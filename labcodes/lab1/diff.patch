Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/bin/bootblock and ./bin/bootblock differ
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/bin/kernel and ./bin/kernel differ
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/bin/sign and ./bin/sign differ
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/bin/ucore.img and ./bin/ucore.img differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/boot/bootasm.S ./boot/bootasm.S
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/boot/bootasm.S	2021-03-18 17:08:00.000000000 +0800
+++ ./boot/bootasm.S	2022-10-09 19:05:15.383151941 +0800
@@ -5,16 +5,16 @@
 # memory at physical address 0x7c00 and starts executing in real mode
 # with %cs=0 %ip=7c00.
 
-.set PROT_MODE_CSEG,        0x8                     # kernel code segment selector
-.set PROT_MODE_DSEG,        0x10                    # kernel data segment selector
+.set PROT_MODE_CSEG,        0x8                     # kernel code segment selector:index=1;TI=0b0;RPL=0b00 (TI=0代表应该访问全局描述符表（GDT），TI=1代表应该访问局部描述符表（LDT）)
+.set PROT_MODE_DSEG,        0x10                    # kernel data segment selector:index=2;TI=0b0;RPL=0b00
 .set CR0_PE_ON,             0x1                     # protected mode enable flag
 
 # start address should be 0:7c00, in real mode, the beginning address of the running bootloader
 .globl start
 start:
 .code16                                             # Assemble for 16-bit mode
-    cli                                             # Disable interrupts
-    cld                                             # String operations increment
+    cli                                             # Disable interrupts，之前BIOS运行时，可能打开了中断，而后面打开A20 Gate需要给键盘端口发送指令，而且操作系统还未加载，也无法处理中断.（猜测）
+    cld                                             # String operations increment，串处理指令，例如movs,执行后指针寄存器(si, di)自增1
 
     # Set up the important data segment registers (DS, ES, SS).
     xorw %ax, %ax                                   # Segment number zero
@@ -28,9 +28,9 @@
     #  1MB wrap around to zero by default. This code undoes this.
 seta20.1:
     inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
-    testb $0x2, %al
+    testb $0x2, %al                                 # Status Register（0x64端口) 的 bit1 代表 input register (60h/64h) 有数据
     jnz seta20.1
-
+    # 向键盘输入缓冲器(0x64端口)写一个控制命令(0xd1)
     movb $0xd1, %al                                 # 0xd1 -> port 0x64
     outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port
 
@@ -38,7 +38,7 @@
     inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
     testb $0x2, %al
     jnz seta20.2
-
+    # 向键盘输入缓冲器(0x60端口)写入0xdf
     movb $0xdf, %al                                 # 0xdf -> port 0x60
     outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
 
@@ -46,14 +46,14 @@
     # and segment translation that makes virtual addresses
     # identical to physical addresses, so that the
     # effective memory map does not change during the switch.
-    lgdt gdtdesc
-    movl %cr0, %eax
+    lgdt gdtdesc                                    # 加载全局描述符表放入GDTR寄存器
+    movl %cr0, %eax                                 # cr0寄存器0位是保护允许位PE(Protedted Enable)，用于启动保护模式，如果PE位置1，则保护模式启动，如果PE=0，则在实模式下运行。
     orl $CR0_PE_ON, %eax
     movl %eax, %cr0
 
     # Jump to next instruction, but in 32-bit code segment.
     # Switches processor into 32-bit mode.
-    ljmp $PROT_MODE_CSEG, $protcseg
+    ljmp $PROT_MODE_CSEG, $protcseg                 # 第一个参数是段，第二个参数是偏移量
 
 .code32                                             # Assemble for 32-bit mode
 protcseg:
@@ -75,12 +75,12 @@
     jmp spin
 
 # Bootstrap GDT
-.p2align 2                                          # force 4 byte alignment
-gdt:
+.p2align 2                                          # force 4 byte alignment， 将位置计数器移动到4字节的倍数，如果已经是4字节的倍数则不会发生变化。
+gdt:                                                # 关于SEG_ASM（段描述符）的定义在ASM.h中，以type，base，lim为参数定义一个段描述符
     SEG_NULLASM                                     # null seg
-    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel
-    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel
-
+    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel，可读可执行
+    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel，可写但不可执行
+# GDTR长48位，其中高32位为基地址，低16位为段界限
 gdtdesc:
-    .word 0x17                                      # sizeof(gdt) - 1
-    .long gdt                                       # address gdt
+    .word 0x17                                      # sizeof(gdt) - 1，为什么是sizeof(gdt) - 1而不是sizeof(gdt)我也不是特别清楚，据说是规定
+    .long gdt                                       # address gdt，.long后面的参数为gdt运行时生成的值，即gdt表的地址
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/boot/bootmain.c ./boot/bootmain.c
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/boot/bootmain.c	2021-03-18 17:08:00.000000000 +0800
+++ ./boot/bootmain.c	2022-10-09 15:38:09.061690953 +0800
@@ -40,18 +40,18 @@
         /* do nothing */;
 }
 
-/* readsect - read a single sector at @secno into @dst */
+/* readsect - read a single sector at @secno into @dst，bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。 */
 static void
 readsect(void *dst, uint32_t secno) {
     // wait for disk to be ready
     waitdisk();
-
-    outb(0x1F2, 1);                         // count = 1
-    outb(0x1F3, secno & 0xFF);
-    outb(0x1F4, (secno >> 8) & 0xFF);
-    outb(0x1F5, (secno >> 16) & 0xFF);
-    outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0);
-    outb(0x1F7, 0x20);                      // cmd 0x20 - read sectors
+    // 发出读取扇区的命令
+    outb(0x1F2, 1);                            // count = 1，读一个扇区
+    outb(0x1F3, secno & 0xFF);                 // LBA参数的0-7位
+    outb(0x1F4, (secno >> 8) & 0xFF);          // LBA参数的8-15位
+    outb(0x1F5, (secno >> 16) & 0xFF);         // LBA参数的16-23位
+    outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0); // 第0~3位是LBA模式的24-27位;第4位为0，代表主盘;第6位：为1=LBA模式(0 = CHS模式);第7位和第5位必须为1
+    outb(0x1F7, 0x20);                         // cmd 0x20 - read sectors
 
     // wait for disk to be ready
     waitdisk();
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/diff.patch ./diff.patch
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/diff.patch	1970-01-01 08:00:00.000000000 +0800
+++ ./diff.patch	2022-10-09 20:28:07.095296396 +0800
@@ -0,0 +1,117 @@
+Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/bin/bootblock and ./bin/bootblock differ
+Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/bin/kernel and ./bin/kernel differ
+Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/bin/sign and ./bin/sign differ
+Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/bin/ucore.img and ./bin/ucore.img differ
+diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/boot/bootasm.S ./boot/bootasm.S
+--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/boot/bootasm.S	2021-03-18 17:08:00.000000000 +0800
++++ ./boot/bootasm.S	2022-10-09 19:05:15.383151941 +0800
+@@ -5,16 +5,16 @@
+ # memory at physical address 0x7c00 and starts executing in real mode
+ # with %cs=0 %ip=7c00.
+ 
+-.set PROT_MODE_CSEG,        0x8                     # kernel code segment selector
+-.set PROT_MODE_DSEG,        0x10                    # kernel data segment selector
++.set PROT_MODE_CSEG,        0x8                     # kernel code segment selector:index=1;TI=0b0;RPL=0b00 (TI=0代表应该访问全局描述符表（GDT），TI=1代表应该访问局部描述符表（LDT）)
++.set PROT_MODE_DSEG,        0x10                    # kernel data segment selector:index=2;TI=0b0;RPL=0b00
+ .set CR0_PE_ON,             0x1                     # protected mode enable flag
+ 
+ # start address should be 0:7c00, in real mode, the beginning address of the running bootloader
+ .globl start
+ start:
+ .code16                                             # Assemble for 16-bit mode
+-    cli                                             # Disable interrupts
+-    cld                                             # String operations increment
++    cli                                             # Disable interrupts，之前BIOS运行时，可能打开了中断，而后面打开A20 Gate需要给键盘端口发送指令，而且操作系统还未加载，也无法处理中断.（猜测）
++    cld                                             # String operations increment，串处理指令，例如movs,执行后指针寄存器(si, di)自增1
+ 
+     # Set up the important data segment registers (DS, ES, SS).
+     xorw %ax, %ax                                   # Segment number zero
+@@ -28,9 +28,9 @@
+     #  1MB wrap around to zero by default. This code undoes this.
+ seta20.1:
+     inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
+-    testb $0x2, %al
++    testb $0x2, %al                                 # Status Register（0x64端口) 的 bit1 代表 input register (60h/64h) 有数据
+     jnz seta20.1
+-
++    # 向键盘输入缓冲器(0x64端口)写一个控制命令(0xd1)
+     movb $0xd1, %al                                 # 0xd1 -> port 0x64
+     outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port
+ 
+@@ -38,7 +38,7 @@
+     inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
+     testb $0x2, %al
+     jnz seta20.2
+-
++    # 向键盘输入缓冲器(0x60端口)写入0xdf
+     movb $0xdf, %al                                 # 0xdf -> port 0x60
+     outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
+ 
+@@ -46,14 +46,14 @@
+     # and segment translation that makes virtual addresses
+     # identical to physical addresses, so that the
+     # effective memory map does not change during the switch.
+-    lgdt gdtdesc
+-    movl %cr0, %eax
++    lgdt gdtdesc                                    # 加载全局描述符表放入GDTR寄存器
++    movl %cr0, %eax                                 # cr0寄存器0位是保护允许位PE(Protedted Enable)，用于启动保护模式，如果PE位置1，则保护模式启动，如果PE=0，则在实模式下运行。
+     orl $CR0_PE_ON, %eax
+     movl %eax, %cr0
+ 
+     # Jump to next instruction, but in 32-bit code segment.
+     # Switches processor into 32-bit mode.
+-    ljmp $PROT_MODE_CSEG, $protcseg
++    ljmp $PROT_MODE_CSEG, $protcseg                 # 第一个参数是段，第二个参数是偏移量
+ 
+ .code32                                             # Assemble for 32-bit mode
+ protcseg:
+@@ -75,12 +75,12 @@
+     jmp spin
+ 
+ # Bootstrap GDT
+-.p2align 2                                          # force 4 byte alignment
+-gdt:
++.p2align 2                                          # force 4 byte alignment， 将位置计数器移动到4字节的倍数，如果已经是4字节的倍数则不会发生变化。
++gdt:                                                # 关于SEG_ASM（段描述符）的定义在ASM.h中，以type，base，lim为参数定义一个段描述符
+     SEG_NULLASM                                     # null seg
+-    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel
+-    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel
+-
++    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel，可读可执行
++    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel，可写但不可执行
++# GDTR长48位，其中高32位为基地址，低16位为段界限
+ gdtdesc:
+-    .word 0x17                                      # sizeof(gdt) - 1
+-    .long gdt                                       # address gdt
++    .word 0x17                                      # sizeof(gdt) - 1，为什么是sizeof(gdt) - 1而不是sizeof(gdt)我也不是特别清楚，据说是规定
++    .long gdt                                       # address gdt，.long后面的参数为gdt运行时生成的值，即gdt表的地址
+diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/boot/bootmain.c ./boot/bootmain.c
+--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/boot/bootmain.c	2021-03-18 17:08:00.000000000 +0800
++++ ./boot/bootmain.c	2022-10-09 15:38:09.061690953 +0800
+@@ -40,18 +40,18 @@
+         /* do nothing */;
+ }
+ 
+-/* readsect - read a single sector at @secno into @dst */
++/* readsect - read a single sector at @secno into @dst，bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。 */
+ static void
+ readsect(void *dst, uint32_t secno) {
+     // wait for disk to be ready
+     waitdisk();
+-
+-    outb(0x1F2, 1);                         // count = 1
+-    outb(0x1F3, secno & 0xFF);
+-    outb(0x1F4, (secno >> 8) & 0xFF);
+-    outb(0x1F5, (secno >> 16) & 0xFF);
+-    outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0);
+-    outb(0x1F7, 0x20);                      // cmd 0x20 - read sectors
++    // 发出读取扇区的命令
++    outb(0x1F2, 1);                            // count = 1，读一个扇区
++    outb(0x1F3, secno & 0xFF);                 // LBA参数的0-7位
++    outb(0x1F4, (secno >> 8) & 0xFF);          // LBA参数的8-15位
++    outb(0x1F5, (secno >> 16) & 0xFF);         // LBA参数的16-23位
++    outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0); // 第0~3位是LBA模式的24-27位;第4位为0，代表主盘;第6位：为1=LBA模式(0 = CHS模式);第7位和第5位必须为1
++    outb(0x1F7, 0x20);                         // cmd 0x20 - read sectors
+ 
+     // wait for disk to be ready
+     waitdisk();
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/kern/debug/kdebug.c ./kern/debug/kdebug.c
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/kern/debug/kdebug.c	2021-03-18 17:08:00.000000000 +0800
+++ ./kern/debug/kdebug.c	2022-10-09 20:26:05.069727532 +0800
@@ -247,6 +247,8 @@
     }
 }
 
+// read_eip必须定义为常规函数而不是inline函数，因为这样的话在调用read_eip时会把当前指令的下一条指令的地址（也就是eip寄存器的值）压栈，
+// 那么在进入read_eip函数内部后便可以从栈中获取到调用前eip寄存器的值。
 static __noinline uint32_t
 read_eip(void) {
     uint32_t eip;
@@ -295,12 +297,19 @@
       * (2) call read_eip() to get the value of eip. the type is (uint32_t);
       * (3) from 0 .. STACKFRAME_DEPTH
       *    (3.1) printf value of ebp, eip
-      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]
+      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t*)ebp +2 [0..4]
       *    (3.3) cprintf("\n");
       *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.
       *    (3.5) popup a calling stackframe
       *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
       *                   the calling funciton's ebp = ss:[ebp]
       */
+     uint32_t ebp = read_ebp(), eip = read_eip();//对应(1)、(2)
+     while (ebp)
+     {
+        cprintf("ebp:0x%08x eip:0x%08x args:0x%08x 0x%08x 0x%08x 0x%08x\n", ebp, eip, ((uint32_t*)ebp + 2)[0], ((uint32_t*)ebp + 2)[1], ((uint32_t*)ebp + 2)[2], ((uint32_t*)ebp + 2)[3]); //对应(3.1)、(3.2)、(3.3)
+        print_debuginfo(eip - 1); //对应(3.4)，由于变量eip存放的是下一条指令的地址，因此将变量eip的值减去1，得到的指令地址就属于当前指令的范围了。由于只要输入的地址属于当前指令的起始和结束位置之间，print_debuginfo都能搜索到当前指令，因此这里减去1即可。
+        eip = *(uint32_t*)(ebp + 4), ebp = *(uint32_t*)ebp; //对应(3.5)，这里默认ss基址为0
+     }
 }
 
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/libs/elf.h ./libs/elf.h
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/libs/elf.h	2021-03-18 17:08:00.000000000 +0800
+++ ./libs/elf.h	2022-10-09 14:39:43.699596059 +0800
@@ -5,33 +5,33 @@
 
 #define ELF_MAGIC    0x464C457FU            // "\x7FELF" in little endian
 
-/* file header */
+/* file header，ELF的文件头包含整个执行文件的控制结构 */
 struct elfhdr {
     uint32_t e_magic;     // must equal ELF_MAGIC
     uint8_t e_elf[12];
     uint16_t e_type;      // 1=relocatable, 2=executable, 3=shared object, 4=core image
     uint16_t e_machine;   // 3=x86, 4=68K, etc.
     uint32_t e_version;   // file version, always 1
-    uint32_t e_entry;     // entry point if executable
-    uint32_t e_phoff;     // file position of program header or 0
+    uint32_t e_entry;     // entry point if executable，程序入口的虚拟地址
+    uint32_t e_phoff;     // file position of program header or 0，program header 表的位置偏移
     uint32_t e_shoff;     // file position of section header or 0
     uint32_t e_flags;     // architecture-specific flags, usually 0
     uint16_t e_ehsize;    // size of this elf header
     uint16_t e_phentsize; // size of an entry in program header
-    uint16_t e_phnum;     // number of entries in program header or 0
+    uint16_t e_phnum;     // number of entries in program header or 0，program header表中的入口数目
     uint16_t e_shentsize; // size of an entry in section header
     uint16_t e_shnum;     // number of entries in section header or 0
     uint16_t e_shstrndx;  // section number that contains section name strings
 };
 
-/* program section header */
+/* program section header，program header描述与程序执行直接相关的目标文件结构信息，用来在文件中定位各个段的映像，同时包含其他一些用来为程序创建进程映像所必需的信息。*/
 struct proghdr {
-    uint32_t p_type;   // loadable code or data, dynamic linking info,etc.
-    uint32_t p_offset; // file offset of segment
-    uint32_t p_va;     // virtual address to map segment
+    uint32_t p_type;   // loadable code or data, dynamic linking info,etc.段类型
+    uint32_t p_offset; // file offset of segment 段相对文件头的偏移值
+    uint32_t p_va;     // virtual address to map segment 段的第一个字节将被放到内存中的虚拟地址
     uint32_t p_pa;     // physical address, not used
     uint32_t p_filesz; // size of segment in file
-    uint32_t p_memsz;  // size of segment in memory (bigger if contains bss）
+    uint32_t p_memsz;  // size of segment in memory (bigger if contains bss）段在内存映像中占用的字节数
     uint32_t p_flags;  // read/write/execute bits
     uint32_t p_align;  // required alignment, invariably hardware page size
 };
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/libs/x86.h ./libs/x86.h
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/libs/x86.h	2021-03-18 17:08:00.000000000 +0800
+++ ./libs/x86.h	2022-10-09 17:53:57.595417347 +0800
@@ -45,11 +45,13 @@
 static inline void
 insl(uint32_t port, void *addr, int cnt) {
     asm volatile (
-            "cld;"
-            "repne; insl;"
-            : "=D" (addr), "=c" (cnt)
-            : "d" (port), "0" (addr), "1" (cnt)
-            : "memory", "cc");
+            "cld;"                                  // cld指每次串操作，自动增加指针寄存器(di,si)寄存器值
+            "repne; insl;"                          // repne是重复执行接下来的insl指令，重复次数由ecx寄存器决定。insl就是从指定端口读取4字节长度的串操作。
+            : "=D" (addr), "=c" (cnt)               // 输出寄存器是di(输出给addr变量), ecx(输出给cnt变量)
+            : "d" (port), "0" (addr), "1" (cnt)     // 输入寄存器是edx(初始值由port变量提供)， di（初始值由addr变量提供)， ecx(初始值由cnt变量提供)
+            : "memory", "cc");                      // When you do the clobber list, you specify the registers as above with the %. 
+                                                    // If you write to a variable, you must include "memory" as one of The Clobbered. This is in case you wrote to a variable that GCC thought it had in a register. This is the same as clobbering all registers. 
+                                                    // While I've never run into a problem with it, you might also want to add "cc" as a clobber if you change the condition codes (the bits in the flags register the jnz, je, etc. operators look at.)
 }
 
 static inline void
@@ -62,6 +64,7 @@
     asm volatile ("outw %0, %1" :: "a" (data), "d" (port));
 }
 
+// read_ebp必须定义为inline函数，否则获取的是执行read_ebp函数时的ebp寄存器的值
 static inline uint32_t
 read_ebp(void) {
     uint32_t ebp;
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/Makefile ./Makefile
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/Makefile	2021-03-18 17:08:00.000000000 +0800
+++ ./Makefile	2022-10-08 20:43:55.139662941 +0800
@@ -4,7 +4,7 @@
 SLASH	:= /
 
 V       := @
-#need llvm/cang-3.5+
+#need llvm/clang-3.5+
 #USELLVM := 1
 # try to infer the correct GCCPREFX
 ifndef GCCPREFIX
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/boot/bootasm.d ./obj/boot/bootasm.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/boot/bootasm.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/boot/bootasm.d	2022-10-09 19:28:57.506061272 +0800
@@ -0,0 +1 @@
+obj/boot/bootasm.o obj/boot/bootasm.d: boot/bootasm.S boot/asm.h
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/boot/bootasm.o and ./obj/boot/bootasm.o differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/boot/bootmain.d ./obj/boot/bootmain.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/boot/bootmain.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/boot/bootmain.d	2022-10-09 18:19:16.163723175 +0800
@@ -0,0 +1,2 @@
+obj/boot/bootmain.o obj/boot/bootmain.d: boot/bootmain.c libs/defs.h \
+ libs/x86.h libs/elf.h
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/boot/bootmain.o and ./obj/boot/bootmain.o differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/bootblock.asm ./obj/bootblock.asm
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/bootblock.asm	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/bootblock.asm	2022-10-09 19:28:57.994061889 +0800
@@ -0,0 +1,306 @@
+
+obj/bootblock.o:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00007c00 <start>:
+
+# start address should be 0:7c00, in real mode, the beginning address of the running bootloader
+.globl start
+start:
+.code16                                             # Assemble for 16-bit mode
+    cli                                             # Disable interrupts，之前BIOS运行时，可能打开了中断，而后面打开A20 Gate需要给键盘端口发送指令，而且操作系统还未加载，也无法处理中断.（猜测）
+    7c00:	fa                   	cli    
+    cld                                             # String operations increment，串处理指令，例如movs,执行后指针寄存器(si, di)自增1
+    7c01:	fc                   	cld    
+
+    # Set up the important data segment registers (DS, ES, SS).
+    xorw %ax, %ax                                   # Segment number zero
+    7c02:	31 c0                	xor    %eax,%eax
+    movw %ax, %ds                                   # -> Data Segment
+    7c04:	8e d8                	mov    %eax,%ds
+    movw %ax, %es                                   # -> Extra Segment
+    7c06:	8e c0                	mov    %eax,%es
+    movw %ax, %ss                                   # -> Stack Segment
+    7c08:	8e d0                	mov    %eax,%ss
+
+00007c0a <seta20.1>:
+    # Enable A20:
+    #  For backwards compatibility with the earliest PCs, physical
+    #  address line 20 is tied low, so that addresses higher than
+    #  1MB wrap around to zero by default. This code undoes this.
+seta20.1:
+    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
+    7c0a:	e4 64                	in     $0x64,%al
+    testb $0x2, %al                                 # Status Register（0x64端口) 的 bit1 代表 input register (60h/64h) 有数据
+    7c0c:	a8 02                	test   $0x2,%al
+    jnz seta20.1
+    7c0e:	75 fa                	jne    7c0a <seta20.1>
+    # 向键盘输入缓冲器(0x64端口)写一个控制命令(0xd1)
+    movb $0xd1, %al                                 # 0xd1 -> port 0x64
+    7c10:	b0 d1                	mov    $0xd1,%al
+    outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port
+    7c12:	e6 64                	out    %al,$0x64
+
+00007c14 <seta20.2>:
+
+seta20.2:
+    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
+    7c14:	e4 64                	in     $0x64,%al
+    testb $0x2, %al
+    7c16:	a8 02                	test   $0x2,%al
+    jnz seta20.2
+    7c18:	75 fa                	jne    7c14 <seta20.2>
+    # 向键盘输入缓冲器(0x60端口)写入0xdf
+    movb $0xdf, %al                                 # 0xdf -> port 0x60
+    7c1a:	b0 df                	mov    $0xdf,%al
+    outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
+    7c1c:	e6 60                	out    %al,$0x60
+
+    # Switch from real to protected mode, using a bootstrap GDT
+    # and segment translation that makes virtual addresses
+    # identical to physical addresses, so that the
+    # effective memory map does not change during the switch.
+    lgdt gdtdesc                                    # 加载全局描述符表放入GDTR寄存器
+    7c1e:	0f 01 16             	lgdtl  (%esi)
+    7c21:	6c                   	insb   (%dx),%es:(%edi)
+    7c22:	7c 0f                	jl     7c33 <protcseg+0x1>
+    movl %cr0, %eax                                 # cr0寄存器0位是保护允许位PE(Protedted Enable)，用于启动保护模式，如果PE位置1，则保护模式启动，如果PE=0，则在实模式下运行。
+    7c24:	20 c0                	and    %al,%al
+    orl $CR0_PE_ON, %eax
+    7c26:	66 83 c8 01          	or     $0x1,%ax
+    movl %eax, %cr0
+    7c2a:	0f 22 c0             	mov    %eax,%cr0
+
+    # Jump to next instruction, but in 32-bit code segment.
+    # Switches processor into 32-bit mode.
+    ljmp $PROT_MODE_CSEG, $protcseg                 # 第一个参数是段，第二个参数是偏移量
+    7c2d:	ea                   	.byte 0xea
+    7c2e:	32 7c 08 00          	xor    0x0(%eax,%ecx,1),%bh
+
+00007c32 <protcseg>:
+
+.code32                                             # Assemble for 32-bit mode
+protcseg:
+    # Set up the protected-mode data segment registers
+    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector
+    7c32:	66 b8 10 00          	mov    $0x10,%ax
+    movw %ax, %ds                                   # -> DS: Data Segment
+    7c36:	8e d8                	mov    %eax,%ds
+    movw %ax, %es                                   # -> ES: Extra Segment
+    7c38:	8e c0                	mov    %eax,%es
+    movw %ax, %fs                                   # -> FS
+    7c3a:	8e e0                	mov    %eax,%fs
+    movw %ax, %gs                                   # -> GS
+    7c3c:	8e e8                	mov    %eax,%gs
+    movw %ax, %ss                                   # -> SS: Stack Segment
+    7c3e:	8e d0                	mov    %eax,%ss
+
+    # Set up the stack pointer and call into C. The stack region is from 0--start(0x7c00)
+    movl $0x0, %ebp
+    7c40:	bd 00 00 00 00       	mov    $0x0,%ebp
+    movl $start, %esp
+    7c45:	bc 00 7c 00 00       	mov    $0x7c00,%esp
+    call bootmain
+    7c4a:	e8 ae 00 00 00       	call   7cfd <bootmain>
+
+00007c4f <spin>:
+
+    # If bootmain returns (it shouldn't), loop.
+spin:
+    jmp spin
+    7c4f:	eb fe                	jmp    7c4f <spin>
+    7c51:	8d 76 00             	lea    0x0(%esi),%esi
+
+00007c54 <gdt>:
+	...
+    7c5c:	ff                   	(bad)  
+    7c5d:	ff 00                	incl   (%eax)
+    7c5f:	00 00                	add    %al,(%eax)
+    7c61:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
+    7c68:	00                   	.byte 0x0
+    7c69:	92                   	xchg   %eax,%edx
+    7c6a:	cf                   	iret   
+	...
+
+00007c6c <gdtdesc>:
+    7c6c:	17                   	pop    %ss
+    7c6d:	00 54 7c 00          	add    %dl,0x0(%esp,%edi,2)
+	...
+
+00007c72 <readseg>:
+/* *
+ * readseg - read @count bytes at @offset from kernel into virtual address @va,
+ * might copy more than asked.
+ * */
+static void
+readseg(uintptr_t va, uint32_t count, uint32_t offset) {
+    7c72:	55                   	push   %ebp
+    uintptr_t end_va = va + count;
+    7c73:	01 c2                	add    %eax,%edx
+readseg(uintptr_t va, uint32_t count, uint32_t offset) {
+    7c75:	89 e5                	mov    %esp,%ebp
+    7c77:	57                   	push   %edi
+    7c78:	56                   	push   %esi
+
+    // round down to sector boundary
+    va -= offset % SECTSIZE;
+    7c79:	89 c6                	mov    %eax,%esi
+readseg(uintptr_t va, uint32_t count, uint32_t offset) {
+    7c7b:	53                   	push   %ebx
+    7c7c:	53                   	push   %ebx
+    uintptr_t end_va = va + count;
+    7c7d:	89 55 f0             	mov    %edx,-0x10(%ebp)
+    va -= offset % SECTSIZE;
+    7c80:	89 ca                	mov    %ecx,%edx
+    7c82:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
+
+    // translate from bytes to sectors; kernel starts at sector 1
+    uint32_t secno = (offset / SECTSIZE) + 1;
+    7c88:	c1 e9 09             	shr    $0x9,%ecx
+    va -= offset % SECTSIZE;
+    7c8b:	29 d6                	sub    %edx,%esi
+    uint32_t secno = (offset / SECTSIZE) + 1;
+    7c8d:	8d 59 01             	lea    0x1(%ecx),%ebx
+
+    // If this is too slow, we could read lots of sectors at a time.
+    // We'd write more to memory than asked, but it doesn't matter --
+    // we load in increasing order.
+    for (; va < end_va; va += SECTSIZE, secno ++) {
+    7c90:	eb 60                	jmp    7cf2 <readseg+0x80>
+static inline void ltr(uint16_t sel) __attribute__((always_inline));
+
+static inline uint8_t
+inb(uint16_t port) {
+    uint8_t data;
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+    7c92:	ba f7 01 00 00       	mov    $0x1f7,%edx
+    7c97:	ec                   	in     (%dx),%al
+    while ((inb(0x1F7) & 0xC0) != 0x40)
+    7c98:	83 e0 c0             	and    $0xffffffc0,%eax
+    7c9b:	3c 40                	cmp    $0x40,%al
+    7c9d:	75 f3                	jne    7c92 <readseg+0x20>
+                                                    // While I've never run into a problem with it, you might also want to add "cc" as a clobber if you change the condition codes (the bits in the flags register the jnz, je, etc. operators look at.)
+}
+
+static inline void
+outb(uint16_t port, uint8_t data) {
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port));
+    7c9f:	b2 f2                	mov    $0xf2,%dl
+    7ca1:	b0 01                	mov    $0x1,%al
+    7ca3:	ee                   	out    %al,(%dx)
+    outw(0x8A00, 0x8A00);
+    outw(0x8A00, 0x8E00);
+
+    /* do nothing */
+    while (1);
+}
+    7ca4:	0f b6 c3             	movzbl %bl,%eax
+    7ca7:	b2 f3                	mov    $0xf3,%dl
+    7ca9:	ee                   	out    %al,(%dx)
+    7caa:	0f b6 c7             	movzbl %bh,%eax
+    7cad:	b2 f4                	mov    $0xf4,%dl
+    7caf:	ee                   	out    %al,(%dx)
+    outb(0x1F5, (secno >> 16) & 0xFF);         // LBA参数的16-23位
+    7cb0:	89 d8                	mov    %ebx,%eax
+    7cb2:	b2 f5                	mov    $0xf5,%dl
+    7cb4:	c1 e8 10             	shr    $0x10,%eax
+}
+    7cb7:	25 ff 00 00 00       	and    $0xff,%eax
+    7cbc:	ee                   	out    %al,(%dx)
+    outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0); // 第0~3位是LBA模式的24-27位;第4位为0，代表主盘;第6位：为1=LBA模式(0 = CHS模式);第7位和第5位必须为1
+    7cbd:	89 d8                	mov    %ebx,%eax
+    7cbf:	b2 f6                	mov    $0xf6,%dl
+    7cc1:	c1 e8 18             	shr    $0x18,%eax
+    7cc4:	83 e0 0f             	and    $0xf,%eax
+    7cc7:	0c e0                	or     $0xe0,%al
+    7cc9:	ee                   	out    %al,(%dx)
+    7cca:	b0 20                	mov    $0x20,%al
+    7ccc:	b2 f7                	mov    $0xf7,%dl
+    7cce:	ee                   	out    %al,(%dx)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+    7ccf:	ba f7 01 00 00       	mov    $0x1f7,%edx
+    7cd4:	ec                   	in     (%dx),%al
+    while ((inb(0x1F7) & 0xC0) != 0x40)
+    7cd5:	83 e0 c0             	and    $0xffffffc0,%eax
+    7cd8:	3c 40                	cmp    $0x40,%al
+    7cda:	75 f3                	jne    7ccf <readseg+0x5d>
+    asm volatile (
+    7cdc:	89 f7                	mov    %esi,%edi
+    7cde:	b9 80 00 00 00       	mov    $0x80,%ecx
+    7ce3:	ba f0 01 00 00       	mov    $0x1f0,%edx
+    7ce8:	fc                   	cld    
+    7ce9:	f2 6d                	repnz insl (%dx),%es:(%edi)
+    for (; va < end_va; va += SECTSIZE, secno ++) {
+    7ceb:	81 c6 00 02 00 00    	add    $0x200,%esi
+    7cf1:	43                   	inc    %ebx
+    7cf2:	3b 75 f0             	cmp    -0x10(%ebp),%esi
+    7cf5:	72 9b                	jb     7c92 <readseg+0x20>
+}
+    7cf7:	58                   	pop    %eax
+    7cf8:	5b                   	pop    %ebx
+    7cf9:	5e                   	pop    %esi
+    7cfa:	5f                   	pop    %edi
+    7cfb:	5d                   	pop    %ebp
+    7cfc:	c3                   	ret    
+
+00007cfd <bootmain>:
+bootmain(void) {
+    7cfd:	55                   	push   %ebp
+    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);
+    7cfe:	31 c9                	xor    %ecx,%ecx
+bootmain(void) {
+    7d00:	89 e5                	mov    %esp,%ebp
+    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);
+    7d02:	ba 00 10 00 00       	mov    $0x1000,%edx
+bootmain(void) {
+    7d07:	56                   	push   %esi
+    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);
+    7d08:	b8 00 00 01 00       	mov    $0x10000,%eax
+bootmain(void) {
+    7d0d:	53                   	push   %ebx
+    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);
+    7d0e:	e8 5f ff ff ff       	call   7c72 <readseg>
+    if (ELFHDR->e_magic != ELF_MAGIC) {
+    7d13:	81 3d 00 00 01 00 7f 	cmpl   $0x464c457f,0x10000
+    7d1a:	45 4c 46 
+    7d1d:	75 41                	jne    7d60 <bootmain+0x63>
+    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);
+    7d1f:	8b 1d 1c 00 01 00    	mov    0x1001c,%ebx
+    eph = ph + ELFHDR->e_phnum;
+    7d25:	0f b7 05 2c 00 01 00 	movzwl 0x1002c,%eax
+    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);
+    7d2c:	81 c3 00 00 01 00    	add    $0x10000,%ebx
+    eph = ph + ELFHDR->e_phnum;
+    7d32:	c1 e0 05             	shl    $0x5,%eax
+    7d35:	8d 34 03             	lea    (%ebx,%eax,1),%esi
+    for (; ph < eph; ph ++) {
+    7d38:	eb 16                	jmp    7d50 <bootmain+0x53>
+        readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);
+    7d3a:	8b 43 08             	mov    0x8(%ebx),%eax
+    7d3d:	8b 4b 04             	mov    0x4(%ebx),%ecx
+    7d40:	8b 53 14             	mov    0x14(%ebx),%edx
+    for (; ph < eph; ph ++) {
+    7d43:	83 c3 20             	add    $0x20,%ebx
+        readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);
+    7d46:	25 ff ff ff 00       	and    $0xffffff,%eax
+    7d4b:	e8 22 ff ff ff       	call   7c72 <readseg>
+    for (; ph < eph; ph ++) {
+    7d50:	39 f3                	cmp    %esi,%ebx
+    7d52:	72 e6                	jb     7d3a <bootmain+0x3d>
+    ((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))();
+    7d54:	a1 18 00 01 00       	mov    0x10018,%eax
+    7d59:	25 ff ff ff 00       	and    $0xffffff,%eax
+    7d5e:	ff d0                	call   *%eax
+}
+
+static inline void
+outw(uint16_t port, uint16_t data) {
+    asm volatile ("outw %0, %1" :: "a" (data), "d" (port));
+    7d60:	ba 00 8a ff ff       	mov    $0xffff8a00,%edx
+    7d65:	89 d0                	mov    %edx,%eax
+    7d67:	66 ef                	out    %ax,(%dx)
+    7d69:	b8 00 8e ff ff       	mov    $0xffff8e00,%eax
+    7d6e:	66 ef                	out    %ax,(%dx)
+    7d70:	eb fe                	jmp    7d70 <bootmain+0x73>
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/bootblock.o and ./obj/bootblock.o differ
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/bootblock.out and ./obj/bootblock.out differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/debug/kdebug.d ./obj/kern/debug/kdebug.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/debug/kdebug.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/kern/debug/kdebug.d	2022-10-09 19:34:01.591313485 +0800
@@ -0,0 +1,3 @@
+obj/kern/debug/kdebug.o obj/kern/debug/kdebug.d: kern/debug/kdebug.c \
+ libs/defs.h libs/x86.h kern/debug/stab.h libs/stdio.h libs/stdarg.h \
+ libs/string.h kern/debug/kdebug.h
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/debug/kdebug.o and ./obj/kern/debug/kdebug.o differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/debug/kmonitor.d ./obj/kern/debug/kmonitor.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/debug/kmonitor.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/kern/debug/kmonitor.d	2022-10-09 18:19:16.371728975 +0800
@@ -0,0 +1,3 @@
+obj/kern/debug/kmonitor.o obj/kern/debug/kmonitor.d: \
+ kern/debug/kmonitor.c libs/stdio.h libs/defs.h libs/stdarg.h \
+ libs/string.h kern/trap/trap.h kern/debug/kmonitor.h kern/debug/kdebug.h
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/debug/kmonitor.o and ./obj/kern/debug/kmonitor.o differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/debug/panic.d ./obj/kern/debug/panic.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/debug/panic.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/kern/debug/panic.d	2022-10-09 18:19:16.407729979 +0800
@@ -0,0 +1,3 @@
+obj/kern/debug/panic.o obj/kern/debug/panic.d: kern/debug/panic.c \
+ libs/defs.h libs/stdio.h libs/stdarg.h kern/driver/intr.h \
+ kern/debug/kmonitor.h kern/trap/trap.h
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/debug/panic.o and ./obj/kern/debug/panic.o differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/driver/clock.d ./obj/kern/driver/clock.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/driver/clock.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/kern/driver/clock.d	2022-10-09 18:19:16.347728306 +0800
@@ -0,0 +1,3 @@
+obj/kern/driver/clock.o obj/kern/driver/clock.d: kern/driver/clock.c \
+ libs/x86.h libs/defs.h kern/trap/trap.h libs/stdio.h libs/stdarg.h \
+ kern/driver/picirq.h
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/driver/clock.o and ./obj/kern/driver/clock.o differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/driver/console.d ./obj/kern/driver/console.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/driver/console.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/kern/driver/console.d	2022-10-09 18:19:16.343728194 +0800
@@ -0,0 +1,3 @@
+obj/kern/driver/console.o obj/kern/driver/console.d: \
+ kern/driver/console.c libs/defs.h libs/x86.h libs/stdio.h libs/stdarg.h \
+ libs/string.h kern/driver/kbdreg.h kern/driver/picirq.h kern/trap/trap.h
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/driver/console.o and ./obj/kern/driver/console.o differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/driver/intr.d ./obj/kern/driver/intr.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/driver/intr.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/kern/driver/intr.d	2022-10-09 18:19:16.311727302 +0800
@@ -0,0 +1,2 @@
+obj/kern/driver/intr.o obj/kern/driver/intr.d: kern/driver/intr.c \
+ libs/x86.h libs/defs.h kern/driver/intr.h
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/driver/intr.o and ./obj/kern/driver/intr.o differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/driver/picirq.d ./obj/kern/driver/picirq.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/driver/picirq.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/kern/driver/picirq.d	2022-10-09 18:19:16.323727637 +0800
@@ -0,0 +1,2 @@
+obj/kern/driver/picirq.o obj/kern/driver/picirq.d: kern/driver/picirq.c \
+ libs/defs.h libs/x86.h kern/driver/picirq.h
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/driver/picirq.o and ./obj/kern/driver/picirq.o differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/init/init.d ./obj/kern/init/init.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/init/init.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/kern/init/init.d	2022-10-09 18:19:16.451731206 +0800
@@ -0,0 +1,5 @@
+obj/kern/init/init.o obj/kern/init/init.d: kern/init/init.c libs/defs.h \
+ libs/stdio.h libs/stdarg.h libs/string.h kern/driver/console.h \
+ kern/debug/kdebug.h kern/driver/picirq.h kern/trap/trap.h \
+ kern/driver/clock.h kern/driver/intr.h kern/mm/pmm.h \
+ kern/debug/kmonitor.h
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/init/init.o and ./obj/kern/init/init.o differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/libs/readline.d ./obj/kern/libs/readline.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/libs/readline.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/kern/libs/readline.d	2022-10-09 18:19:16.427730536 +0800
@@ -0,0 +1,2 @@
+obj/kern/libs/readline.o obj/kern/libs/readline.d: kern/libs/readline.c \
+ libs/stdio.h libs/defs.h libs/stdarg.h
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/libs/readline.o and ./obj/kern/libs/readline.o differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/libs/stdio.d ./obj/kern/libs/stdio.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/libs/stdio.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/kern/libs/stdio.d	2022-10-09 18:19:16.435730760 +0800
@@ -0,0 +1,2 @@
+obj/kern/libs/stdio.o obj/kern/libs/stdio.d: kern/libs/stdio.c \
+ libs/defs.h libs/stdio.h libs/stdarg.h kern/driver/console.h
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/libs/stdio.o and ./obj/kern/libs/stdio.o differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/mm/pmm.d ./obj/kern/mm/pmm.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/mm/pmm.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/kern/mm/pmm.d	2022-10-09 18:19:16.235725183 +0800
@@ -0,0 +1,2 @@
+obj/kern/mm/pmm.o obj/kern/mm/pmm.d: kern/mm/pmm.c libs/defs.h libs/x86.h \
+ kern/mm/mmu.h kern/mm/memlayout.h kern/mm/pmm.h
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/mm/pmm.o and ./obj/kern/mm/pmm.o differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/trap/trap.d ./obj/kern/trap/trap.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/trap/trap.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/kern/trap/trap.d	2022-10-09 18:19:16.295726856 +0800
@@ -0,0 +1,4 @@
+obj/kern/trap/trap.o obj/kern/trap/trap.d: kern/trap/trap.c libs/defs.h \
+ kern/mm/mmu.h kern/mm/memlayout.h kern/driver/clock.h kern/trap/trap.h \
+ libs/x86.h libs/stdio.h libs/stdarg.h kern/debug/assert.h \
+ kern/driver/console.h kern/debug/kdebug.h
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/trap/trapentry.d ./obj/kern/trap/trapentry.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/trap/trapentry.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/kern/trap/trapentry.d	2022-10-09 18:19:16.263725964 +0800
@@ -0,0 +1,2 @@
+obj/kern/trap/trapentry.o obj/kern/trap/trapentry.d: \
+ kern/trap/trapentry.S kern/mm/memlayout.h
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/trap/trapentry.o and ./obj/kern/trap/trapentry.o differ
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/trap/trap.o and ./obj/kern/trap/trap.o differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/trap/vectors.d ./obj/kern/trap/vectors.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/trap/vectors.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/kern/trap/vectors.d	2022-10-09 18:19:16.271726186 +0800
@@ -0,0 +1 @@
+obj/kern/trap/vectors.o obj/kern/trap/vectors.d: kern/trap/vectors.S
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kern/trap/vectors.o and ./obj/kern/trap/vectors.o differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kernel.asm ./obj/kernel.asm
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kernel.asm	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/kernel.asm	2022-10-09 19:34:01.727314364 +0800
@@ -0,0 +1,7815 @@
+
+bin/kernel:     file format elf32-i386
+
+
+Disassembly of section .text:
+
+00100000 <kern_init>:
+int kern_init(void) __attribute__((noreturn));
+void grade_backtrace(void);
+static void lab1_switch_test(void);
+
+int
+kern_init(void) {
+  100000:	55                   	push   %ebp
+  100001:	89 e5                	mov    %esp,%ebp
+  100003:	83 ec 28             	sub    $0x28,%esp
+    extern char edata[], end[];
+    memset(edata, 0, end - edata);
+  100006:	ba 20 fd 10 00       	mov    $0x10fd20,%edx
+  10000b:	b8 16 ea 10 00       	mov    $0x10ea16,%eax
+  100010:	89 d1                	mov    %edx,%ecx
+  100012:	29 c1                	sub    %eax,%ecx
+  100014:	89 c8                	mov    %ecx,%eax
+  100016:	89 44 24 08          	mov    %eax,0x8(%esp)
+  10001a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  100021:	00 
+  100022:	c7 04 24 16 ea 10 00 	movl   $0x10ea16,(%esp)
+  100029:	e8 3e 2b 00 00       	call   102b6c <memset>
+
+    cons_init();                // init the console
+  10002e:	e8 cd 15 00 00       	call   101600 <cons_init>
+
+    const char *message = "(THU.CST) os is loading ...";
+  100033:	c7 45 f4 00 34 10 00 	movl   $0x103400,-0xc(%ebp)
+    cprintf("%s\n\n", message);
+  10003a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10003d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100041:	c7 04 24 1c 34 10 00 	movl   $0x10341c,(%esp)
+  100048:	e8 11 02 00 00       	call   10025e <cprintf>
+
+    print_kerninfo();
+  10004d:	e8 d5 08 00 00       	call   100927 <print_kerninfo>
+
+    grade_backtrace();
+  100052:	e8 86 00 00 00       	call   1000dd <grade_backtrace>
+
+    pmm_init();                 // init physical memory management
+  100057:	e8 c7 27 00 00       	call   102823 <pmm_init>
+
+    pic_init();                 // init interrupt controller
+  10005c:	e8 dc 16 00 00       	call   10173d <pic_init>
+    idt_init();                 // init interrupt descriptor table
+  100061:	e8 3a 18 00 00       	call   1018a0 <idt_init>
+
+    clock_init();               // init clock interrupt
+  100066:	e8 ea 0c 00 00       	call   100d55 <clock_init>
+    intr_enable();              // enable irq interrupt
+  10006b:	e8 08 18 00 00       	call   101878 <intr_enable>
+    //LAB1: CAHLLENGE 1 If you try to do it, uncomment lab1_switch_test()
+    // user/kernel mode switch test
+    //lab1_switch_test();
+
+    /* do nothing */
+    while (1);
+  100070:	eb fe                	jmp    100070 <kern_init+0x70>
+
+00100072 <grade_backtrace2>:
+}
+
+void __attribute__((noinline))
+grade_backtrace2(int arg0, int arg1, int arg2, int arg3) {
+  100072:	55                   	push   %ebp
+  100073:	89 e5                	mov    %esp,%ebp
+  100075:	83 ec 18             	sub    $0x18,%esp
+    mon_backtrace(0, NULL, NULL);
+  100078:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
+  10007f:	00 
+  100080:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
+  100087:	00 
+  100088:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  10008f:	e8 af 0c 00 00       	call   100d43 <mon_backtrace>
+}
+  100094:	c9                   	leave  
+  100095:	c3                   	ret    
+
+00100096 <grade_backtrace1>:
+
+void __attribute__((noinline))
+grade_backtrace1(int arg0, int arg1) {
+  100096:	55                   	push   %ebp
+  100097:	89 e5                	mov    %esp,%ebp
+  100099:	53                   	push   %ebx
+  10009a:	83 ec 14             	sub    $0x14,%esp
+    grade_backtrace2(arg0, (int)&arg0, arg1, (int)&arg1);
+  10009d:	8d 5d 0c             	lea    0xc(%ebp),%ebx
+  1000a0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
+  1000a3:	8d 55 08             	lea    0x8(%ebp),%edx
+  1000a6:	8b 45 08             	mov    0x8(%ebp),%eax
+  1000a9:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  1000ad:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  1000b1:	89 54 24 04          	mov    %edx,0x4(%esp)
+  1000b5:	89 04 24             	mov    %eax,(%esp)
+  1000b8:	e8 b5 ff ff ff       	call   100072 <grade_backtrace2>
+}
+  1000bd:	83 c4 14             	add    $0x14,%esp
+  1000c0:	5b                   	pop    %ebx
+  1000c1:	5d                   	pop    %ebp
+  1000c2:	c3                   	ret    
+
+001000c3 <grade_backtrace0>:
+
+void __attribute__((noinline))
+grade_backtrace0(int arg0, int arg1, int arg2) {
+  1000c3:	55                   	push   %ebp
+  1000c4:	89 e5                	mov    %esp,%ebp
+  1000c6:	83 ec 18             	sub    $0x18,%esp
+    grade_backtrace1(arg0, arg2);
+  1000c9:	8b 45 10             	mov    0x10(%ebp),%eax
+  1000cc:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1000d0:	8b 45 08             	mov    0x8(%ebp),%eax
+  1000d3:	89 04 24             	mov    %eax,(%esp)
+  1000d6:	e8 bb ff ff ff       	call   100096 <grade_backtrace1>
+}
+  1000db:	c9                   	leave  
+  1000dc:	c3                   	ret    
+
+001000dd <grade_backtrace>:
+
+void
+grade_backtrace(void) {
+  1000dd:	55                   	push   %ebp
+  1000de:	89 e5                	mov    %esp,%ebp
+  1000e0:	83 ec 18             	sub    $0x18,%esp
+    grade_backtrace0(0, (int)kern_init, 0xffff0000);
+  1000e3:	b8 00 00 10 00       	mov    $0x100000,%eax
+  1000e8:	c7 44 24 08 00 00 ff 	movl   $0xffff0000,0x8(%esp)
+  1000ef:	ff 
+  1000f0:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1000f4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  1000fb:	e8 c3 ff ff ff       	call   1000c3 <grade_backtrace0>
+}
+  100100:	c9                   	leave  
+  100101:	c3                   	ret    
+
+00100102 <lab1_print_cur_status>:
+
+static void
+lab1_print_cur_status(void) {
+  100102:	55                   	push   %ebp
+  100103:	89 e5                	mov    %esp,%ebp
+  100105:	83 ec 28             	sub    $0x28,%esp
+    static int round = 0;
+    uint16_t reg1, reg2, reg3, reg4;
+    asm volatile (
+  100108:	8c 4d f6             	mov    %cs,-0xa(%ebp)
+  10010b:	8c 5d f4             	mov    %ds,-0xc(%ebp)
+  10010e:	8c 45 f2             	mov    %es,-0xe(%ebp)
+  100111:	8c 55 f0             	mov    %ss,-0x10(%ebp)
+            "mov %%cs, %0;"
+            "mov %%ds, %1;"
+            "mov %%es, %2;"
+            "mov %%ss, %3;"
+            : "=m"(reg1), "=m"(reg2), "=m"(reg3), "=m"(reg4));
+    cprintf("%d: @ring %d\n", round, reg1 & 3);
+  100114:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+  100118:	0f b7 c0             	movzwl %ax,%eax
+  10011b:	89 c2                	mov    %eax,%edx
+  10011d:	83 e2 03             	and    $0x3,%edx
+  100120:	a1 20 ea 10 00       	mov    0x10ea20,%eax
+  100125:	89 54 24 08          	mov    %edx,0x8(%esp)
+  100129:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10012d:	c7 04 24 21 34 10 00 	movl   $0x103421,(%esp)
+  100134:	e8 25 01 00 00       	call   10025e <cprintf>
+    cprintf("%d:  cs = %x\n", round, reg1);
+  100139:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
+  10013d:	0f b7 d0             	movzwl %ax,%edx
+  100140:	a1 20 ea 10 00       	mov    0x10ea20,%eax
+  100145:	89 54 24 08          	mov    %edx,0x8(%esp)
+  100149:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10014d:	c7 04 24 2f 34 10 00 	movl   $0x10342f,(%esp)
+  100154:	e8 05 01 00 00       	call   10025e <cprintf>
+    cprintf("%d:  ds = %x\n", round, reg2);
+  100159:	0f b7 45 f4          	movzwl -0xc(%ebp),%eax
+  10015d:	0f b7 d0             	movzwl %ax,%edx
+  100160:	a1 20 ea 10 00       	mov    0x10ea20,%eax
+  100165:	89 54 24 08          	mov    %edx,0x8(%esp)
+  100169:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10016d:	c7 04 24 3d 34 10 00 	movl   $0x10343d,(%esp)
+  100174:	e8 e5 00 00 00       	call   10025e <cprintf>
+    cprintf("%d:  es = %x\n", round, reg3);
+  100179:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
+  10017d:	0f b7 d0             	movzwl %ax,%edx
+  100180:	a1 20 ea 10 00       	mov    0x10ea20,%eax
+  100185:	89 54 24 08          	mov    %edx,0x8(%esp)
+  100189:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10018d:	c7 04 24 4b 34 10 00 	movl   $0x10344b,(%esp)
+  100194:	e8 c5 00 00 00       	call   10025e <cprintf>
+    cprintf("%d:  ss = %x\n", round, reg4);
+  100199:	0f b7 45 f0          	movzwl -0x10(%ebp),%eax
+  10019d:	0f b7 d0             	movzwl %ax,%edx
+  1001a0:	a1 20 ea 10 00       	mov    0x10ea20,%eax
+  1001a5:	89 54 24 08          	mov    %edx,0x8(%esp)
+  1001a9:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1001ad:	c7 04 24 59 34 10 00 	movl   $0x103459,(%esp)
+  1001b4:	e8 a5 00 00 00       	call   10025e <cprintf>
+    round ++;
+  1001b9:	a1 20 ea 10 00       	mov    0x10ea20,%eax
+  1001be:	83 c0 01             	add    $0x1,%eax
+  1001c1:	a3 20 ea 10 00       	mov    %eax,0x10ea20
+}
+  1001c6:	c9                   	leave  
+  1001c7:	c3                   	ret    
+
+001001c8 <lab1_switch_to_user>:
+
+static void
+lab1_switch_to_user(void) {
+  1001c8:	55                   	push   %ebp
+  1001c9:	89 e5                	mov    %esp,%ebp
+    //LAB1 CHALLENGE 1 : TODO
+}
+  1001cb:	5d                   	pop    %ebp
+  1001cc:	c3                   	ret    
+
+001001cd <lab1_switch_to_kernel>:
+
+static void
+lab1_switch_to_kernel(void) {
+  1001cd:	55                   	push   %ebp
+  1001ce:	89 e5                	mov    %esp,%ebp
+    //LAB1 CHALLENGE 1 :  TODO
+}
+  1001d0:	5d                   	pop    %ebp
+  1001d1:	c3                   	ret    
+
+001001d2 <lab1_switch_test>:
+
+static void
+lab1_switch_test(void) {
+  1001d2:	55                   	push   %ebp
+  1001d3:	89 e5                	mov    %esp,%ebp
+  1001d5:	83 ec 18             	sub    $0x18,%esp
+    lab1_print_cur_status();
+  1001d8:	e8 25 ff ff ff       	call   100102 <lab1_print_cur_status>
+    cprintf("+++ switch to  user  mode +++\n");
+  1001dd:	c7 04 24 68 34 10 00 	movl   $0x103468,(%esp)
+  1001e4:	e8 75 00 00 00       	call   10025e <cprintf>
+    lab1_switch_to_user();
+  1001e9:	e8 da ff ff ff       	call   1001c8 <lab1_switch_to_user>
+    lab1_print_cur_status();
+  1001ee:	e8 0f ff ff ff       	call   100102 <lab1_print_cur_status>
+    cprintf("+++ switch to kernel mode +++\n");
+  1001f3:	c7 04 24 88 34 10 00 	movl   $0x103488,(%esp)
+  1001fa:	e8 5f 00 00 00       	call   10025e <cprintf>
+    lab1_switch_to_kernel();
+  1001ff:	e8 c9 ff ff ff       	call   1001cd <lab1_switch_to_kernel>
+    lab1_print_cur_status();
+  100204:	e8 f9 fe ff ff       	call   100102 <lab1_print_cur_status>
+}
+  100209:	c9                   	leave  
+  10020a:	c3                   	ret    
+
+0010020b <cputch>:
+/* *
+ * cputch - writes a single character @c to stdout, and it will
+ * increace the value of counter pointed by @cnt.
+ * */
+static void
+cputch(int c, int *cnt) {
+  10020b:	55                   	push   %ebp
+  10020c:	89 e5                	mov    %esp,%ebp
+  10020e:	83 ec 18             	sub    $0x18,%esp
+    cons_putc(c);
+  100211:	8b 45 08             	mov    0x8(%ebp),%eax
+  100214:	89 04 24             	mov    %eax,(%esp)
+  100217:	e8 10 14 00 00       	call   10162c <cons_putc>
+    (*cnt) ++;
+  10021c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10021f:	8b 00                	mov    (%eax),%eax
+  100221:	8d 50 01             	lea    0x1(%eax),%edx
+  100224:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100227:	89 10                	mov    %edx,(%eax)
+}
+  100229:	c9                   	leave  
+  10022a:	c3                   	ret    
+
+0010022b <vcprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want cprintf() instead.
+ * */
+int
+vcprintf(const char *fmt, va_list ap) {
+  10022b:	55                   	push   %ebp
+  10022c:	89 e5                	mov    %esp,%ebp
+  10022e:	83 ec 28             	sub    $0x28,%esp
+    int cnt = 0;
+  100231:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    vprintfmt((void*)cputch, &cnt, fmt, ap);
+  100238:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10023b:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  10023f:	8b 45 08             	mov    0x8(%ebp),%eax
+  100242:	89 44 24 08          	mov    %eax,0x8(%esp)
+  100246:	8d 45 f4             	lea    -0xc(%ebp),%eax
+  100249:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10024d:	c7 04 24 0b 02 10 00 	movl   $0x10020b,(%esp)
+  100254:	e8 d2 2c 00 00       	call   102f2b <vprintfmt>
+    return cnt;
+  100259:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  10025c:	c9                   	leave  
+  10025d:	c3                   	ret    
+
+0010025e <cprintf>:
+ *
+ * The return value is the number of characters which would be
+ * written to stdout.
+ * */
+int
+cprintf(const char *fmt, ...) {
+  10025e:	55                   	push   %ebp
+  10025f:	89 e5                	mov    %esp,%ebp
+  100261:	83 ec 28             	sub    $0x28,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  100264:	8d 45 0c             	lea    0xc(%ebp),%eax
+  100267:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vcprintf(fmt, ap);
+  10026a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  10026d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100271:	8b 45 08             	mov    0x8(%ebp),%eax
+  100274:	89 04 24             	mov    %eax,(%esp)
+  100277:	e8 af ff ff ff       	call   10022b <vcprintf>
+  10027c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  10027f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  100282:	c9                   	leave  
+  100283:	c3                   	ret    
+
+00100284 <cputchar>:
+
+/* cputchar - writes a single character to stdout */
+void
+cputchar(int c) {
+  100284:	55                   	push   %ebp
+  100285:	89 e5                	mov    %esp,%ebp
+  100287:	83 ec 18             	sub    $0x18,%esp
+    cons_putc(c);
+  10028a:	8b 45 08             	mov    0x8(%ebp),%eax
+  10028d:	89 04 24             	mov    %eax,(%esp)
+  100290:	e8 97 13 00 00       	call   10162c <cons_putc>
+}
+  100295:	c9                   	leave  
+  100296:	c3                   	ret    
+
+00100297 <cputs>:
+/* *
+ * cputs- writes the string pointed by @str to stdout and
+ * appends a newline character.
+ * */
+int
+cputs(const char *str) {
+  100297:	55                   	push   %ebp
+  100298:	89 e5                	mov    %esp,%ebp
+  10029a:	83 ec 28             	sub    $0x28,%esp
+    int cnt = 0;
+  10029d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
+    char c;
+    while ((c = *str ++) != '\0') {
+  1002a4:	eb 13                	jmp    1002b9 <cputs+0x22>
+        cputch(c, &cnt);
+  1002a6:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  1002aa:	8d 55 f0             	lea    -0x10(%ebp),%edx
+  1002ad:	89 54 24 04          	mov    %edx,0x4(%esp)
+  1002b1:	89 04 24             	mov    %eax,(%esp)
+  1002b4:	e8 52 ff ff ff       	call   10020b <cputch>
+    while ((c = *str ++) != '\0') {
+  1002b9:	8b 45 08             	mov    0x8(%ebp),%eax
+  1002bc:	0f b6 00             	movzbl (%eax),%eax
+  1002bf:	88 45 f7             	mov    %al,-0x9(%ebp)
+  1002c2:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
+  1002c6:	0f 95 c0             	setne  %al
+  1002c9:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  1002cd:	84 c0                	test   %al,%al
+  1002cf:	75 d5                	jne    1002a6 <cputs+0xf>
+    }
+    cputch('\n', &cnt);
+  1002d1:	8d 45 f0             	lea    -0x10(%ebp),%eax
+  1002d4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1002d8:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
+  1002df:	e8 27 ff ff ff       	call   10020b <cputch>
+    return cnt;
+  1002e4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+}
+  1002e7:	c9                   	leave  
+  1002e8:	c3                   	ret    
+
+001002e9 <getchar>:
+
+/* getchar - reads a single non-zero character from stdin */
+int
+getchar(void) {
+  1002e9:	55                   	push   %ebp
+  1002ea:	89 e5                	mov    %esp,%ebp
+  1002ec:	83 ec 18             	sub    $0x18,%esp
+    int c;
+    while ((c = cons_getc()) == 0)
+  1002ef:	e8 61 13 00 00       	call   101655 <cons_getc>
+  1002f4:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  1002f7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  1002fb:	74 f2                	je     1002ef <getchar+0x6>
+        /* do nothing */;
+    return c;
+  1002fd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  100300:	c9                   	leave  
+  100301:	c3                   	ret    
+
+00100302 <readline>:
+ * The readline() function returns the text of the line read. If some errors
+ * are happened, NULL is returned. The return value is a global variable,
+ * thus it should be copied before it is used.
+ * */
+char *
+readline(const char *prompt) {
+  100302:	55                   	push   %ebp
+  100303:	89 e5                	mov    %esp,%ebp
+  100305:	83 ec 28             	sub    $0x28,%esp
+    if (prompt != NULL) {
+  100308:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  10030c:	74 13                	je     100321 <readline+0x1f>
+        cprintf("%s", prompt);
+  10030e:	8b 45 08             	mov    0x8(%ebp),%eax
+  100311:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100315:	c7 04 24 a7 34 10 00 	movl   $0x1034a7,(%esp)
+  10031c:	e8 3d ff ff ff       	call   10025e <cprintf>
+    }
+    int i = 0, c;
+  100321:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  100328:	eb 01                	jmp    10032b <readline+0x29>
+        else if (c == '\n' || c == '\r') {
+            cputchar(c);
+            buf[i] = '\0';
+            return buf;
+        }
+    }
+  10032a:	90                   	nop
+        c = getchar();
+  10032b:	e8 b9 ff ff ff       	call   1002e9 <getchar>
+  100330:	89 45 f0             	mov    %eax,-0x10(%ebp)
+        if (c < 0) {
+  100333:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  100337:	79 07                	jns    100340 <readline+0x3e>
+            return NULL;
+  100339:	b8 00 00 00 00       	mov    $0x0,%eax
+  10033e:	eb 79                	jmp    1003b9 <readline+0xb7>
+        else if (c >= ' ' && i < BUFSIZE - 1) {
+  100340:	83 7d f0 1f          	cmpl   $0x1f,-0x10(%ebp)
+  100344:	7e 28                	jle    10036e <readline+0x6c>
+  100346:	81 7d f4 fe 03 00 00 	cmpl   $0x3fe,-0xc(%ebp)
+  10034d:	7f 1f                	jg     10036e <readline+0x6c>
+            cputchar(c);
+  10034f:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  100352:	89 04 24             	mov    %eax,(%esp)
+  100355:	e8 2a ff ff ff       	call   100284 <cputchar>
+            buf[i ++] = c;
+  10035a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  10035d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  100360:	81 c2 40 ea 10 00    	add    $0x10ea40,%edx
+  100366:	88 02                	mov    %al,(%edx)
+  100368:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  10036c:	eb 46                	jmp    1003b4 <readline+0xb2>
+        else if (c == '\b' && i > 0) {
+  10036e:	83 7d f0 08          	cmpl   $0x8,-0x10(%ebp)
+  100372:	75 17                	jne    10038b <readline+0x89>
+  100374:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  100378:	7e 11                	jle    10038b <readline+0x89>
+            cputchar(c);
+  10037a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  10037d:	89 04 24             	mov    %eax,(%esp)
+  100380:	e8 ff fe ff ff       	call   100284 <cputchar>
+            i --;
+  100385:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
+  100389:	eb 29                	jmp    1003b4 <readline+0xb2>
+        else if (c == '\n' || c == '\r') {
+  10038b:	83 7d f0 0a          	cmpl   $0xa,-0x10(%ebp)
+  10038f:	74 06                	je     100397 <readline+0x95>
+  100391:	83 7d f0 0d          	cmpl   $0xd,-0x10(%ebp)
+  100395:	75 93                	jne    10032a <readline+0x28>
+            cputchar(c);
+  100397:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  10039a:	89 04 24             	mov    %eax,(%esp)
+  10039d:	e8 e2 fe ff ff       	call   100284 <cputchar>
+            buf[i] = '\0';
+  1003a2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1003a5:	05 40 ea 10 00       	add    $0x10ea40,%eax
+  1003aa:	c6 00 00             	movb   $0x0,(%eax)
+            return buf;
+  1003ad:	b8 40 ea 10 00       	mov    $0x10ea40,%eax
+  1003b2:	eb 05                	jmp    1003b9 <readline+0xb7>
+    }
+  1003b4:	e9 71 ff ff ff       	jmp    10032a <readline+0x28>
+}
+  1003b9:	c9                   	leave  
+  1003ba:	c3                   	ret    
+
+001003bb <__panic>:
+/* *
+ * __panic - __panic is called on unresolvable fatal errors. it prints
+ * "panic: 'message'", and then enters the kernel monitor.
+ * */
+void
+__panic(const char *file, int line, const char *fmt, ...) {
+  1003bb:	55                   	push   %ebp
+  1003bc:	89 e5                	mov    %esp,%ebp
+  1003be:	83 ec 28             	sub    $0x28,%esp
+    if (is_panic) {
+  1003c1:	a1 40 ee 10 00       	mov    0x10ee40,%eax
+  1003c6:	85 c0                	test   %eax,%eax
+  1003c8:	75 5b                	jne    100425 <__panic+0x6a>
+        goto panic_dead;
+    }
+    is_panic = 1;
+  1003ca:	c7 05 40 ee 10 00 01 	movl   $0x1,0x10ee40
+  1003d1:	00 00 00 
+
+    // print the 'message'
+    va_list ap;
+    va_start(ap, fmt);
+  1003d4:	8d 45 14             	lea    0x14(%ebp),%eax
+  1003d7:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("kernel panic at %s:%d:\n    ", file, line);
+  1003da:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1003dd:	89 44 24 08          	mov    %eax,0x8(%esp)
+  1003e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  1003e4:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1003e8:	c7 04 24 aa 34 10 00 	movl   $0x1034aa,(%esp)
+  1003ef:	e8 6a fe ff ff       	call   10025e <cprintf>
+    vcprintf(fmt, ap);
+  1003f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1003f7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1003fb:	8b 45 10             	mov    0x10(%ebp),%eax
+  1003fe:	89 04 24             	mov    %eax,(%esp)
+  100401:	e8 25 fe ff ff       	call   10022b <vcprintf>
+    cprintf("\n");
+  100406:	c7 04 24 c6 34 10 00 	movl   $0x1034c6,(%esp)
+  10040d:	e8 4c fe ff ff       	call   10025e <cprintf>
+    
+    cprintf("stack trackback:\n");
+  100412:	c7 04 24 c8 34 10 00 	movl   $0x1034c8,(%esp)
+  100419:	e8 40 fe ff ff       	call   10025e <cprintf>
+    print_stackframe();
+  10041e:	e8 55 06 00 00       	call   100a78 <print_stackframe>
+  100423:	eb 01                	jmp    100426 <__panic+0x6b>
+        goto panic_dead;
+  100425:	90                   	nop
+    
+    va_end(ap);
+
+panic_dead:
+    intr_disable();
+  100426:	e8 53 14 00 00       	call   10187e <intr_disable>
+    while (1) {
+        kmonitor(NULL);
+  10042b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  100432:	e8 3d 08 00 00       	call   100c74 <kmonitor>
+    }
+  100437:	eb f2                	jmp    10042b <__panic+0x70>
+
+00100439 <__warn>:
+}
+
+/* __warn - like panic, but don't */
+void
+__warn(const char *file, int line, const char *fmt, ...) {
+  100439:	55                   	push   %ebp
+  10043a:	89 e5                	mov    %esp,%ebp
+  10043c:	83 ec 28             	sub    $0x28,%esp
+    va_list ap;
+    va_start(ap, fmt);
+  10043f:	8d 45 14             	lea    0x14(%ebp),%eax
+  100442:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    cprintf("kernel warning at %s:%d:\n    ", file, line);
+  100445:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100448:	89 44 24 08          	mov    %eax,0x8(%esp)
+  10044c:	8b 45 08             	mov    0x8(%ebp),%eax
+  10044f:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100453:	c7 04 24 da 34 10 00 	movl   $0x1034da,(%esp)
+  10045a:	e8 ff fd ff ff       	call   10025e <cprintf>
+    vcprintf(fmt, ap);
+  10045f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100462:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100466:	8b 45 10             	mov    0x10(%ebp),%eax
+  100469:	89 04 24             	mov    %eax,(%esp)
+  10046c:	e8 ba fd ff ff       	call   10022b <vcprintf>
+    cprintf("\n");
+  100471:	c7 04 24 c6 34 10 00 	movl   $0x1034c6,(%esp)
+  100478:	e8 e1 fd ff ff       	call   10025e <cprintf>
+    va_end(ap);
+}
+  10047d:	c9                   	leave  
+  10047e:	c3                   	ret    
+
+0010047f <is_kernel_panic>:
+
+bool
+is_kernel_panic(void) {
+  10047f:	55                   	push   %ebp
+  100480:	89 e5                	mov    %esp,%ebp
+    return is_panic;
+  100482:	a1 40 ee 10 00       	mov    0x10ee40,%eax
+}
+  100487:	5d                   	pop    %ebp
+  100488:	c3                   	ret    
+
+00100489 <stab_binsearch>:
+ *      stab_binsearch(stabs, &left, &right, N_SO, 0xf0100184);
+ * will exit setting left = 118, right = 554.
+ * */
+static void
+stab_binsearch(const struct stab *stabs, int *region_left, int *region_right,
+           int type, uintptr_t addr) {
+  100489:	55                   	push   %ebp
+  10048a:	89 e5                	mov    %esp,%ebp
+  10048c:	83 ec 20             	sub    $0x20,%esp
+    int l = *region_left, r = *region_right, any_matches = 0;
+  10048f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100492:	8b 00                	mov    (%eax),%eax
+  100494:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  100497:	8b 45 10             	mov    0x10(%ebp),%eax
+  10049a:	8b 00                	mov    (%eax),%eax
+  10049c:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  10049f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+
+    while (l <= r) {
+  1004a6:	e9 d2 00 00 00       	jmp    10057d <stab_binsearch+0xf4>
+        int true_m = (l + r) / 2, m = true_m;
+  1004ab:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  1004ae:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  1004b1:	01 d0                	add    %edx,%eax
+  1004b3:	89 c2                	mov    %eax,%edx
+  1004b5:	c1 ea 1f             	shr    $0x1f,%edx
+  1004b8:	01 d0                	add    %edx,%eax
+  1004ba:	d1 f8                	sar    %eax
+  1004bc:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  1004bf:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  1004c2:	89 45 f0             	mov    %eax,-0x10(%ebp)
+
+        // search for earliest stab with right type
+        while (m >= l && stabs[m].n_type != type) {
+  1004c5:	eb 04                	jmp    1004cb <stab_binsearch+0x42>
+            m --;
+  1004c7:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
+        while (m >= l && stabs[m].n_type != type) {
+  1004cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1004ce:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  1004d1:	7c 1f                	jl     1004f2 <stab_binsearch+0x69>
+  1004d3:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  1004d6:	89 d0                	mov    %edx,%eax
+  1004d8:	01 c0                	add    %eax,%eax
+  1004da:	01 d0                	add    %edx,%eax
+  1004dc:	c1 e0 02             	shl    $0x2,%eax
+  1004df:	89 c2                	mov    %eax,%edx
+  1004e1:	8b 45 08             	mov    0x8(%ebp),%eax
+  1004e4:	01 d0                	add    %edx,%eax
+  1004e6:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+  1004ea:	0f b6 c0             	movzbl %al,%eax
+  1004ed:	3b 45 14             	cmp    0x14(%ebp),%eax
+  1004f0:	75 d5                	jne    1004c7 <stab_binsearch+0x3e>
+        }
+        if (m < l) {    // no match in [l, m]
+  1004f2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1004f5:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  1004f8:	7d 0b                	jge    100505 <stab_binsearch+0x7c>
+            l = true_m + 1;
+  1004fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  1004fd:	83 c0 01             	add    $0x1,%eax
+  100500:	89 45 fc             	mov    %eax,-0x4(%ebp)
+            continue;
+  100503:	eb 78                	jmp    10057d <stab_binsearch+0xf4>
+        }
+
+        // actual binary search
+        any_matches = 1;
+  100505:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
+        if (stabs[m].n_value < addr) {
+  10050c:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  10050f:	89 d0                	mov    %edx,%eax
+  100511:	01 c0                	add    %eax,%eax
+  100513:	01 d0                	add    %edx,%eax
+  100515:	c1 e0 02             	shl    $0x2,%eax
+  100518:	89 c2                	mov    %eax,%edx
+  10051a:	8b 45 08             	mov    0x8(%ebp),%eax
+  10051d:	01 d0                	add    %edx,%eax
+  10051f:	8b 40 08             	mov    0x8(%eax),%eax
+  100522:	3b 45 18             	cmp    0x18(%ebp),%eax
+  100525:	73 13                	jae    10053a <stab_binsearch+0xb1>
+            *region_left = m;
+  100527:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10052a:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  10052d:	89 10                	mov    %edx,(%eax)
+            l = true_m + 1;
+  10052f:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  100532:	83 c0 01             	add    $0x1,%eax
+  100535:	89 45 fc             	mov    %eax,-0x4(%ebp)
+  100538:	eb 43                	jmp    10057d <stab_binsearch+0xf4>
+        } else if (stabs[m].n_value > addr) {
+  10053a:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  10053d:	89 d0                	mov    %edx,%eax
+  10053f:	01 c0                	add    %eax,%eax
+  100541:	01 d0                	add    %edx,%eax
+  100543:	c1 e0 02             	shl    $0x2,%eax
+  100546:	89 c2                	mov    %eax,%edx
+  100548:	8b 45 08             	mov    0x8(%ebp),%eax
+  10054b:	01 d0                	add    %edx,%eax
+  10054d:	8b 40 08             	mov    0x8(%eax),%eax
+  100550:	3b 45 18             	cmp    0x18(%ebp),%eax
+  100553:	76 16                	jbe    10056b <stab_binsearch+0xe2>
+            *region_right = m - 1;
+  100555:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  100558:	8d 50 ff             	lea    -0x1(%eax),%edx
+  10055b:	8b 45 10             	mov    0x10(%ebp),%eax
+  10055e:	89 10                	mov    %edx,(%eax)
+            r = m - 1;
+  100560:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  100563:	83 e8 01             	sub    $0x1,%eax
+  100566:	89 45 f8             	mov    %eax,-0x8(%ebp)
+  100569:	eb 12                	jmp    10057d <stab_binsearch+0xf4>
+        } else {
+            // exact match for 'addr', but continue loop to find
+            // *region_right
+            *region_left = m;
+  10056b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10056e:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  100571:	89 10                	mov    %edx,(%eax)
+            l = m;
+  100573:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  100576:	89 45 fc             	mov    %eax,-0x4(%ebp)
+            addr ++;
+  100579:	83 45 18 01          	addl   $0x1,0x18(%ebp)
+    while (l <= r) {
+  10057d:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  100580:	3b 45 f8             	cmp    -0x8(%ebp),%eax
+  100583:	0f 8e 22 ff ff ff    	jle    1004ab <stab_binsearch+0x22>
+        }
+    }
+
+    if (!any_matches) {
+  100589:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  10058d:	75 0f                	jne    10059e <stab_binsearch+0x115>
+        *region_right = *region_left - 1;
+  10058f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100592:	8b 00                	mov    (%eax),%eax
+  100594:	8d 50 ff             	lea    -0x1(%eax),%edx
+  100597:	8b 45 10             	mov    0x10(%ebp),%eax
+  10059a:	89 10                	mov    %edx,(%eax)
+  10059c:	eb 3f                	jmp    1005dd <stab_binsearch+0x154>
+    }
+    else {
+        // find rightmost region containing 'addr'
+        l = *region_right;
+  10059e:	8b 45 10             	mov    0x10(%ebp),%eax
+  1005a1:	8b 00                	mov    (%eax),%eax
+  1005a3:	89 45 fc             	mov    %eax,-0x4(%ebp)
+        for (; l > *region_left && stabs[l].n_type != type; l --)
+  1005a6:	eb 04                	jmp    1005ac <stab_binsearch+0x123>
+  1005a8:	83 6d fc 01          	subl   $0x1,-0x4(%ebp)
+  1005ac:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1005af:	8b 00                	mov    (%eax),%eax
+  1005b1:	3b 45 fc             	cmp    -0x4(%ebp),%eax
+  1005b4:	7d 1f                	jge    1005d5 <stab_binsearch+0x14c>
+  1005b6:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  1005b9:	89 d0                	mov    %edx,%eax
+  1005bb:	01 c0                	add    %eax,%eax
+  1005bd:	01 d0                	add    %edx,%eax
+  1005bf:	c1 e0 02             	shl    $0x2,%eax
+  1005c2:	89 c2                	mov    %eax,%edx
+  1005c4:	8b 45 08             	mov    0x8(%ebp),%eax
+  1005c7:	01 d0                	add    %edx,%eax
+  1005c9:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+  1005cd:	0f b6 c0             	movzbl %al,%eax
+  1005d0:	3b 45 14             	cmp    0x14(%ebp),%eax
+  1005d3:	75 d3                	jne    1005a8 <stab_binsearch+0x11f>
+            /* do nothing */;
+        *region_left = l;
+  1005d5:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1005d8:	8b 55 fc             	mov    -0x4(%ebp),%edx
+  1005db:	89 10                	mov    %edx,(%eax)
+    }
+}
+  1005dd:	c9                   	leave  
+  1005de:	c3                   	ret    
+
+001005df <debuginfo_eip>:
+ * the specified instruction address, @addr.  Returns 0 if information
+ * was found, and negative if not.  But even if it returns negative it
+ * has stored some information into '*info'.
+ * */
+int
+debuginfo_eip(uintptr_t addr, struct eipdebuginfo *info) {
+  1005df:	55                   	push   %ebp
+  1005e0:	89 e5                	mov    %esp,%ebp
+  1005e2:	53                   	push   %ebx
+  1005e3:	83 ec 54             	sub    $0x54,%esp
+    const struct stab *stabs, *stab_end;
+    const char *stabstr, *stabstr_end;
+
+    info->eip_file = "<unknown>";
+  1005e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1005e9:	c7 00 f8 34 10 00    	movl   $0x1034f8,(%eax)
+    info->eip_line = 0;
+  1005ef:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1005f2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
+    info->eip_fn_name = "<unknown>";
+  1005f9:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1005fc:	c7 40 08 f8 34 10 00 	movl   $0x1034f8,0x8(%eax)
+    info->eip_fn_namelen = 9;
+  100603:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100606:	c7 40 0c 09 00 00 00 	movl   $0x9,0xc(%eax)
+    info->eip_fn_addr = addr;
+  10060d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100610:	8b 55 08             	mov    0x8(%ebp),%edx
+  100613:	89 50 10             	mov    %edx,0x10(%eax)
+    info->eip_fn_narg = 0;
+  100616:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100619:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
+
+    stabs = __STAB_BEGIN__;
+  100620:	c7 45 f4 2c 3d 10 00 	movl   $0x103d2c,-0xc(%ebp)
+    stab_end = __STAB_END__;
+  100627:	c7 45 f0 94 b3 10 00 	movl   $0x10b394,-0x10(%ebp)
+    stabstr = __STABSTR_BEGIN__;
+  10062e:	c7 45 ec 95 b3 10 00 	movl   $0x10b395,-0x14(%ebp)
+    stabstr_end = __STABSTR_END__;
+  100635:	c7 45 e8 35 d3 10 00 	movl   $0x10d335,-0x18(%ebp)
+
+    // String table validity checks
+    if (stabstr_end <= stabstr || stabstr_end[-1] != 0) {
+  10063c:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  10063f:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  100642:	76 0d                	jbe    100651 <debuginfo_eip+0x72>
+  100644:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  100647:	83 e8 01             	sub    $0x1,%eax
+  10064a:	0f b6 00             	movzbl (%eax),%eax
+  10064d:	84 c0                	test   %al,%al
+  10064f:	74 0a                	je     10065b <debuginfo_eip+0x7c>
+        return -1;
+  100651:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  100656:	e9 c6 02 00 00       	jmp    100921 <debuginfo_eip+0x342>
+    // 'eip'.  First, we find the basic source file containing 'eip'.
+    // Then, we look in that source file for the function.  Then we look
+    // for the line number.
+
+    // Search the entire set of stabs for the source file (type N_SO).
+    int lfile = 0, rfile = (stab_end - stabs) - 1;
+  10065b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+  100662:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  100665:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100668:	89 d1                	mov    %edx,%ecx
+  10066a:	29 c1                	sub    %eax,%ecx
+  10066c:	89 c8                	mov    %ecx,%eax
+  10066e:	c1 f8 02             	sar    $0x2,%eax
+  100671:	69 c0 ab aa aa aa    	imul   $0xaaaaaaab,%eax,%eax
+  100677:	83 e8 01             	sub    $0x1,%eax
+  10067a:	89 45 e0             	mov    %eax,-0x20(%ebp)
+    stab_binsearch(stabs, &lfile, &rfile, N_SO, addr);
+  10067d:	8b 45 08             	mov    0x8(%ebp),%eax
+  100680:	89 44 24 10          	mov    %eax,0x10(%esp)
+  100684:	c7 44 24 0c 64 00 00 	movl   $0x64,0xc(%esp)
+  10068b:	00 
+  10068c:	8d 45 e0             	lea    -0x20(%ebp),%eax
+  10068f:	89 44 24 08          	mov    %eax,0x8(%esp)
+  100693:	8d 45 e4             	lea    -0x1c(%ebp),%eax
+  100696:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10069a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10069d:	89 04 24             	mov    %eax,(%esp)
+  1006a0:	e8 e4 fd ff ff       	call   100489 <stab_binsearch>
+    if (lfile == 0)
+  1006a5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  1006a8:	85 c0                	test   %eax,%eax
+  1006aa:	75 0a                	jne    1006b6 <debuginfo_eip+0xd7>
+        return -1;
+  1006ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  1006b1:	e9 6b 02 00 00       	jmp    100921 <debuginfo_eip+0x342>
+
+    // Search within that file's stabs for the function definition
+    // (N_FUN).
+    int lfun = lfile, rfun = rfile;
+  1006b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  1006b9:	89 45 dc             	mov    %eax,-0x24(%ebp)
+  1006bc:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  1006bf:	89 45 d8             	mov    %eax,-0x28(%ebp)
+    int lline, rline;
+    stab_binsearch(stabs, &lfun, &rfun, N_FUN, addr);
+  1006c2:	8b 45 08             	mov    0x8(%ebp),%eax
+  1006c5:	89 44 24 10          	mov    %eax,0x10(%esp)
+  1006c9:	c7 44 24 0c 24 00 00 	movl   $0x24,0xc(%esp)
+  1006d0:	00 
+  1006d1:	8d 45 d8             	lea    -0x28(%ebp),%eax
+  1006d4:	89 44 24 08          	mov    %eax,0x8(%esp)
+  1006d8:	8d 45 dc             	lea    -0x24(%ebp),%eax
+  1006db:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1006df:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1006e2:	89 04 24             	mov    %eax,(%esp)
+  1006e5:	e8 9f fd ff ff       	call   100489 <stab_binsearch>
+
+    if (lfun <= rfun) {
+  1006ea:	8b 55 dc             	mov    -0x24(%ebp),%edx
+  1006ed:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  1006f0:	39 c2                	cmp    %eax,%edx
+  1006f2:	7f 7e                	jg     100772 <debuginfo_eip+0x193>
+        // stabs[lfun] points to the function name
+        // in the string table, but check bounds just in case.
+        if (stabs[lfun].n_strx < stabstr_end - stabstr) {
+  1006f4:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  1006f7:	89 c2                	mov    %eax,%edx
+  1006f9:	89 d0                	mov    %edx,%eax
+  1006fb:	01 c0                	add    %eax,%eax
+  1006fd:	01 d0                	add    %edx,%eax
+  1006ff:	c1 e0 02             	shl    $0x2,%eax
+  100702:	89 c2                	mov    %eax,%edx
+  100704:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100707:	01 d0                	add    %edx,%eax
+  100709:	8b 10                	mov    (%eax),%edx
+  10070b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
+  10070e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  100711:	89 cb                	mov    %ecx,%ebx
+  100713:	29 c3                	sub    %eax,%ebx
+  100715:	89 d8                	mov    %ebx,%eax
+  100717:	39 c2                	cmp    %eax,%edx
+  100719:	73 22                	jae    10073d <debuginfo_eip+0x15e>
+            info->eip_fn_name = stabstr + stabs[lfun].n_strx;
+  10071b:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  10071e:	89 c2                	mov    %eax,%edx
+  100720:	89 d0                	mov    %edx,%eax
+  100722:	01 c0                	add    %eax,%eax
+  100724:	01 d0                	add    %edx,%eax
+  100726:	c1 e0 02             	shl    $0x2,%eax
+  100729:	89 c2                	mov    %eax,%edx
+  10072b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10072e:	01 d0                	add    %edx,%eax
+  100730:	8b 10                	mov    (%eax),%edx
+  100732:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  100735:	01 c2                	add    %eax,%edx
+  100737:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10073a:	89 50 08             	mov    %edx,0x8(%eax)
+        }
+        info->eip_fn_addr = stabs[lfun].n_value;
+  10073d:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  100740:	89 c2                	mov    %eax,%edx
+  100742:	89 d0                	mov    %edx,%eax
+  100744:	01 c0                	add    %eax,%eax
+  100746:	01 d0                	add    %edx,%eax
+  100748:	c1 e0 02             	shl    $0x2,%eax
+  10074b:	89 c2                	mov    %eax,%edx
+  10074d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100750:	01 d0                	add    %edx,%eax
+  100752:	8b 50 08             	mov    0x8(%eax),%edx
+  100755:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100758:	89 50 10             	mov    %edx,0x10(%eax)
+        addr -= info->eip_fn_addr;
+  10075b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10075e:	8b 40 10             	mov    0x10(%eax),%eax
+  100761:	29 45 08             	sub    %eax,0x8(%ebp)
+        // Search within the function definition for the line number.
+        lline = lfun;
+  100764:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  100767:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+        rline = rfun;
+  10076a:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  10076d:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  100770:	eb 15                	jmp    100787 <debuginfo_eip+0x1a8>
+    } else {
+        // Couldn't find function stab!  Maybe we're in an assembly
+        // file.  Search the whole file for the line number.
+        info->eip_fn_addr = addr;
+  100772:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100775:	8b 55 08             	mov    0x8(%ebp),%edx
+  100778:	89 50 10             	mov    %edx,0x10(%eax)
+        lline = lfile;
+  10077b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  10077e:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+        rline = rfile;
+  100781:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  100784:	89 45 d0             	mov    %eax,-0x30(%ebp)
+    }
+    info->eip_fn_namelen = strfind(info->eip_fn_name, ':') - info->eip_fn_name;
+  100787:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10078a:	8b 40 08             	mov    0x8(%eax),%eax
+  10078d:	c7 44 24 04 3a 00 00 	movl   $0x3a,0x4(%esp)
+  100794:	00 
+  100795:	89 04 24             	mov    %eax,(%esp)
+  100798:	e8 43 22 00 00       	call   1029e0 <strfind>
+  10079d:	89 c2                	mov    %eax,%edx
+  10079f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1007a2:	8b 40 08             	mov    0x8(%eax),%eax
+  1007a5:	29 c2                	sub    %eax,%edx
+  1007a7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1007aa:	89 50 0c             	mov    %edx,0xc(%eax)
+
+    // Search within [lline, rline] for the line number stab.
+    // If found, set info->eip_line to the right line number.
+    // If not found, return -1.
+    stab_binsearch(stabs, &lline, &rline, N_SLINE, addr);
+  1007ad:	8b 45 08             	mov    0x8(%ebp),%eax
+  1007b0:	89 44 24 10          	mov    %eax,0x10(%esp)
+  1007b4:	c7 44 24 0c 44 00 00 	movl   $0x44,0xc(%esp)
+  1007bb:	00 
+  1007bc:	8d 45 d0             	lea    -0x30(%ebp),%eax
+  1007bf:	89 44 24 08          	mov    %eax,0x8(%esp)
+  1007c3:	8d 45 d4             	lea    -0x2c(%ebp),%eax
+  1007c6:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1007ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1007cd:	89 04 24             	mov    %eax,(%esp)
+  1007d0:	e8 b4 fc ff ff       	call   100489 <stab_binsearch>
+    if (lline <= rline) {
+  1007d5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  1007d8:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  1007db:	39 c2                	cmp    %eax,%edx
+  1007dd:	7f 24                	jg     100803 <debuginfo_eip+0x224>
+        info->eip_line = stabs[rline].n_desc;
+  1007df:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  1007e2:	89 c2                	mov    %eax,%edx
+  1007e4:	89 d0                	mov    %edx,%eax
+  1007e6:	01 c0                	add    %eax,%eax
+  1007e8:	01 d0                	add    %edx,%eax
+  1007ea:	c1 e0 02             	shl    $0x2,%eax
+  1007ed:	89 c2                	mov    %eax,%edx
+  1007ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1007f2:	01 d0                	add    %edx,%eax
+  1007f4:	0f b7 40 06          	movzwl 0x6(%eax),%eax
+  1007f8:	0f b7 d0             	movzwl %ax,%edx
+  1007fb:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1007fe:	89 50 04             	mov    %edx,0x4(%eax)
+
+    // Search backwards from the line number for the relevant filename stab.
+    // We can't just use the "lfile" stab because inlined functions
+    // can interpolate code from a different file!
+    // Such included source files use the N_SOL stab type.
+    while (lline >= lfile
+  100801:	eb 13                	jmp    100816 <debuginfo_eip+0x237>
+        return -1;
+  100803:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  100808:	e9 14 01 00 00       	jmp    100921 <debuginfo_eip+0x342>
+           && stabs[lline].n_type != N_SOL
+           && (stabs[lline].n_type != N_SO || !stabs[lline].n_value)) {
+        lline --;
+  10080d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  100810:	83 e8 01             	sub    $0x1,%eax
+  100813:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    while (lline >= lfile
+  100816:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  100819:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  10081c:	39 c2                	cmp    %eax,%edx
+  10081e:	7c 56                	jl     100876 <debuginfo_eip+0x297>
+           && stabs[lline].n_type != N_SOL
+  100820:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  100823:	89 c2                	mov    %eax,%edx
+  100825:	89 d0                	mov    %edx,%eax
+  100827:	01 c0                	add    %eax,%eax
+  100829:	01 d0                	add    %edx,%eax
+  10082b:	c1 e0 02             	shl    $0x2,%eax
+  10082e:	89 c2                	mov    %eax,%edx
+  100830:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100833:	01 d0                	add    %edx,%eax
+  100835:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+  100839:	3c 84                	cmp    $0x84,%al
+  10083b:	74 39                	je     100876 <debuginfo_eip+0x297>
+           && (stabs[lline].n_type != N_SO || !stabs[lline].n_value)) {
+  10083d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  100840:	89 c2                	mov    %eax,%edx
+  100842:	89 d0                	mov    %edx,%eax
+  100844:	01 c0                	add    %eax,%eax
+  100846:	01 d0                	add    %edx,%eax
+  100848:	c1 e0 02             	shl    $0x2,%eax
+  10084b:	89 c2                	mov    %eax,%edx
+  10084d:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100850:	01 d0                	add    %edx,%eax
+  100852:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+  100856:	3c 64                	cmp    $0x64,%al
+  100858:	75 b3                	jne    10080d <debuginfo_eip+0x22e>
+  10085a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  10085d:	89 c2                	mov    %eax,%edx
+  10085f:	89 d0                	mov    %edx,%eax
+  100861:	01 c0                	add    %eax,%eax
+  100863:	01 d0                	add    %edx,%eax
+  100865:	c1 e0 02             	shl    $0x2,%eax
+  100868:	89 c2                	mov    %eax,%edx
+  10086a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  10086d:	01 d0                	add    %edx,%eax
+  10086f:	8b 40 08             	mov    0x8(%eax),%eax
+  100872:	85 c0                	test   %eax,%eax
+  100874:	74 97                	je     10080d <debuginfo_eip+0x22e>
+    }
+    if (lline >= lfile && stabs[lline].n_strx < stabstr_end - stabstr) {
+  100876:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  100879:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  10087c:	39 c2                	cmp    %eax,%edx
+  10087e:	7c 48                	jl     1008c8 <debuginfo_eip+0x2e9>
+  100880:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  100883:	89 c2                	mov    %eax,%edx
+  100885:	89 d0                	mov    %edx,%eax
+  100887:	01 c0                	add    %eax,%eax
+  100889:	01 d0                	add    %edx,%eax
+  10088b:	c1 e0 02             	shl    $0x2,%eax
+  10088e:	89 c2                	mov    %eax,%edx
+  100890:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100893:	01 d0                	add    %edx,%eax
+  100895:	8b 10                	mov    (%eax),%edx
+  100897:	8b 4d e8             	mov    -0x18(%ebp),%ecx
+  10089a:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  10089d:	89 cb                	mov    %ecx,%ebx
+  10089f:	29 c3                	sub    %eax,%ebx
+  1008a1:	89 d8                	mov    %ebx,%eax
+  1008a3:	39 c2                	cmp    %eax,%edx
+  1008a5:	73 21                	jae    1008c8 <debuginfo_eip+0x2e9>
+        info->eip_file = stabstr + stabs[lline].n_strx;
+  1008a7:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  1008aa:	89 c2                	mov    %eax,%edx
+  1008ac:	89 d0                	mov    %edx,%eax
+  1008ae:	01 c0                	add    %eax,%eax
+  1008b0:	01 d0                	add    %edx,%eax
+  1008b2:	c1 e0 02             	shl    $0x2,%eax
+  1008b5:	89 c2                	mov    %eax,%edx
+  1008b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1008ba:	01 d0                	add    %edx,%eax
+  1008bc:	8b 10                	mov    (%eax),%edx
+  1008be:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  1008c1:	01 c2                	add    %eax,%edx
+  1008c3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1008c6:	89 10                	mov    %edx,(%eax)
+    }
+
+    // Set eip_fn_narg to the number of arguments taken by the function,
+    // or 0 if there was no containing function.
+    if (lfun < rfun) {
+  1008c8:	8b 55 dc             	mov    -0x24(%ebp),%edx
+  1008cb:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  1008ce:	39 c2                	cmp    %eax,%edx
+  1008d0:	7d 4a                	jge    10091c <debuginfo_eip+0x33d>
+        for (lline = lfun + 1;
+  1008d2:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  1008d5:	83 c0 01             	add    $0x1,%eax
+  1008d8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+  1008db:	eb 18                	jmp    1008f5 <debuginfo_eip+0x316>
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+             lline ++) {
+            info->eip_fn_narg ++;
+  1008dd:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1008e0:	8b 40 14             	mov    0x14(%eax),%eax
+  1008e3:	8d 50 01             	lea    0x1(%eax),%edx
+  1008e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1008e9:	89 50 14             	mov    %edx,0x14(%eax)
+             lline ++) {
+  1008ec:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  1008ef:	83 c0 01             	add    $0x1,%eax
+  1008f2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+  1008f5:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  1008f8:	8b 45 d8             	mov    -0x28(%ebp),%eax
+        for (lline = lfun + 1;
+  1008fb:	39 c2                	cmp    %eax,%edx
+  1008fd:	7d 1d                	jge    10091c <debuginfo_eip+0x33d>
+             lline < rfun && stabs[lline].n_type == N_PSYM;
+  1008ff:	8b 45 d4             	mov    -0x2c(%ebp),%eax
+  100902:	89 c2                	mov    %eax,%edx
+  100904:	89 d0                	mov    %edx,%eax
+  100906:	01 c0                	add    %eax,%eax
+  100908:	01 d0                	add    %edx,%eax
+  10090a:	c1 e0 02             	shl    $0x2,%eax
+  10090d:	89 c2                	mov    %eax,%edx
+  10090f:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100912:	01 d0                	add    %edx,%eax
+  100914:	0f b6 40 04          	movzbl 0x4(%eax),%eax
+  100918:	3c a0                	cmp    $0xa0,%al
+  10091a:	74 c1                	je     1008dd <debuginfo_eip+0x2fe>
+        }
+    }
+    return 0;
+  10091c:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  100921:	83 c4 54             	add    $0x54,%esp
+  100924:	5b                   	pop    %ebx
+  100925:	5d                   	pop    %ebp
+  100926:	c3                   	ret    
+
+00100927 <print_kerninfo>:
+ * print_kerninfo - print the information about kernel, including the location
+ * of kernel entry, the start addresses of data and text segements, the start
+ * address of free memory and how many memory that kernel has used.
+ * */
+void
+print_kerninfo(void) {
+  100927:	55                   	push   %ebp
+  100928:	89 e5                	mov    %esp,%ebp
+  10092a:	83 ec 18             	sub    $0x18,%esp
+    extern char etext[], edata[], end[], kern_init[];
+    cprintf("Special kernel symbols:\n");
+  10092d:	c7 04 24 02 35 10 00 	movl   $0x103502,(%esp)
+  100934:	e8 25 f9 ff ff       	call   10025e <cprintf>
+    cprintf("  entry  0x%08x (phys)\n", kern_init);
+  100939:	c7 44 24 04 00 00 10 	movl   $0x100000,0x4(%esp)
+  100940:	00 
+  100941:	c7 04 24 1b 35 10 00 	movl   $0x10351b,(%esp)
+  100948:	e8 11 f9 ff ff       	call   10025e <cprintf>
+    cprintf("  etext  0x%08x (phys)\n", etext);
+  10094d:	c7 44 24 04 ed 33 10 	movl   $0x1033ed,0x4(%esp)
+  100954:	00 
+  100955:	c7 04 24 33 35 10 00 	movl   $0x103533,(%esp)
+  10095c:	e8 fd f8 ff ff       	call   10025e <cprintf>
+    cprintf("  edata  0x%08x (phys)\n", edata);
+  100961:	c7 44 24 04 16 ea 10 	movl   $0x10ea16,0x4(%esp)
+  100968:	00 
+  100969:	c7 04 24 4b 35 10 00 	movl   $0x10354b,(%esp)
+  100970:	e8 e9 f8 ff ff       	call   10025e <cprintf>
+    cprintf("  end    0x%08x (phys)\n", end);
+  100975:	c7 44 24 04 20 fd 10 	movl   $0x10fd20,0x4(%esp)
+  10097c:	00 
+  10097d:	c7 04 24 63 35 10 00 	movl   $0x103563,(%esp)
+  100984:	e8 d5 f8 ff ff       	call   10025e <cprintf>
+    cprintf("Kernel executable memory footprint: %dKB\n", (end - kern_init + 1023)/1024);
+  100989:	b8 20 fd 10 00       	mov    $0x10fd20,%eax
+  10098e:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
+  100994:	b8 00 00 10 00       	mov    $0x100000,%eax
+  100999:	89 d1                	mov    %edx,%ecx
+  10099b:	29 c1                	sub    %eax,%ecx
+  10099d:	89 c8                	mov    %ecx,%eax
+  10099f:	8d 90 ff 03 00 00    	lea    0x3ff(%eax),%edx
+  1009a5:	85 c0                	test   %eax,%eax
+  1009a7:	0f 48 c2             	cmovs  %edx,%eax
+  1009aa:	c1 f8 0a             	sar    $0xa,%eax
+  1009ad:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1009b1:	c7 04 24 7c 35 10 00 	movl   $0x10357c,(%esp)
+  1009b8:	e8 a1 f8 ff ff       	call   10025e <cprintf>
+}
+  1009bd:	c9                   	leave  
+  1009be:	c3                   	ret    
+
+001009bf <print_debuginfo>:
+/* *
+ * print_debuginfo - read and print the stat information for the address @eip,
+ * and info.eip_fn_addr should be the first address of the related function.
+ * */
+void
+print_debuginfo(uintptr_t eip) {
+  1009bf:	55                   	push   %ebp
+  1009c0:	89 e5                	mov    %esp,%ebp
+  1009c2:	81 ec 48 01 00 00    	sub    $0x148,%esp
+    struct eipdebuginfo info;
+    if (debuginfo_eip(eip, &info) != 0) {
+  1009c8:	8d 45 dc             	lea    -0x24(%ebp),%eax
+  1009cb:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1009cf:	8b 45 08             	mov    0x8(%ebp),%eax
+  1009d2:	89 04 24             	mov    %eax,(%esp)
+  1009d5:	e8 05 fc ff ff       	call   1005df <debuginfo_eip>
+  1009da:	85 c0                	test   %eax,%eax
+  1009dc:	74 15                	je     1009f3 <print_debuginfo+0x34>
+        cprintf("    <unknow>: -- 0x%08x --\n", eip);
+  1009de:	8b 45 08             	mov    0x8(%ebp),%eax
+  1009e1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1009e5:	c7 04 24 a6 35 10 00 	movl   $0x1035a6,(%esp)
+  1009ec:	e8 6d f8 ff ff       	call   10025e <cprintf>
+  1009f1:	eb 6d                	jmp    100a60 <print_debuginfo+0xa1>
+    }
+    else {
+        char fnname[256];
+        int j;
+        for (j = 0; j < info.eip_fn_namelen; j ++) {
+  1009f3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  1009fa:	eb 1c                	jmp    100a18 <print_debuginfo+0x59>
+            fnname[j] = info.eip_fn_name[j];
+  1009fc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  1009ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100a02:	01 d0                	add    %edx,%eax
+  100a04:	0f b6 00             	movzbl (%eax),%eax
+  100a07:	8d 8d dc fe ff ff    	lea    -0x124(%ebp),%ecx
+  100a0d:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  100a10:	01 ca                	add    %ecx,%edx
+  100a12:	88 02                	mov    %al,(%edx)
+        for (j = 0; j < info.eip_fn_namelen; j ++) {
+  100a14:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  100a18:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  100a1b:	3b 45 f4             	cmp    -0xc(%ebp),%eax
+  100a1e:	7f dc                	jg     1009fc <print_debuginfo+0x3d>
+        }
+        fnname[j] = '\0';
+  100a20:	8d 95 dc fe ff ff    	lea    -0x124(%ebp),%edx
+  100a26:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100a29:	01 d0                	add    %edx,%eax
+  100a2b:	c6 00 00             	movb   $0x0,(%eax)
+        cprintf("    %s:%d: %s+%d\n", info.eip_file, info.eip_line,
+                fnname, eip - info.eip_fn_addr);
+  100a2e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+        cprintf("    %s:%d: %s+%d\n", info.eip_file, info.eip_line,
+  100a31:	8b 55 08             	mov    0x8(%ebp),%edx
+  100a34:	89 d1                	mov    %edx,%ecx
+  100a36:	29 c1                	sub    %eax,%ecx
+  100a38:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  100a3b:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  100a3e:	89 4c 24 10          	mov    %ecx,0x10(%esp)
+                fnname, eip - info.eip_fn_addr);
+  100a42:	8d 8d dc fe ff ff    	lea    -0x124(%ebp),%ecx
+  100a48:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
+        cprintf("    %s:%d: %s+%d\n", info.eip_file, info.eip_line,
+  100a4c:	89 54 24 08          	mov    %edx,0x8(%esp)
+  100a50:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100a54:	c7 04 24 c2 35 10 00 	movl   $0x1035c2,(%esp)
+  100a5b:	e8 fe f7 ff ff       	call   10025e <cprintf>
+    }
+}
+  100a60:	c9                   	leave  
+  100a61:	c3                   	ret    
+
+00100a62 <read_eip>:
+
+// read_eip必须定义为常规函数而不是inline函数，因为这样的话在调用read_eip时会把当前指令的下一条指令的地址（也就是eip寄存器的值）压栈，
+// 那么在进入read_eip函数内部后便可以从栈中获取到调用前eip寄存器的值。
+static __noinline uint32_t
+read_eip(void) {
+  100a62:	55                   	push   %ebp
+  100a63:	89 e5                	mov    %esp,%ebp
+  100a65:	53                   	push   %ebx
+  100a66:	83 ec 10             	sub    $0x10,%esp
+    uint32_t eip;
+    asm volatile("movl 4(%%ebp), %0" : "=r" (eip));
+  100a69:	8b 5d 04             	mov    0x4(%ebp),%ebx
+  100a6c:	89 5d f8             	mov    %ebx,-0x8(%ebp)
+    return eip;
+  100a6f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  100a72:	83 c4 10             	add    $0x10,%esp
+  100a75:	5b                   	pop    %ebx
+  100a76:	5d                   	pop    %ebp
+  100a77:	c3                   	ret    
+
+00100a78 <print_stackframe>:
+ *
+ * Note that, the length of ebp-chain is limited. In boot/bootasm.S, before jumping
+ * to the kernel entry, the value of ebp has been set to zero, that's the boundary.
+ * */
+void
+print_stackframe(void) {
+  100a78:	55                   	push   %ebp
+  100a79:	89 e5                	mov    %esp,%ebp
+  100a7b:	53                   	push   %ebx
+  100a7c:	83 ec 34             	sub    $0x34,%esp
+
+// read_ebp必须定义为inline函数，否则获取的是执行read_ebp函数时的ebp寄存器的值
+static inline uint32_t
+read_ebp(void) {
+    uint32_t ebp;
+    asm volatile ("movl %%ebp, %0" : "=r" (ebp));
+  100a7f:	89 eb                	mov    %ebp,%ebx
+  100a81:	89 5d ec             	mov    %ebx,-0x14(%ebp)
+    return ebp;
+  100a84:	8b 45 ec             	mov    -0x14(%ebp),%eax
+      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.
+      *    (3.5) popup a calling stackframe
+      *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]
+      *                   the calling funciton's ebp = ss:[ebp]
+      */
+     uint32_t ebp = read_ebp(), eip = read_eip();//对应(1)、(2)
+  100a87:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  100a8a:	e8 d3 ff ff ff       	call   100a62 <read_eip>
+  100a8f:	89 45 f0             	mov    %eax,-0x10(%ebp)
+     while (ebp)
+  100a92:	eb 6b                	jmp    100aff <print_stackframe+0x87>
+     {
+        cprintf("ebp:0x%08x eip:0x%08x args:0x%08x 0x%08x 0x%08x 0x%08x\n", ebp, eip, ((uint32_t*)ebp + 2)[0], ((uint32_t*)ebp + 2)[1], ((uint32_t*)ebp + 2)[2], ((uint32_t*)ebp + 2)[3]); //对应(3.1)、(3.2)、(3.3)
+  100a94:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100a97:	83 c0 14             	add    $0x14,%eax
+  100a9a:	8b 18                	mov    (%eax),%ebx
+  100a9c:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100a9f:	83 c0 10             	add    $0x10,%eax
+  100aa2:	8b 08                	mov    (%eax),%ecx
+  100aa4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100aa7:	83 c0 0c             	add    $0xc,%eax
+  100aaa:	8b 10                	mov    (%eax),%edx
+  100aac:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100aaf:	83 c0 08             	add    $0x8,%eax
+  100ab2:	8b 00                	mov    (%eax),%eax
+  100ab4:	89 5c 24 18          	mov    %ebx,0x18(%esp)
+  100ab8:	89 4c 24 14          	mov    %ecx,0x14(%esp)
+  100abc:	89 54 24 10          	mov    %edx,0x10(%esp)
+  100ac0:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  100ac4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  100ac7:	89 44 24 08          	mov    %eax,0x8(%esp)
+  100acb:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100ace:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100ad2:	c7 04 24 d4 35 10 00 	movl   $0x1035d4,(%esp)
+  100ad9:	e8 80 f7 ff ff       	call   10025e <cprintf>
+        print_debuginfo(eip - 1); //对应(3.4)，由于变量eip存放的是下一条指令的地址，因此将变量eip的值减去1，得到的指令地址就属于当前指令的范围了。由于只要输入的地址属于当前指令的起始和结束位置之间，print_debuginfo都能搜索到当前指令，因此这里减去1即可。
+  100ade:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  100ae1:	83 e8 01             	sub    $0x1,%eax
+  100ae4:	89 04 24             	mov    %eax,(%esp)
+  100ae7:	e8 d3 fe ff ff       	call   1009bf <print_debuginfo>
+        //     "movl (%0, 4), %1;" 
+        //     "movl (%0), %0;"
+        //     : "=r" (ebp), "=r" (eip)
+        //     : "0" (ebp)
+        //     : "memory"); //对应(3.5)，这里默认ss基址为0
+        eip = *(uint32_t*)(ebp + 4), ebp = *(uint32_t*)ebp;
+  100aec:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100aef:	83 c0 04             	add    $0x4,%eax
+  100af2:	8b 00                	mov    (%eax),%eax
+  100af4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  100af7:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100afa:	8b 00                	mov    (%eax),%eax
+  100afc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+     while (ebp)
+  100aff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  100b03:	75 8f                	jne    100a94 <print_stackframe+0x1c>
+     }
+}
+  100b05:	83 c4 34             	add    $0x34,%esp
+  100b08:	5b                   	pop    %ebx
+  100b09:	5d                   	pop    %ebp
+  100b0a:	c3                   	ret    
+
+00100b0b <parse>:
+#define MAXARGS         16
+#define WHITESPACE      " \t\n\r"
+
+/* parse - parse the command buffer into whitespace-separated arguments */
+static int
+parse(char *buf, char **argv) {
+  100b0b:	55                   	push   %ebp
+  100b0c:	89 e5                	mov    %esp,%ebp
+  100b0e:	83 ec 28             	sub    $0x28,%esp
+    int argc = 0;
+  100b11:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    while (1) {
+        // find global whitespace
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
+  100b18:	eb 0d                	jmp    100b27 <parse+0x1c>
+        }
+        argv[argc ++] = buf;
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
+            buf ++;
+        }
+    }
+  100b1a:	90                   	nop
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
+  100b1b:	eb 0a                	jmp    100b27 <parse+0x1c>
+            *buf ++ = '\0';
+  100b1d:	8b 45 08             	mov    0x8(%ebp),%eax
+  100b20:	c6 00 00             	movb   $0x0,(%eax)
+  100b23:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) != NULL) {
+  100b27:	8b 45 08             	mov    0x8(%ebp),%eax
+  100b2a:	0f b6 00             	movzbl (%eax),%eax
+  100b2d:	84 c0                	test   %al,%al
+  100b2f:	74 1d                	je     100b4e <parse+0x43>
+  100b31:	8b 45 08             	mov    0x8(%ebp),%eax
+  100b34:	0f b6 00             	movzbl (%eax),%eax
+  100b37:	0f be c0             	movsbl %al,%eax
+  100b3a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100b3e:	c7 04 24 8c 36 10 00 	movl   $0x10368c,(%esp)
+  100b45:	e8 63 1e 00 00       	call   1029ad <strchr>
+  100b4a:	85 c0                	test   %eax,%eax
+  100b4c:	75 cf                	jne    100b1d <parse+0x12>
+        if (*buf == '\0') {
+  100b4e:	8b 45 08             	mov    0x8(%ebp),%eax
+  100b51:	0f b6 00             	movzbl (%eax),%eax
+  100b54:	84 c0                	test   %al,%al
+  100b56:	74 64                	je     100bbc <parse+0xb1>
+        if (argc == MAXARGS - 1) {
+  100b58:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
+  100b5c:	75 14                	jne    100b72 <parse+0x67>
+            cprintf("Too many arguments (max %d).\n", MAXARGS);
+  100b5e:	c7 44 24 04 10 00 00 	movl   $0x10,0x4(%esp)
+  100b65:	00 
+  100b66:	c7 04 24 91 36 10 00 	movl   $0x103691,(%esp)
+  100b6d:	e8 ec f6 ff ff       	call   10025e <cprintf>
+        argv[argc ++] = buf;
+  100b72:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100b75:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
+  100b7c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  100b7f:	01 c2                	add    %eax,%edx
+  100b81:	8b 45 08             	mov    0x8(%ebp),%eax
+  100b84:	89 02                	mov    %eax,(%edx)
+  100b86:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
+  100b8a:	eb 04                	jmp    100b90 <parse+0x85>
+            buf ++;
+  100b8c:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+        while (*buf != '\0' && strchr(WHITESPACE, *buf) == NULL) {
+  100b90:	8b 45 08             	mov    0x8(%ebp),%eax
+  100b93:	0f b6 00             	movzbl (%eax),%eax
+  100b96:	84 c0                	test   %al,%al
+  100b98:	74 80                	je     100b1a <parse+0xf>
+  100b9a:	8b 45 08             	mov    0x8(%ebp),%eax
+  100b9d:	0f b6 00             	movzbl (%eax),%eax
+  100ba0:	0f be c0             	movsbl %al,%eax
+  100ba3:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100ba7:	c7 04 24 8c 36 10 00 	movl   $0x10368c,(%esp)
+  100bae:	e8 fa 1d 00 00       	call   1029ad <strchr>
+  100bb3:	85 c0                	test   %eax,%eax
+  100bb5:	74 d5                	je     100b8c <parse+0x81>
+    }
+  100bb7:	e9 5e ff ff ff       	jmp    100b1a <parse+0xf>
+            break;
+  100bbc:	90                   	nop
+    return argc;
+  100bbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  100bc0:	c9                   	leave  
+  100bc1:	c3                   	ret    
+
+00100bc2 <runcmd>:
+/* *
+ * runcmd - parse the input string, split it into separated arguments
+ * and then lookup and invoke some related commands/
+ * */
+static int
+runcmd(char *buf, struct trapframe *tf) {
+  100bc2:	55                   	push   %ebp
+  100bc3:	89 e5                	mov    %esp,%ebp
+  100bc5:	83 ec 68             	sub    $0x68,%esp
+    char *argv[MAXARGS];
+    int argc = parse(buf, argv);
+  100bc8:	8d 45 b0             	lea    -0x50(%ebp),%eax
+  100bcb:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100bcf:	8b 45 08             	mov    0x8(%ebp),%eax
+  100bd2:	89 04 24             	mov    %eax,(%esp)
+  100bd5:	e8 31 ff ff ff       	call   100b0b <parse>
+  100bda:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    if (argc == 0) {
+  100bdd:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  100be1:	75 0a                	jne    100bed <runcmd+0x2b>
+        return 0;
+  100be3:	b8 00 00 00 00       	mov    $0x0,%eax
+  100be8:	e9 85 00 00 00       	jmp    100c72 <runcmd+0xb0>
+    }
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+  100bed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  100bf4:	eb 5c                	jmp    100c52 <runcmd+0x90>
+        if (strcmp(commands[i].name, argv[0]) == 0) {
+  100bf6:	8b 4d b0             	mov    -0x50(%ebp),%ecx
+  100bf9:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  100bfc:	89 d0                	mov    %edx,%eax
+  100bfe:	01 c0                	add    %eax,%eax
+  100c00:	01 d0                	add    %edx,%eax
+  100c02:	c1 e0 02             	shl    $0x2,%eax
+  100c05:	05 00 e0 10 00       	add    $0x10e000,%eax
+  100c0a:	8b 00                	mov    (%eax),%eax
+  100c0c:	89 4c 24 04          	mov    %ecx,0x4(%esp)
+  100c10:	89 04 24             	mov    %eax,(%esp)
+  100c13:	e8 f0 1c 00 00       	call   102908 <strcmp>
+  100c18:	85 c0                	test   %eax,%eax
+  100c1a:	75 32                	jne    100c4e <runcmd+0x8c>
+            return commands[i].func(argc - 1, argv + 1, tf);
+  100c1c:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  100c1f:	89 d0                	mov    %edx,%eax
+  100c21:	01 c0                	add    %eax,%eax
+  100c23:	01 d0                	add    %edx,%eax
+  100c25:	c1 e0 02             	shl    $0x2,%eax
+  100c28:	05 00 e0 10 00       	add    $0x10e000,%eax
+  100c2d:	8b 40 08             	mov    0x8(%eax),%eax
+  100c30:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  100c33:	8d 4a ff             	lea    -0x1(%edx),%ecx
+  100c36:	8b 55 0c             	mov    0xc(%ebp),%edx
+  100c39:	89 54 24 08          	mov    %edx,0x8(%esp)
+  100c3d:	8d 55 b0             	lea    -0x50(%ebp),%edx
+  100c40:	83 c2 04             	add    $0x4,%edx
+  100c43:	89 54 24 04          	mov    %edx,0x4(%esp)
+  100c47:	89 0c 24             	mov    %ecx,(%esp)
+  100c4a:	ff d0                	call   *%eax
+  100c4c:	eb 24                	jmp    100c72 <runcmd+0xb0>
+    for (i = 0; i < NCOMMANDS; i ++) {
+  100c4e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  100c52:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100c55:	83 f8 02             	cmp    $0x2,%eax
+  100c58:	76 9c                	jbe    100bf6 <runcmd+0x34>
+        }
+    }
+    cprintf("Unknown command '%s'\n", argv[0]);
+  100c5a:	8b 45 b0             	mov    -0x50(%ebp),%eax
+  100c5d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100c61:	c7 04 24 af 36 10 00 	movl   $0x1036af,(%esp)
+  100c68:	e8 f1 f5 ff ff       	call   10025e <cprintf>
+    return 0;
+  100c6d:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  100c72:	c9                   	leave  
+  100c73:	c3                   	ret    
+
+00100c74 <kmonitor>:
+
+/***** Implementations of basic kernel monitor commands *****/
+
+void
+kmonitor(struct trapframe *tf) {
+  100c74:	55                   	push   %ebp
+  100c75:	89 e5                	mov    %esp,%ebp
+  100c77:	83 ec 28             	sub    $0x28,%esp
+    cprintf("Welcome to the kernel debug monitor!!\n");
+  100c7a:	c7 04 24 c8 36 10 00 	movl   $0x1036c8,(%esp)
+  100c81:	e8 d8 f5 ff ff       	call   10025e <cprintf>
+    cprintf("Type 'help' for a list of commands.\n");
+  100c86:	c7 04 24 f0 36 10 00 	movl   $0x1036f0,(%esp)
+  100c8d:	e8 cc f5 ff ff       	call   10025e <cprintf>
+
+    if (tf != NULL) {
+  100c92:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  100c96:	74 0e                	je     100ca6 <kmonitor+0x32>
+        print_trapframe(tf);
+  100c98:	8b 45 08             	mov    0x8(%ebp),%eax
+  100c9b:	89 04 24             	mov    %eax,(%esp)
+  100c9e:	e8 49 0c 00 00       	call   1018ec <print_trapframe>
+  100ca3:	eb 01                	jmp    100ca6 <kmonitor+0x32>
+        if ((buf = readline("K> ")) != NULL) {
+            if (runcmd(buf, tf) < 0) {
+                break;
+            }
+        }
+    }
+  100ca5:	90                   	nop
+        if ((buf = readline("K> ")) != NULL) {
+  100ca6:	c7 04 24 15 37 10 00 	movl   $0x103715,(%esp)
+  100cad:	e8 50 f6 ff ff       	call   100302 <readline>
+  100cb2:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  100cb5:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  100cb9:	74 ea                	je     100ca5 <kmonitor+0x31>
+            if (runcmd(buf, tf) < 0) {
+  100cbb:	8b 45 08             	mov    0x8(%ebp),%eax
+  100cbe:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100cc2:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100cc5:	89 04 24             	mov    %eax,(%esp)
+  100cc8:	e8 f5 fe ff ff       	call   100bc2 <runcmd>
+  100ccd:	85 c0                	test   %eax,%eax
+  100ccf:	79 d4                	jns    100ca5 <kmonitor+0x31>
+                break;
+  100cd1:	90                   	nop
+}
+  100cd2:	c9                   	leave  
+  100cd3:	c3                   	ret    
+
+00100cd4 <mon_help>:
+
+/* mon_help - print the information about mon_* functions */
+int
+mon_help(int argc, char **argv, struct trapframe *tf) {
+  100cd4:	55                   	push   %ebp
+  100cd5:	89 e5                	mov    %esp,%ebp
+  100cd7:	83 ec 28             	sub    $0x28,%esp
+    int i;
+    for (i = 0; i < NCOMMANDS; i ++) {
+  100cda:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  100ce1:	eb 3f                	jmp    100d22 <mon_help+0x4e>
+        cprintf("%s - %s\n", commands[i].name, commands[i].desc);
+  100ce3:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  100ce6:	89 d0                	mov    %edx,%eax
+  100ce8:	01 c0                	add    %eax,%eax
+  100cea:	01 d0                	add    %edx,%eax
+  100cec:	c1 e0 02             	shl    $0x2,%eax
+  100cef:	05 00 e0 10 00       	add    $0x10e000,%eax
+  100cf4:	8b 48 04             	mov    0x4(%eax),%ecx
+  100cf7:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  100cfa:	89 d0                	mov    %edx,%eax
+  100cfc:	01 c0                	add    %eax,%eax
+  100cfe:	01 d0                	add    %edx,%eax
+  100d00:	c1 e0 02             	shl    $0x2,%eax
+  100d03:	05 00 e0 10 00       	add    $0x10e000,%eax
+  100d08:	8b 00                	mov    (%eax),%eax
+  100d0a:	89 4c 24 08          	mov    %ecx,0x8(%esp)
+  100d0e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  100d12:	c7 04 24 19 37 10 00 	movl   $0x103719,(%esp)
+  100d19:	e8 40 f5 ff ff       	call   10025e <cprintf>
+    for (i = 0; i < NCOMMANDS; i ++) {
+  100d1e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  100d22:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  100d25:	83 f8 02             	cmp    $0x2,%eax
+  100d28:	76 b9                	jbe    100ce3 <mon_help+0xf>
+    }
+    return 0;
+  100d2a:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  100d2f:	c9                   	leave  
+  100d30:	c3                   	ret    
+
+00100d31 <mon_kerninfo>:
+/* *
+ * mon_kerninfo - call print_kerninfo in kern/debug/kdebug.c to
+ * print the memory occupancy in kernel.
+ * */
+int
+mon_kerninfo(int argc, char **argv, struct trapframe *tf) {
+  100d31:	55                   	push   %ebp
+  100d32:	89 e5                	mov    %esp,%ebp
+  100d34:	83 ec 08             	sub    $0x8,%esp
+    print_kerninfo();
+  100d37:	e8 eb fb ff ff       	call   100927 <print_kerninfo>
+    return 0;
+  100d3c:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  100d41:	c9                   	leave  
+  100d42:	c3                   	ret    
+
+00100d43 <mon_backtrace>:
+/* *
+ * mon_backtrace - call print_stackframe in kern/debug/kdebug.c to
+ * print a backtrace of the stack.
+ * */
+int
+mon_backtrace(int argc, char **argv, struct trapframe *tf) {
+  100d43:	55                   	push   %ebp
+  100d44:	89 e5                	mov    %esp,%ebp
+  100d46:	83 ec 08             	sub    $0x8,%esp
+    print_stackframe();
+  100d49:	e8 2a fd ff ff       	call   100a78 <print_stackframe>
+    return 0;
+  100d4e:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  100d53:	c9                   	leave  
+  100d54:	c3                   	ret    
+
+00100d55 <clock_init>:
+/* *
+ * clock_init - initialize 8253 clock to interrupt 100 times per second,
+ * and then enable IRQ_TIMER.
+ * */
+void
+clock_init(void) {
+  100d55:	55                   	push   %ebp
+  100d56:	89 e5                	mov    %esp,%ebp
+  100d58:	83 ec 28             	sub    $0x28,%esp
+  100d5b:	66 c7 45 f6 43 00    	movw   $0x43,-0xa(%ebp)
+  100d61:	c6 45 f5 34          	movb   $0x34,-0xb(%ebp)
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port));
+  100d65:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+  100d69:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+  100d6d:	ee                   	out    %al,(%dx)
+  100d6e:	66 c7 45 f2 40 00    	movw   $0x40,-0xe(%ebp)
+  100d74:	c6 45 f1 9c          	movb   $0x9c,-0xf(%ebp)
+  100d78:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+  100d7c:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  100d80:	ee                   	out    %al,(%dx)
+  100d81:	66 c7 45 ee 40 00    	movw   $0x40,-0x12(%ebp)
+  100d87:	c6 45 ed 2e          	movb   $0x2e,-0x13(%ebp)
+  100d8b:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+  100d8f:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+  100d93:	ee                   	out    %al,(%dx)
+    outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
+    outb(IO_TIMER1, TIMER_DIV(100) % 256);
+    outb(IO_TIMER1, TIMER_DIV(100) / 256);
+
+    // initialize time counter 'ticks' to zero
+    ticks = 0;
+  100d94:	c7 05 08 f9 10 00 00 	movl   $0x0,0x10f908
+  100d9b:	00 00 00 
+
+    cprintf("++ setup timer interrupts\n");
+  100d9e:	c7 04 24 22 37 10 00 	movl   $0x103722,(%esp)
+  100da5:	e8 b4 f4 ff ff       	call   10025e <cprintf>
+    pic_enable(IRQ_TIMER);
+  100daa:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
+  100db1:	e8 52 09 00 00       	call   101708 <pic_enable>
+}
+  100db6:	c9                   	leave  
+  100db7:	c3                   	ret    
+
+00100db8 <delay>:
+#include <picirq.h>
+#include <trap.h>
+
+/* stupid I/O delay routine necessitated by historical PC design flaws */
+static void
+delay(void) {
+  100db8:	55                   	push   %ebp
+  100db9:	89 e5                	mov    %esp,%ebp
+  100dbb:	53                   	push   %ebx
+  100dbc:	83 ec 14             	sub    $0x14,%esp
+  100dbf:	66 c7 45 fa 84 00    	movw   $0x84,-0x6(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  100dc5:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+  100dc9:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
+  100dcd:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  100dd1:	ec                   	in     (%dx),%al
+  100dd2:	89 c3                	mov    %eax,%ebx
+  100dd4:	88 5d f9             	mov    %bl,-0x7(%ebp)
+  100dd7:	66 c7 45 f6 84 00    	movw   $0x84,-0xa(%ebp)
+  100ddd:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+  100de1:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
+  100de5:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  100de9:	ec                   	in     (%dx),%al
+  100dea:	89 c3                	mov    %eax,%ebx
+  100dec:	88 5d f5             	mov    %bl,-0xb(%ebp)
+  100def:	66 c7 45 f2 84 00    	movw   $0x84,-0xe(%ebp)
+  100df5:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  100df9:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
+  100dfd:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  100e01:	ec                   	in     (%dx),%al
+  100e02:	89 c3                	mov    %eax,%ebx
+  100e04:	88 5d f1             	mov    %bl,-0xf(%ebp)
+  100e07:	66 c7 45 ee 84 00    	movw   $0x84,-0x12(%ebp)
+  100e0d:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+  100e11:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
+  100e15:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  100e19:	ec                   	in     (%dx),%al
+  100e1a:	89 c3                	mov    %eax,%ebx
+  100e1c:	88 5d ed             	mov    %bl,-0x13(%ebp)
+    inb(0x84);
+    inb(0x84);
+    inb(0x84);
+    inb(0x84);
+}
+  100e1f:	83 c4 14             	add    $0x14,%esp
+  100e22:	5b                   	pop    %ebx
+  100e23:	5d                   	pop    %ebp
+  100e24:	c3                   	ret    
+
+00100e25 <cga_init>:
+//    -- 数据寄存器 映射 到 端口 0x3D5或0x3B5 
+//    -- 索引寄存器 0x3D4或0x3B4,决定在数据寄存器中的数据表示什么。
+
+/* TEXT-mode CGA/VGA display output */
+static void
+cga_init(void) {
+  100e25:	55                   	push   %ebp
+  100e26:	89 e5                	mov    %esp,%ebp
+  100e28:	53                   	push   %ebx
+  100e29:	83 ec 24             	sub    $0x24,%esp
+    volatile uint16_t *cp = (uint16_t *)CGA_BUF;   //CGA_BUF: 0xB8000 (彩色显示的显存物理基址)
+  100e2c:	c7 45 f8 00 80 0b 00 	movl   $0xb8000,-0x8(%ebp)
+    uint16_t was = *cp;                                            //保存当前显存0xB8000处的值
+  100e33:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  100e36:	0f b7 00             	movzwl (%eax),%eax
+  100e39:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
+    *cp = (uint16_t) 0xA55A;                                   // 给这个地址随便写个值，看看能否再读出同样的值
+  100e3d:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  100e40:	66 c7 00 5a a5       	movw   $0xa55a,(%eax)
+    if (*cp != 0xA55A) {                                            // 如果读不出来，说明没有这块显存，即是单显配置
+  100e45:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  100e48:	0f b7 00             	movzwl (%eax),%eax
+  100e4b:	66 3d 5a a5          	cmp    $0xa55a,%ax
+  100e4f:	74 12                	je     100e63 <cga_init+0x3e>
+        cp = (uint16_t*)MONO_BUF;                         //设置为单显的显存基址 MONO_BUF： 0xB0000
+  100e51:	c7 45 f8 00 00 0b 00 	movl   $0xb0000,-0x8(%ebp)
+        addr_6845 = MONO_BASE;                           //设置为单显控制的IO地址，MONO_BASE: 0x3B4
+  100e58:	66 c7 05 66 ee 10 00 	movw   $0x3b4,0x10ee66
+  100e5f:	b4 03 
+  100e61:	eb 13                	jmp    100e76 <cga_init+0x51>
+    } else {                                                                // 如果读出来了，有这块显存，即是彩显配置
+        *cp = was;                                                      //还原原来显存位置的值
+  100e63:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  100e66:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+  100e6a:	66 89 10             	mov    %dx,(%eax)
+        addr_6845 = CGA_BASE;                               // 设置为彩显控制的IO地址，CGA_BASE: 0x3D4 
+  100e6d:	66 c7 05 66 ee 10 00 	movw   $0x3d4,0x10ee66
+  100e74:	d4 03 
+    // Extract cursor location
+    // 6845索引寄存器的index 0x0E（及十进制的14）== 光标位置(高位)
+    // 6845索引寄存器的index 0x0F（及十进制的15）== 光标位置(低位)
+    // 6845 reg 15 : Cursor Address (Low Byte)
+    uint32_t pos;
+    outb(addr_6845, 14);                                        
+  100e76:	0f b7 05 66 ee 10 00 	movzwl 0x10ee66,%eax
+  100e7d:	0f b7 c0             	movzwl %ax,%eax
+  100e80:	66 89 45 ee          	mov    %ax,-0x12(%ebp)
+  100e84:	c6 45 ed 0e          	movb   $0xe,-0x13(%ebp)
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port));
+  100e88:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+  100e8c:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+  100e90:	ee                   	out    %al,(%dx)
+    pos = inb(addr_6845 + 1) << 8;                       //读出了光标位置(高位)
+  100e91:	0f b7 05 66 ee 10 00 	movzwl 0x10ee66,%eax
+  100e98:	83 c0 01             	add    $0x1,%eax
+  100e9b:	0f b7 c0             	movzwl %ax,%eax
+  100e9e:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  100ea2:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  100ea6:	66 89 55 da          	mov    %dx,-0x26(%ebp)
+  100eaa:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
+  100eae:	ec                   	in     (%dx),%al
+  100eaf:	89 c3                	mov    %eax,%ebx
+  100eb1:	88 5d e9             	mov    %bl,-0x17(%ebp)
+    return data;
+  100eb4:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+  100eb8:	0f b6 c0             	movzbl %al,%eax
+  100ebb:	c1 e0 08             	shl    $0x8,%eax
+  100ebe:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    outb(addr_6845, 15);
+  100ec1:	0f b7 05 66 ee 10 00 	movzwl 0x10ee66,%eax
+  100ec8:	0f b7 c0             	movzwl %ax,%eax
+  100ecb:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
+  100ecf:	c6 45 e5 0f          	movb   $0xf,-0x1b(%ebp)
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port));
+  100ed3:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
+  100ed7:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+  100edb:	ee                   	out    %al,(%dx)
+    pos |= inb(addr_6845 + 1);                             //读出了光标位置(低位)
+  100edc:	0f b7 05 66 ee 10 00 	movzwl 0x10ee66,%eax
+  100ee3:	83 c0 01             	add    $0x1,%eax
+  100ee6:	0f b7 c0             	movzwl %ax,%eax
+  100ee9:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  100eed:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
+  100ef1:	66 89 55 da          	mov    %dx,-0x26(%ebp)
+  100ef5:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
+  100ef9:	ec                   	in     (%dx),%al
+  100efa:	89 c3                	mov    %eax,%ebx
+  100efc:	88 5d e1             	mov    %bl,-0x1f(%ebp)
+    return data;
+  100eff:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
+  100f03:	0f b6 c0             	movzbl %al,%eax
+  100f06:	09 45 f0             	or     %eax,-0x10(%ebp)
+
+    crt_buf = (uint16_t*) cp;                                  //crt_buf是CGA显存起始地址
+  100f09:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  100f0c:	a3 60 ee 10 00       	mov    %eax,0x10ee60
+    crt_pos = pos;                                                  //crt_pos是CGA当前光标位置
+  100f11:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  100f14:	66 a3 64 ee 10 00    	mov    %ax,0x10ee64
+}
+  100f1a:	83 c4 24             	add    $0x24,%esp
+  100f1d:	5b                   	pop    %ebx
+  100f1e:	5d                   	pop    %ebp
+  100f1f:	c3                   	ret    
+
+00100f20 <serial_init>:
+
+static bool serial_exists = 0;
+
+static void
+serial_init(void) {
+  100f20:	55                   	push   %ebp
+  100f21:	89 e5                	mov    %esp,%ebp
+  100f23:	53                   	push   %ebx
+  100f24:	83 ec 54             	sub    $0x54,%esp
+  100f27:	66 c7 45 f6 fa 03    	movw   $0x3fa,-0xa(%ebp)
+  100f2d:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port));
+  100f31:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+  100f35:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+  100f39:	ee                   	out    %al,(%dx)
+  100f3a:	66 c7 45 f2 fb 03    	movw   $0x3fb,-0xe(%ebp)
+  100f40:	c6 45 f1 80          	movb   $0x80,-0xf(%ebp)
+  100f44:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+  100f48:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  100f4c:	ee                   	out    %al,(%dx)
+  100f4d:	66 c7 45 ee f8 03    	movw   $0x3f8,-0x12(%ebp)
+  100f53:	c6 45 ed 0c          	movb   $0xc,-0x13(%ebp)
+  100f57:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+  100f5b:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+  100f5f:	ee                   	out    %al,(%dx)
+  100f60:	66 c7 45 ea f9 03    	movw   $0x3f9,-0x16(%ebp)
+  100f66:	c6 45 e9 00          	movb   $0x0,-0x17(%ebp)
+  100f6a:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+  100f6e:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  100f72:	ee                   	out    %al,(%dx)
+  100f73:	66 c7 45 e6 fb 03    	movw   $0x3fb,-0x1a(%ebp)
+  100f79:	c6 45 e5 03          	movb   $0x3,-0x1b(%ebp)
+  100f7d:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
+  100f81:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+  100f85:	ee                   	out    %al,(%dx)
+  100f86:	66 c7 45 e2 fc 03    	movw   $0x3fc,-0x1e(%ebp)
+  100f8c:	c6 45 e1 00          	movb   $0x0,-0x1f(%ebp)
+  100f90:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
+  100f94:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
+  100f98:	ee                   	out    %al,(%dx)
+  100f99:	66 c7 45 de f9 03    	movw   $0x3f9,-0x22(%ebp)
+  100f9f:	c6 45 dd 01          	movb   $0x1,-0x23(%ebp)
+  100fa3:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
+  100fa7:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
+  100fab:	ee                   	out    %al,(%dx)
+  100fac:	66 c7 45 da fd 03    	movw   $0x3fd,-0x26(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  100fb2:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
+  100fb6:	66 89 55 c6          	mov    %dx,-0x3a(%ebp)
+  100fba:	0f b7 55 c6          	movzwl -0x3a(%ebp),%edx
+  100fbe:	ec                   	in     (%dx),%al
+  100fbf:	89 c3                	mov    %eax,%ebx
+  100fc1:	88 5d d9             	mov    %bl,-0x27(%ebp)
+    return data;
+  100fc4:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
+    // Enable rcv interrupts
+    outb(COM1 + COM_IER, COM_IER_RDI);
+
+    // Clear any preexisting overrun indications and interrupts
+    // Serial port doesn't exist if COM_LSR returns 0xFF
+    serial_exists = (inb(COM1 + COM_LSR) != 0xFF);
+  100fc8:	3c ff                	cmp    $0xff,%al
+  100fca:	0f 95 c0             	setne  %al
+  100fcd:	0f b6 c0             	movzbl %al,%eax
+  100fd0:	a3 68 ee 10 00       	mov    %eax,0x10ee68
+  100fd5:	66 c7 45 d6 fa 03    	movw   $0x3fa,-0x2a(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  100fdb:	0f b7 55 d6          	movzwl -0x2a(%ebp),%edx
+  100fdf:	66 89 55 c6          	mov    %dx,-0x3a(%ebp)
+  100fe3:	0f b7 55 c6          	movzwl -0x3a(%ebp),%edx
+  100fe7:	ec                   	in     (%dx),%al
+  100fe8:	89 c3                	mov    %eax,%ebx
+  100fea:	88 5d d5             	mov    %bl,-0x2b(%ebp)
+  100fed:	66 c7 45 d2 f8 03    	movw   $0x3f8,-0x2e(%ebp)
+  100ff3:	0f b7 55 d2          	movzwl -0x2e(%ebp),%edx
+  100ff7:	66 89 55 c6          	mov    %dx,-0x3a(%ebp)
+  100ffb:	0f b7 55 c6          	movzwl -0x3a(%ebp),%edx
+  100fff:	ec                   	in     (%dx),%al
+  101000:	89 c3                	mov    %eax,%ebx
+  101002:	88 5d d1             	mov    %bl,-0x2f(%ebp)
+    (void) inb(COM1+COM_IIR);
+    (void) inb(COM1+COM_RX);
+
+    if (serial_exists) {
+  101005:	a1 68 ee 10 00       	mov    0x10ee68,%eax
+  10100a:	85 c0                	test   %eax,%eax
+  10100c:	74 0c                	je     10101a <serial_init+0xfa>
+        pic_enable(IRQ_COM1);
+  10100e:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
+  101015:	e8 ee 06 00 00       	call   101708 <pic_enable>
+    }
+}
+  10101a:	83 c4 54             	add    $0x54,%esp
+  10101d:	5b                   	pop    %ebx
+  10101e:	5d                   	pop    %ebp
+  10101f:	c3                   	ret    
+
+00101020 <lpt_putc_sub>:
+
+static void
+lpt_putc_sub(int c) {
+  101020:	55                   	push   %ebp
+  101021:	89 e5                	mov    %esp,%ebp
+  101023:	53                   	push   %ebx
+  101024:	83 ec 24             	sub    $0x24,%esp
+    int i;
+    for (i = 0; !(inb(LPTPORT + 1) & 0x80) && i < 12800; i ++) {
+  101027:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+  10102e:	eb 09                	jmp    101039 <lpt_putc_sub+0x19>
+        delay();
+  101030:	e8 83 fd ff ff       	call   100db8 <delay>
+    for (i = 0; !(inb(LPTPORT + 1) & 0x80) && i < 12800; i ++) {
+  101035:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+  101039:	66 c7 45 f6 79 03    	movw   $0x379,-0xa(%ebp)
+  10103f:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+  101043:	66 89 55 da          	mov    %dx,-0x26(%ebp)
+  101047:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
+  10104b:	ec                   	in     (%dx),%al
+  10104c:	89 c3                	mov    %eax,%ebx
+  10104e:	88 5d f5             	mov    %bl,-0xb(%ebp)
+    return data;
+  101051:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+  101055:	84 c0                	test   %al,%al
+  101057:	78 09                	js     101062 <lpt_putc_sub+0x42>
+  101059:	81 7d f8 ff 31 00 00 	cmpl   $0x31ff,-0x8(%ebp)
+  101060:	7e ce                	jle    101030 <lpt_putc_sub+0x10>
+    }
+    outb(LPTPORT + 0, c);
+  101062:	8b 45 08             	mov    0x8(%ebp),%eax
+  101065:	0f b6 c0             	movzbl %al,%eax
+  101068:	66 c7 45 f2 78 03    	movw   $0x378,-0xe(%ebp)
+  10106e:	88 45 f1             	mov    %al,-0xf(%ebp)
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port));
+  101071:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+  101075:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  101079:	ee                   	out    %al,(%dx)
+  10107a:	66 c7 45 ee 7a 03    	movw   $0x37a,-0x12(%ebp)
+  101080:	c6 45 ed 0d          	movb   $0xd,-0x13(%ebp)
+  101084:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+  101088:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+  10108c:	ee                   	out    %al,(%dx)
+  10108d:	66 c7 45 ea 7a 03    	movw   $0x37a,-0x16(%ebp)
+  101093:	c6 45 e9 08          	movb   $0x8,-0x17(%ebp)
+  101097:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+  10109b:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  10109f:	ee                   	out    %al,(%dx)
+    outb(LPTPORT + 2, 0x08 | 0x04 | 0x01);
+    outb(LPTPORT + 2, 0x08);
+}
+  1010a0:	83 c4 24             	add    $0x24,%esp
+  1010a3:	5b                   	pop    %ebx
+  1010a4:	5d                   	pop    %ebp
+  1010a5:	c3                   	ret    
+
+001010a6 <lpt_putc>:
+
+/* lpt_putc - copy console output to parallel port */
+static void
+lpt_putc(int c) {
+  1010a6:	55                   	push   %ebp
+  1010a7:	89 e5                	mov    %esp,%ebp
+  1010a9:	83 ec 04             	sub    $0x4,%esp
+    if (c != '\b') {
+  1010ac:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
+  1010b0:	74 0d                	je     1010bf <lpt_putc+0x19>
+        lpt_putc_sub(c);
+  1010b2:	8b 45 08             	mov    0x8(%ebp),%eax
+  1010b5:	89 04 24             	mov    %eax,(%esp)
+  1010b8:	e8 63 ff ff ff       	call   101020 <lpt_putc_sub>
+  1010bd:	eb 24                	jmp    1010e3 <lpt_putc+0x3d>
+    }
+    else {
+        lpt_putc_sub('\b');
+  1010bf:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+  1010c6:	e8 55 ff ff ff       	call   101020 <lpt_putc_sub>
+        lpt_putc_sub(' ');
+  1010cb:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  1010d2:	e8 49 ff ff ff       	call   101020 <lpt_putc_sub>
+        lpt_putc_sub('\b');
+  1010d7:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+  1010de:	e8 3d ff ff ff       	call   101020 <lpt_putc_sub>
+    }
+}
+  1010e3:	c9                   	leave  
+  1010e4:	c3                   	ret    
+
+001010e5 <cga_putc>:
+
+/* cga_putc - print character to console */
+static void
+cga_putc(int c) {
+  1010e5:	55                   	push   %ebp
+  1010e6:	89 e5                	mov    %esp,%ebp
+  1010e8:	53                   	push   %ebx
+  1010e9:	83 ec 34             	sub    $0x34,%esp
+    // set black on white
+    if (!(c & ~0xFF)) {
+  1010ec:	8b 45 08             	mov    0x8(%ebp),%eax
+  1010ef:	b0 00                	mov    $0x0,%al
+  1010f1:	85 c0                	test   %eax,%eax
+  1010f3:	75 07                	jne    1010fc <cga_putc+0x17>
+        c |= 0x0700;
+  1010f5:	81 4d 08 00 07 00 00 	orl    $0x700,0x8(%ebp)
+    }
+
+    switch (c & 0xff) {
+  1010fc:	8b 45 08             	mov    0x8(%ebp),%eax
+  1010ff:	25 ff 00 00 00       	and    $0xff,%eax
+  101104:	83 f8 0a             	cmp    $0xa,%eax
+  101107:	74 4e                	je     101157 <cga_putc+0x72>
+  101109:	83 f8 0d             	cmp    $0xd,%eax
+  10110c:	74 59                	je     101167 <cga_putc+0x82>
+  10110e:	83 f8 08             	cmp    $0x8,%eax
+  101111:	0f 85 8a 00 00 00    	jne    1011a1 <cga_putc+0xbc>
+    case '\b':
+        if (crt_pos > 0) {
+  101117:	0f b7 05 64 ee 10 00 	movzwl 0x10ee64,%eax
+  10111e:	66 85 c0             	test   %ax,%ax
+  101121:	0f 84 9f 00 00 00    	je     1011c6 <cga_putc+0xe1>
+            crt_pos --;
+  101127:	0f b7 05 64 ee 10 00 	movzwl 0x10ee64,%eax
+  10112e:	83 e8 01             	sub    $0x1,%eax
+  101131:	66 a3 64 ee 10 00    	mov    %ax,0x10ee64
+            crt_buf[crt_pos] = (c & ~0xff) | ' ';
+  101137:	a1 60 ee 10 00       	mov    0x10ee60,%eax
+  10113c:	0f b7 15 64 ee 10 00 	movzwl 0x10ee64,%edx
+  101143:	0f b7 d2             	movzwl %dx,%edx
+  101146:	01 d2                	add    %edx,%edx
+  101148:	01 c2                	add    %eax,%edx
+  10114a:	8b 45 08             	mov    0x8(%ebp),%eax
+  10114d:	b0 00                	mov    $0x0,%al
+  10114f:	83 c8 20             	or     $0x20,%eax
+  101152:	66 89 02             	mov    %ax,(%edx)
+        }
+        break;
+  101155:	eb 6f                	jmp    1011c6 <cga_putc+0xe1>
+    case '\n':
+        crt_pos += CRT_COLS;
+  101157:	0f b7 05 64 ee 10 00 	movzwl 0x10ee64,%eax
+  10115e:	83 c0 50             	add    $0x50,%eax
+  101161:	66 a3 64 ee 10 00    	mov    %ax,0x10ee64
+    case '\r':
+        crt_pos -= (crt_pos % CRT_COLS);
+  101167:	0f b7 1d 64 ee 10 00 	movzwl 0x10ee64,%ebx
+  10116e:	0f b7 0d 64 ee 10 00 	movzwl 0x10ee64,%ecx
+  101175:	0f b7 c1             	movzwl %cx,%eax
+  101178:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
+  10117e:	c1 e8 10             	shr    $0x10,%eax
+  101181:	89 c2                	mov    %eax,%edx
+  101183:	66 c1 ea 06          	shr    $0x6,%dx
+  101187:	89 d0                	mov    %edx,%eax
+  101189:	c1 e0 02             	shl    $0x2,%eax
+  10118c:	01 d0                	add    %edx,%eax
+  10118e:	c1 e0 04             	shl    $0x4,%eax
+  101191:	89 ca                	mov    %ecx,%edx
+  101193:	29 c2                	sub    %eax,%edx
+  101195:	89 d8                	mov    %ebx,%eax
+  101197:	29 d0                	sub    %edx,%eax
+  101199:	66 a3 64 ee 10 00    	mov    %ax,0x10ee64
+        break;
+  10119f:	eb 26                	jmp    1011c7 <cga_putc+0xe2>
+    default:
+        crt_buf[crt_pos ++] = c;     // write the character
+  1011a1:	8b 15 60 ee 10 00    	mov    0x10ee60,%edx
+  1011a7:	0f b7 05 64 ee 10 00 	movzwl 0x10ee64,%eax
+  1011ae:	0f b7 c8             	movzwl %ax,%ecx
+  1011b1:	01 c9                	add    %ecx,%ecx
+  1011b3:	01 d1                	add    %edx,%ecx
+  1011b5:	8b 55 08             	mov    0x8(%ebp),%edx
+  1011b8:	66 89 11             	mov    %dx,(%ecx)
+  1011bb:	83 c0 01             	add    $0x1,%eax
+  1011be:	66 a3 64 ee 10 00    	mov    %ax,0x10ee64
+        break;
+  1011c4:	eb 01                	jmp    1011c7 <cga_putc+0xe2>
+        break;
+  1011c6:	90                   	nop
+    }
+
+    // What is the purpose of this?
+    if (crt_pos >= CRT_SIZE) {
+  1011c7:	0f b7 05 64 ee 10 00 	movzwl 0x10ee64,%eax
+  1011ce:	66 3d cf 07          	cmp    $0x7cf,%ax
+  1011d2:	76 5b                	jbe    10122f <cga_putc+0x14a>
+        int i;
+        memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
+  1011d4:	a1 60 ee 10 00       	mov    0x10ee60,%eax
+  1011d9:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
+  1011df:	a1 60 ee 10 00       	mov    0x10ee60,%eax
+  1011e4:	c7 44 24 08 00 0f 00 	movl   $0xf00,0x8(%esp)
+  1011eb:	00 
+  1011ec:	89 54 24 04          	mov    %edx,0x4(%esp)
+  1011f0:	89 04 24             	mov    %eax,(%esp)
+  1011f3:	e8 bf 19 00 00       	call   102bb7 <memmove>
+        for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i ++) {
+  1011f8:	c7 45 f4 80 07 00 00 	movl   $0x780,-0xc(%ebp)
+  1011ff:	eb 15                	jmp    101216 <cga_putc+0x131>
+            crt_buf[i] = 0x0700 | ' ';
+  101201:	a1 60 ee 10 00       	mov    0x10ee60,%eax
+  101206:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  101209:	01 d2                	add    %edx,%edx
+  10120b:	01 d0                	add    %edx,%eax
+  10120d:	66 c7 00 20 07       	movw   $0x720,(%eax)
+        for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i ++) {
+  101212:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  101216:	81 7d f4 cf 07 00 00 	cmpl   $0x7cf,-0xc(%ebp)
+  10121d:	7e e2                	jle    101201 <cga_putc+0x11c>
+        }
+        crt_pos -= CRT_COLS;
+  10121f:	0f b7 05 64 ee 10 00 	movzwl 0x10ee64,%eax
+  101226:	83 e8 50             	sub    $0x50,%eax
+  101229:	66 a3 64 ee 10 00    	mov    %ax,0x10ee64
+    }
+
+    // move that little blinky thing
+    outb(addr_6845, 14);
+  10122f:	0f b7 05 66 ee 10 00 	movzwl 0x10ee66,%eax
+  101236:	0f b7 c0             	movzwl %ax,%eax
+  101239:	66 89 45 f2          	mov    %ax,-0xe(%ebp)
+  10123d:	c6 45 f1 0e          	movb   $0xe,-0xf(%ebp)
+  101241:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+  101245:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  101249:	ee                   	out    %al,(%dx)
+    outb(addr_6845 + 1, crt_pos >> 8);
+  10124a:	0f b7 05 64 ee 10 00 	movzwl 0x10ee64,%eax
+  101251:	66 c1 e8 08          	shr    $0x8,%ax
+  101255:	0f b6 c0             	movzbl %al,%eax
+  101258:	0f b7 15 66 ee 10 00 	movzwl 0x10ee66,%edx
+  10125f:	83 c2 01             	add    $0x1,%edx
+  101262:	0f b7 d2             	movzwl %dx,%edx
+  101265:	66 89 55 ee          	mov    %dx,-0x12(%ebp)
+  101269:	88 45 ed             	mov    %al,-0x13(%ebp)
+  10126c:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+  101270:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+  101274:	ee                   	out    %al,(%dx)
+    outb(addr_6845, 15);
+  101275:	0f b7 05 66 ee 10 00 	movzwl 0x10ee66,%eax
+  10127c:	0f b7 c0             	movzwl %ax,%eax
+  10127f:	66 89 45 ea          	mov    %ax,-0x16(%ebp)
+  101283:	c6 45 e9 0f          	movb   $0xf,-0x17(%ebp)
+  101287:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+  10128b:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  10128f:	ee                   	out    %al,(%dx)
+    outb(addr_6845 + 1, crt_pos);
+  101290:	0f b7 05 64 ee 10 00 	movzwl 0x10ee64,%eax
+  101297:	0f b6 c0             	movzbl %al,%eax
+  10129a:	0f b7 15 66 ee 10 00 	movzwl 0x10ee66,%edx
+  1012a1:	83 c2 01             	add    $0x1,%edx
+  1012a4:	0f b7 d2             	movzwl %dx,%edx
+  1012a7:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
+  1012ab:	88 45 e5             	mov    %al,-0x1b(%ebp)
+  1012ae:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
+  1012b2:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+  1012b6:	ee                   	out    %al,(%dx)
+}
+  1012b7:	83 c4 34             	add    $0x34,%esp
+  1012ba:	5b                   	pop    %ebx
+  1012bb:	5d                   	pop    %ebp
+  1012bc:	c3                   	ret    
+
+001012bd <serial_putc_sub>:
+
+static void
+serial_putc_sub(int c) {
+  1012bd:	55                   	push   %ebp
+  1012be:	89 e5                	mov    %esp,%ebp
+  1012c0:	53                   	push   %ebx
+  1012c1:	83 ec 14             	sub    $0x14,%esp
+    int i;
+    for (i = 0; !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800; i ++) {
+  1012c4:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+  1012cb:	eb 09                	jmp    1012d6 <serial_putc_sub+0x19>
+        delay();
+  1012cd:	e8 e6 fa ff ff       	call   100db8 <delay>
+    for (i = 0; !(inb(COM1 + COM_LSR) & COM_LSR_TXRDY) && i < 12800; i ++) {
+  1012d2:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+  1012d6:	66 c7 45 f6 fd 03    	movw   $0x3fd,-0xa(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  1012dc:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+  1012e0:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
+  1012e4:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  1012e8:	ec                   	in     (%dx),%al
+  1012e9:	89 c3                	mov    %eax,%ebx
+  1012eb:	88 5d f5             	mov    %bl,-0xb(%ebp)
+    return data;
+  1012ee:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+  1012f2:	0f b6 c0             	movzbl %al,%eax
+  1012f5:	83 e0 20             	and    $0x20,%eax
+  1012f8:	85 c0                	test   %eax,%eax
+  1012fa:	75 09                	jne    101305 <serial_putc_sub+0x48>
+  1012fc:	81 7d f8 ff 31 00 00 	cmpl   $0x31ff,-0x8(%ebp)
+  101303:	7e c8                	jle    1012cd <serial_putc_sub+0x10>
+    }
+    outb(COM1 + COM_TX, c);
+  101305:	8b 45 08             	mov    0x8(%ebp),%eax
+  101308:	0f b6 c0             	movzbl %al,%eax
+  10130b:	66 c7 45 f2 f8 03    	movw   $0x3f8,-0xe(%ebp)
+  101311:	88 45 f1             	mov    %al,-0xf(%ebp)
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port));
+  101314:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+  101318:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  10131c:	ee                   	out    %al,(%dx)
+}
+  10131d:	83 c4 14             	add    $0x14,%esp
+  101320:	5b                   	pop    %ebx
+  101321:	5d                   	pop    %ebp
+  101322:	c3                   	ret    
+
+00101323 <serial_putc>:
+
+/* serial_putc - print character to serial port */
+static void
+serial_putc(int c) {
+  101323:	55                   	push   %ebp
+  101324:	89 e5                	mov    %esp,%ebp
+  101326:	83 ec 04             	sub    $0x4,%esp
+    if (c != '\b') {
+  101329:	83 7d 08 08          	cmpl   $0x8,0x8(%ebp)
+  10132d:	74 0d                	je     10133c <serial_putc+0x19>
+        serial_putc_sub(c);
+  10132f:	8b 45 08             	mov    0x8(%ebp),%eax
+  101332:	89 04 24             	mov    %eax,(%esp)
+  101335:	e8 83 ff ff ff       	call   1012bd <serial_putc_sub>
+  10133a:	eb 24                	jmp    101360 <serial_putc+0x3d>
+    }
+    else {
+        serial_putc_sub('\b');
+  10133c:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+  101343:	e8 75 ff ff ff       	call   1012bd <serial_putc_sub>
+        serial_putc_sub(' ');
+  101348:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  10134f:	e8 69 ff ff ff       	call   1012bd <serial_putc_sub>
+        serial_putc_sub('\b');
+  101354:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
+  10135b:	e8 5d ff ff ff       	call   1012bd <serial_putc_sub>
+    }
+}
+  101360:	c9                   	leave  
+  101361:	c3                   	ret    
+
+00101362 <cons_intr>:
+/* *
+ * cons_intr - called by device interrupt routines to feed input
+ * characters into the circular console input buffer.
+ * */
+static void
+cons_intr(int (*proc)(void)) {
+  101362:	55                   	push   %ebp
+  101363:	89 e5                	mov    %esp,%ebp
+  101365:	83 ec 18             	sub    $0x18,%esp
+    int c;
+    while ((c = (*proc)()) != -1) {
+  101368:	eb 32                	jmp    10139c <cons_intr+0x3a>
+        if (c != 0) {
+  10136a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
+  10136e:	74 2c                	je     10139c <cons_intr+0x3a>
+            cons.buf[cons.wpos ++] = c;
+  101370:	a1 84 f0 10 00       	mov    0x10f084,%eax
+  101375:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  101378:	88 90 80 ee 10 00    	mov    %dl,0x10ee80(%eax)
+  10137e:	83 c0 01             	add    $0x1,%eax
+  101381:	a3 84 f0 10 00       	mov    %eax,0x10f084
+            if (cons.wpos == CONSBUFSIZE) {
+  101386:	a1 84 f0 10 00       	mov    0x10f084,%eax
+  10138b:	3d 00 02 00 00       	cmp    $0x200,%eax
+  101390:	75 0a                	jne    10139c <cons_intr+0x3a>
+                cons.wpos = 0;
+  101392:	c7 05 84 f0 10 00 00 	movl   $0x0,0x10f084
+  101399:	00 00 00 
+    while ((c = (*proc)()) != -1) {
+  10139c:	8b 45 08             	mov    0x8(%ebp),%eax
+  10139f:	ff d0                	call   *%eax
+  1013a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  1013a4:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
+  1013a8:	75 c0                	jne    10136a <cons_intr+0x8>
+            }
+        }
+    }
+}
+  1013aa:	c9                   	leave  
+  1013ab:	c3                   	ret    
+
+001013ac <serial_proc_data>:
+
+/* serial_proc_data - get data from serial port */
+static int
+serial_proc_data(void) {
+  1013ac:	55                   	push   %ebp
+  1013ad:	89 e5                	mov    %esp,%ebp
+  1013af:	53                   	push   %ebx
+  1013b0:	83 ec 14             	sub    $0x14,%esp
+  1013b3:	66 c7 45 f6 fd 03    	movw   $0x3fd,-0xa(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  1013b9:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+  1013bd:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
+  1013c1:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  1013c5:	ec                   	in     (%dx),%al
+  1013c6:	89 c3                	mov    %eax,%ebx
+  1013c8:	88 5d f5             	mov    %bl,-0xb(%ebp)
+    return data;
+  1013cb:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+    if (!(inb(COM1 + COM_LSR) & COM_LSR_DATA)) {
+  1013cf:	0f b6 c0             	movzbl %al,%eax
+  1013d2:	83 e0 01             	and    $0x1,%eax
+  1013d5:	85 c0                	test   %eax,%eax
+  1013d7:	75 07                	jne    1013e0 <serial_proc_data+0x34>
+        return -1;
+  1013d9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  1013de:	eb 32                	jmp    101412 <serial_proc_data+0x66>
+  1013e0:	66 c7 45 f2 f8 03    	movw   $0x3f8,-0xe(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  1013e6:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  1013ea:	66 89 55 ea          	mov    %dx,-0x16(%ebp)
+  1013ee:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  1013f2:	ec                   	in     (%dx),%al
+  1013f3:	89 c3                	mov    %eax,%ebx
+  1013f5:	88 5d f1             	mov    %bl,-0xf(%ebp)
+    return data;
+  1013f8:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+    }
+    int c = inb(COM1 + COM_RX);
+  1013fc:	0f b6 c0             	movzbl %al,%eax
+  1013ff:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    if (c == 127) {
+  101402:	83 7d f8 7f          	cmpl   $0x7f,-0x8(%ebp)
+  101406:	75 07                	jne    10140f <serial_proc_data+0x63>
+        c = '\b';
+  101408:	c7 45 f8 08 00 00 00 	movl   $0x8,-0x8(%ebp)
+    }
+    return c;
+  10140f:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  101412:	83 c4 14             	add    $0x14,%esp
+  101415:	5b                   	pop    %ebx
+  101416:	5d                   	pop    %ebp
+  101417:	c3                   	ret    
+
+00101418 <serial_intr>:
+
+/* serial_intr - try to feed input characters from serial port */
+void
+serial_intr(void) {
+  101418:	55                   	push   %ebp
+  101419:	89 e5                	mov    %esp,%ebp
+  10141b:	83 ec 18             	sub    $0x18,%esp
+    if (serial_exists) {
+  10141e:	a1 68 ee 10 00       	mov    0x10ee68,%eax
+  101423:	85 c0                	test   %eax,%eax
+  101425:	74 0c                	je     101433 <serial_intr+0x1b>
+        cons_intr(serial_proc_data);
+  101427:	c7 04 24 ac 13 10 00 	movl   $0x1013ac,(%esp)
+  10142e:	e8 2f ff ff ff       	call   101362 <cons_intr>
+    }
+}
+  101433:	c9                   	leave  
+  101434:	c3                   	ret    
+
+00101435 <kbd_proc_data>:
+ *
+ * The kbd_proc_data() function gets data from the keyboard.
+ * If we finish a character, return it, else 0. And return -1 if no data.
+ * */
+static int
+kbd_proc_data(void) {
+  101435:	55                   	push   %ebp
+  101436:	89 e5                	mov    %esp,%ebp
+  101438:	53                   	push   %ebx
+  101439:	83 ec 44             	sub    $0x44,%esp
+  10143c:	66 c7 45 f0 64 00    	movw   $0x64,-0x10(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  101442:	0f b7 55 f0          	movzwl -0x10(%ebp),%edx
+  101446:	66 89 55 d6          	mov    %dx,-0x2a(%ebp)
+  10144a:	0f b7 55 d6          	movzwl -0x2a(%ebp),%edx
+  10144e:	ec                   	in     (%dx),%al
+  10144f:	89 c3                	mov    %eax,%ebx
+  101451:	88 5d ef             	mov    %bl,-0x11(%ebp)
+    return data;
+  101454:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+    int c;
+    uint8_t data;
+    static uint32_t shift;
+
+    if ((inb(KBSTATP) & KBS_DIB) == 0) {
+  101458:	0f b6 c0             	movzbl %al,%eax
+  10145b:	83 e0 01             	and    $0x1,%eax
+  10145e:	85 c0                	test   %eax,%eax
+  101460:	75 0a                	jne    10146c <kbd_proc_data+0x37>
+        return -1;
+  101462:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
+  101467:	e9 61 01 00 00       	jmp    1015cd <kbd_proc_data+0x198>
+  10146c:	66 c7 45 ec 60 00    	movw   $0x60,-0x14(%ebp)
+    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port));
+  101472:	0f b7 55 ec          	movzwl -0x14(%ebp),%edx
+  101476:	66 89 55 d6          	mov    %dx,-0x2a(%ebp)
+  10147a:	0f b7 55 d6          	movzwl -0x2a(%ebp),%edx
+  10147e:	ec                   	in     (%dx),%al
+  10147f:	89 c3                	mov    %eax,%ebx
+  101481:	88 5d eb             	mov    %bl,-0x15(%ebp)
+    return data;
+  101484:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
+    }
+
+    data = inb(KBDATAP);
+  101488:	88 45 f3             	mov    %al,-0xd(%ebp)
+
+    if (data == 0xE0) {
+  10148b:	80 7d f3 e0          	cmpb   $0xe0,-0xd(%ebp)
+  10148f:	75 17                	jne    1014a8 <kbd_proc_data+0x73>
+        // E0 escape character
+        shift |= E0ESC;
+  101491:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  101496:	83 c8 40             	or     $0x40,%eax
+  101499:	a3 88 f0 10 00       	mov    %eax,0x10f088
+        return 0;
+  10149e:	b8 00 00 00 00       	mov    $0x0,%eax
+  1014a3:	e9 25 01 00 00       	jmp    1015cd <kbd_proc_data+0x198>
+    } else if (data & 0x80) {
+  1014a8:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  1014ac:	84 c0                	test   %al,%al
+  1014ae:	79 47                	jns    1014f7 <kbd_proc_data+0xc2>
+        // Key released
+        data = (shift & E0ESC ? data : data & 0x7F);
+  1014b0:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  1014b5:	83 e0 40             	and    $0x40,%eax
+  1014b8:	85 c0                	test   %eax,%eax
+  1014ba:	75 09                	jne    1014c5 <kbd_proc_data+0x90>
+  1014bc:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  1014c0:	83 e0 7f             	and    $0x7f,%eax
+  1014c3:	eb 04                	jmp    1014c9 <kbd_proc_data+0x94>
+  1014c5:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  1014c9:	88 45 f3             	mov    %al,-0xd(%ebp)
+        shift &= ~(shiftcode[data] | E0ESC);
+  1014cc:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  1014d0:	0f b6 80 40 e0 10 00 	movzbl 0x10e040(%eax),%eax
+  1014d7:	83 c8 40             	or     $0x40,%eax
+  1014da:	0f b6 c0             	movzbl %al,%eax
+  1014dd:	f7 d0                	not    %eax
+  1014df:	89 c2                	mov    %eax,%edx
+  1014e1:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  1014e6:	21 d0                	and    %edx,%eax
+  1014e8:	a3 88 f0 10 00       	mov    %eax,0x10f088
+        return 0;
+  1014ed:	b8 00 00 00 00       	mov    $0x0,%eax
+  1014f2:	e9 d6 00 00 00       	jmp    1015cd <kbd_proc_data+0x198>
+    } else if (shift & E0ESC) {
+  1014f7:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  1014fc:	83 e0 40             	and    $0x40,%eax
+  1014ff:	85 c0                	test   %eax,%eax
+  101501:	74 11                	je     101514 <kbd_proc_data+0xdf>
+        // Last character was an E0 escape; or with 0x80
+        data |= 0x80;
+  101503:	80 4d f3 80          	orb    $0x80,-0xd(%ebp)
+        shift &= ~E0ESC;
+  101507:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  10150c:	83 e0 bf             	and    $0xffffffbf,%eax
+  10150f:	a3 88 f0 10 00       	mov    %eax,0x10f088
+    }
+
+    shift |= shiftcode[data];
+  101514:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  101518:	0f b6 80 40 e0 10 00 	movzbl 0x10e040(%eax),%eax
+  10151f:	0f b6 d0             	movzbl %al,%edx
+  101522:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  101527:	09 d0                	or     %edx,%eax
+  101529:	a3 88 f0 10 00       	mov    %eax,0x10f088
+    shift ^= togglecode[data];
+  10152e:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  101532:	0f b6 80 40 e1 10 00 	movzbl 0x10e140(%eax),%eax
+  101539:	0f b6 d0             	movzbl %al,%edx
+  10153c:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  101541:	31 d0                	xor    %edx,%eax
+  101543:	a3 88 f0 10 00       	mov    %eax,0x10f088
+
+    c = charcode[shift & (CTL | SHIFT)][data];
+  101548:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  10154d:	83 e0 03             	and    $0x3,%eax
+  101550:	8b 14 85 40 e5 10 00 	mov    0x10e540(,%eax,4),%edx
+  101557:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
+  10155b:	01 d0                	add    %edx,%eax
+  10155d:	0f b6 00             	movzbl (%eax),%eax
+  101560:	0f b6 c0             	movzbl %al,%eax
+  101563:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    if (shift & CAPSLOCK) {
+  101566:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  10156b:	83 e0 08             	and    $0x8,%eax
+  10156e:	85 c0                	test   %eax,%eax
+  101570:	74 22                	je     101594 <kbd_proc_data+0x15f>
+        if ('a' <= c && c <= 'z')
+  101572:	83 7d f4 60          	cmpl   $0x60,-0xc(%ebp)
+  101576:	7e 0c                	jle    101584 <kbd_proc_data+0x14f>
+  101578:	83 7d f4 7a          	cmpl   $0x7a,-0xc(%ebp)
+  10157c:	7f 06                	jg     101584 <kbd_proc_data+0x14f>
+            c += 'A' - 'a';
+  10157e:	83 6d f4 20          	subl   $0x20,-0xc(%ebp)
+  101582:	eb 10                	jmp    101594 <kbd_proc_data+0x15f>
+        else if ('A' <= c && c <= 'Z')
+  101584:	83 7d f4 40          	cmpl   $0x40,-0xc(%ebp)
+  101588:	7e 0a                	jle    101594 <kbd_proc_data+0x15f>
+  10158a:	83 7d f4 5a          	cmpl   $0x5a,-0xc(%ebp)
+  10158e:	7f 04                	jg     101594 <kbd_proc_data+0x15f>
+            c += 'a' - 'A';
+  101590:	83 45 f4 20          	addl   $0x20,-0xc(%ebp)
+    }
+
+    // Process special keys
+    // Ctrl-Alt-Del: reboot
+    if (!(~shift & (CTL | ALT)) && c == KEY_DEL) {
+  101594:	a1 88 f0 10 00       	mov    0x10f088,%eax
+  101599:	f7 d0                	not    %eax
+  10159b:	83 e0 06             	and    $0x6,%eax
+  10159e:	85 c0                	test   %eax,%eax
+  1015a0:	75 28                	jne    1015ca <kbd_proc_data+0x195>
+  1015a2:	81 7d f4 e9 00 00 00 	cmpl   $0xe9,-0xc(%ebp)
+  1015a9:	75 1f                	jne    1015ca <kbd_proc_data+0x195>
+        cprintf("Rebooting!\n");
+  1015ab:	c7 04 24 3d 37 10 00 	movl   $0x10373d,(%esp)
+  1015b2:	e8 a7 ec ff ff       	call   10025e <cprintf>
+  1015b7:	66 c7 45 e8 92 00    	movw   $0x92,-0x18(%ebp)
+  1015bd:	c6 45 e7 03          	movb   $0x3,-0x19(%ebp)
+    asm volatile ("outb %0, %1" :: "a" (data), "d" (port));
+  1015c1:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
+  1015c5:	0f b7 55 e8          	movzwl -0x18(%ebp),%edx
+  1015c9:	ee                   	out    %al,(%dx)
+        outb(0x92, 0x3); // courtesy of Chris Frost
+    }
+    return c;
+  1015ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  1015cd:	83 c4 44             	add    $0x44,%esp
+  1015d0:	5b                   	pop    %ebx
+  1015d1:	5d                   	pop    %ebp
+  1015d2:	c3                   	ret    
+
+001015d3 <kbd_intr>:
+
+/* kbd_intr - try to feed input characters from keyboard */
+static void
+kbd_intr(void) {
+  1015d3:	55                   	push   %ebp
+  1015d4:	89 e5                	mov    %esp,%ebp
+  1015d6:	83 ec 18             	sub    $0x18,%esp
+    cons_intr(kbd_proc_data);
+  1015d9:	c7 04 24 35 14 10 00 	movl   $0x101435,(%esp)
+  1015e0:	e8 7d fd ff ff       	call   101362 <cons_intr>
+}
+  1015e5:	c9                   	leave  
+  1015e6:	c3                   	ret    
+
+001015e7 <kbd_init>:
+
+static void
+kbd_init(void) {
+  1015e7:	55                   	push   %ebp
+  1015e8:	89 e5                	mov    %esp,%ebp
+  1015ea:	83 ec 18             	sub    $0x18,%esp
+    // drain the kbd buffer
+    kbd_intr();
+  1015ed:	e8 e1 ff ff ff       	call   1015d3 <kbd_intr>
+    pic_enable(IRQ_KBD);
+  1015f2:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
+  1015f9:	e8 0a 01 00 00       	call   101708 <pic_enable>
+}
+  1015fe:	c9                   	leave  
+  1015ff:	c3                   	ret    
+
+00101600 <cons_init>:
+
+/* cons_init - initializes the console devices */
+void
+cons_init(void) {
+  101600:	55                   	push   %ebp
+  101601:	89 e5                	mov    %esp,%ebp
+  101603:	83 ec 18             	sub    $0x18,%esp
+    cga_init();
+  101606:	e8 1a f8 ff ff       	call   100e25 <cga_init>
+    serial_init();
+  10160b:	e8 10 f9 ff ff       	call   100f20 <serial_init>
+    kbd_init();
+  101610:	e8 d2 ff ff ff       	call   1015e7 <kbd_init>
+    if (!serial_exists) {
+  101615:	a1 68 ee 10 00       	mov    0x10ee68,%eax
+  10161a:	85 c0                	test   %eax,%eax
+  10161c:	75 0c                	jne    10162a <cons_init+0x2a>
+        cprintf("serial port does not exist!!\n");
+  10161e:	c7 04 24 49 37 10 00 	movl   $0x103749,(%esp)
+  101625:	e8 34 ec ff ff       	call   10025e <cprintf>
+    }
+}
+  10162a:	c9                   	leave  
+  10162b:	c3                   	ret    
+
+0010162c <cons_putc>:
+
+/* cons_putc - print a single character @c to console devices */
+void
+cons_putc(int c) {
+  10162c:	55                   	push   %ebp
+  10162d:	89 e5                	mov    %esp,%ebp
+  10162f:	83 ec 18             	sub    $0x18,%esp
+    lpt_putc(c);
+  101632:	8b 45 08             	mov    0x8(%ebp),%eax
+  101635:	89 04 24             	mov    %eax,(%esp)
+  101638:	e8 69 fa ff ff       	call   1010a6 <lpt_putc>
+    cga_putc(c);
+  10163d:	8b 45 08             	mov    0x8(%ebp),%eax
+  101640:	89 04 24             	mov    %eax,(%esp)
+  101643:	e8 9d fa ff ff       	call   1010e5 <cga_putc>
+    serial_putc(c);
+  101648:	8b 45 08             	mov    0x8(%ebp),%eax
+  10164b:	89 04 24             	mov    %eax,(%esp)
+  10164e:	e8 d0 fc ff ff       	call   101323 <serial_putc>
+}
+  101653:	c9                   	leave  
+  101654:	c3                   	ret    
+
+00101655 <cons_getc>:
+/* *
+ * cons_getc - return the next input character from console,
+ * or 0 if none waiting.
+ * */
+int
+cons_getc(void) {
+  101655:	55                   	push   %ebp
+  101656:	89 e5                	mov    %esp,%ebp
+  101658:	83 ec 18             	sub    $0x18,%esp
+    int c;
+
+    // poll for any pending input characters,
+    // so that this function works even when interrupts are disabled
+    // (e.g., when called from the kernel monitor).
+    serial_intr();
+  10165b:	e8 b8 fd ff ff       	call   101418 <serial_intr>
+    kbd_intr();
+  101660:	e8 6e ff ff ff       	call   1015d3 <kbd_intr>
+
+    // grab the next character from the input buffer.
+    if (cons.rpos != cons.wpos) {
+  101665:	8b 15 80 f0 10 00    	mov    0x10f080,%edx
+  10166b:	a1 84 f0 10 00       	mov    0x10f084,%eax
+  101670:	39 c2                	cmp    %eax,%edx
+  101672:	74 35                	je     1016a9 <cons_getc+0x54>
+        c = cons.buf[cons.rpos ++];
+  101674:	a1 80 f0 10 00       	mov    0x10f080,%eax
+  101679:	0f b6 90 80 ee 10 00 	movzbl 0x10ee80(%eax),%edx
+  101680:	0f b6 d2             	movzbl %dl,%edx
+  101683:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  101686:	83 c0 01             	add    $0x1,%eax
+  101689:	a3 80 f0 10 00       	mov    %eax,0x10f080
+        if (cons.rpos == CONSBUFSIZE) {
+  10168e:	a1 80 f0 10 00       	mov    0x10f080,%eax
+  101693:	3d 00 02 00 00       	cmp    $0x200,%eax
+  101698:	75 0a                	jne    1016a4 <cons_getc+0x4f>
+            cons.rpos = 0;
+  10169a:	c7 05 80 f0 10 00 00 	movl   $0x0,0x10f080
+  1016a1:	00 00 00 
+        }
+        return c;
+  1016a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  1016a7:	eb 05                	jmp    1016ae <cons_getc+0x59>
+    }
+    return 0;
+  1016a9:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  1016ae:	c9                   	leave  
+  1016af:	c3                   	ret    
+
+001016b0 <pic_setmask>:
+// Initial IRQ mask has interrupt 2 enabled (for slave 8259A).
+static uint16_t irq_mask = 0xFFFF & ~(1 << IRQ_SLAVE);
+static bool did_init = 0;
+
+static void
+pic_setmask(uint16_t mask) {
+  1016b0:	55                   	push   %ebp
+  1016b1:	89 e5                	mov    %esp,%ebp
+  1016b3:	83 ec 14             	sub    $0x14,%esp
+  1016b6:	8b 45 08             	mov    0x8(%ebp),%eax
+  1016b9:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
+    irq_mask = mask;
+  1016bd:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+  1016c1:	66 a3 50 e5 10 00    	mov    %ax,0x10e550
+    if (did_init) {
+  1016c7:	a1 8c f0 10 00       	mov    0x10f08c,%eax
+  1016cc:	85 c0                	test   %eax,%eax
+  1016ce:	74 36                	je     101706 <pic_setmask+0x56>
+        outb(IO_PIC1 + 1, mask);
+  1016d0:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+  1016d4:	0f b6 c0             	movzbl %al,%eax
+  1016d7:	66 c7 45 fe 21 00    	movw   $0x21,-0x2(%ebp)
+  1016dd:	88 45 fd             	mov    %al,-0x3(%ebp)
+  1016e0:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
+  1016e4:	0f b7 55 fe          	movzwl -0x2(%ebp),%edx
+  1016e8:	ee                   	out    %al,(%dx)
+        outb(IO_PIC2 + 1, mask >> 8);
+  1016e9:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
+  1016ed:	66 c1 e8 08          	shr    $0x8,%ax
+  1016f1:	0f b6 c0             	movzbl %al,%eax
+  1016f4:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
+  1016fa:	88 45 f9             	mov    %al,-0x7(%ebp)
+  1016fd:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+  101701:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+  101705:	ee                   	out    %al,(%dx)
+    }
+}
+  101706:	c9                   	leave  
+  101707:	c3                   	ret    
+
+00101708 <pic_enable>:
+
+void
+pic_enable(unsigned int irq) {
+  101708:	55                   	push   %ebp
+  101709:	89 e5                	mov    %esp,%ebp
+  10170b:	53                   	push   %ebx
+  10170c:	83 ec 04             	sub    $0x4,%esp
+    pic_setmask(irq_mask & ~(1 << irq));
+  10170f:	8b 45 08             	mov    0x8(%ebp),%eax
+  101712:	ba 01 00 00 00       	mov    $0x1,%edx
+  101717:	89 d3                	mov    %edx,%ebx
+  101719:	89 c1                	mov    %eax,%ecx
+  10171b:	d3 e3                	shl    %cl,%ebx
+  10171d:	89 d8                	mov    %ebx,%eax
+  10171f:	89 c2                	mov    %eax,%edx
+  101721:	f7 d2                	not    %edx
+  101723:	0f b7 05 50 e5 10 00 	movzwl 0x10e550,%eax
+  10172a:	21 d0                	and    %edx,%eax
+  10172c:	0f b7 c0             	movzwl %ax,%eax
+  10172f:	89 04 24             	mov    %eax,(%esp)
+  101732:	e8 79 ff ff ff       	call   1016b0 <pic_setmask>
+}
+  101737:	83 c4 04             	add    $0x4,%esp
+  10173a:	5b                   	pop    %ebx
+  10173b:	5d                   	pop    %ebp
+  10173c:	c3                   	ret    
+
+0010173d <pic_init>:
+
+/* pic_init - initialize the 8259A interrupt controllers */
+void
+pic_init(void) {
+  10173d:	55                   	push   %ebp
+  10173e:	89 e5                	mov    %esp,%ebp
+  101740:	83 ec 44             	sub    $0x44,%esp
+    did_init = 1;
+  101743:	c7 05 8c f0 10 00 01 	movl   $0x1,0x10f08c
+  10174a:	00 00 00 
+  10174d:	66 c7 45 fe 21 00    	movw   $0x21,-0x2(%ebp)
+  101753:	c6 45 fd ff          	movb   $0xff,-0x3(%ebp)
+  101757:	0f b6 45 fd          	movzbl -0x3(%ebp),%eax
+  10175b:	0f b7 55 fe          	movzwl -0x2(%ebp),%edx
+  10175f:	ee                   	out    %al,(%dx)
+  101760:	66 c7 45 fa a1 00    	movw   $0xa1,-0x6(%ebp)
+  101766:	c6 45 f9 ff          	movb   $0xff,-0x7(%ebp)
+  10176a:	0f b6 45 f9          	movzbl -0x7(%ebp),%eax
+  10176e:	0f b7 55 fa          	movzwl -0x6(%ebp),%edx
+  101772:	ee                   	out    %al,(%dx)
+  101773:	66 c7 45 f6 20 00    	movw   $0x20,-0xa(%ebp)
+  101779:	c6 45 f5 11          	movb   $0x11,-0xb(%ebp)
+  10177d:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
+  101781:	0f b7 55 f6          	movzwl -0xa(%ebp),%edx
+  101785:	ee                   	out    %al,(%dx)
+  101786:	66 c7 45 f2 21 00    	movw   $0x21,-0xe(%ebp)
+  10178c:	c6 45 f1 20          	movb   $0x20,-0xf(%ebp)
+  101790:	0f b6 45 f1          	movzbl -0xf(%ebp),%eax
+  101794:	0f b7 55 f2          	movzwl -0xe(%ebp),%edx
+  101798:	ee                   	out    %al,(%dx)
+  101799:	66 c7 45 ee 21 00    	movw   $0x21,-0x12(%ebp)
+  10179f:	c6 45 ed 04          	movb   $0x4,-0x13(%ebp)
+  1017a3:	0f b6 45 ed          	movzbl -0x13(%ebp),%eax
+  1017a7:	0f b7 55 ee          	movzwl -0x12(%ebp),%edx
+  1017ab:	ee                   	out    %al,(%dx)
+  1017ac:	66 c7 45 ea 21 00    	movw   $0x21,-0x16(%ebp)
+  1017b2:	c6 45 e9 03          	movb   $0x3,-0x17(%ebp)
+  1017b6:	0f b6 45 e9          	movzbl -0x17(%ebp),%eax
+  1017ba:	0f b7 55 ea          	movzwl -0x16(%ebp),%edx
+  1017be:	ee                   	out    %al,(%dx)
+  1017bf:	66 c7 45 e6 a0 00    	movw   $0xa0,-0x1a(%ebp)
+  1017c5:	c6 45 e5 11          	movb   $0x11,-0x1b(%ebp)
+  1017c9:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
+  1017cd:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
+  1017d1:	ee                   	out    %al,(%dx)
+  1017d2:	66 c7 45 e2 a1 00    	movw   $0xa1,-0x1e(%ebp)
+  1017d8:	c6 45 e1 28          	movb   $0x28,-0x1f(%ebp)
+  1017dc:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
+  1017e0:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
+  1017e4:	ee                   	out    %al,(%dx)
+  1017e5:	66 c7 45 de a1 00    	movw   $0xa1,-0x22(%ebp)
+  1017eb:	c6 45 dd 02          	movb   $0x2,-0x23(%ebp)
+  1017ef:	0f b6 45 dd          	movzbl -0x23(%ebp),%eax
+  1017f3:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
+  1017f7:	ee                   	out    %al,(%dx)
+  1017f8:	66 c7 45 da a1 00    	movw   $0xa1,-0x26(%ebp)
+  1017fe:	c6 45 d9 03          	movb   $0x3,-0x27(%ebp)
+  101802:	0f b6 45 d9          	movzbl -0x27(%ebp),%eax
+  101806:	0f b7 55 da          	movzwl -0x26(%ebp),%edx
+  10180a:	ee                   	out    %al,(%dx)
+  10180b:	66 c7 45 d6 20 00    	movw   $0x20,-0x2a(%ebp)
+  101811:	c6 45 d5 68          	movb   $0x68,-0x2b(%ebp)
+  101815:	0f b6 45 d5          	movzbl -0x2b(%ebp),%eax
+  101819:	0f b7 55 d6          	movzwl -0x2a(%ebp),%edx
+  10181d:	ee                   	out    %al,(%dx)
+  10181e:	66 c7 45 d2 20 00    	movw   $0x20,-0x2e(%ebp)
+  101824:	c6 45 d1 0a          	movb   $0xa,-0x2f(%ebp)
+  101828:	0f b6 45 d1          	movzbl -0x2f(%ebp),%eax
+  10182c:	0f b7 55 d2          	movzwl -0x2e(%ebp),%edx
+  101830:	ee                   	out    %al,(%dx)
+  101831:	66 c7 45 ce a0 00    	movw   $0xa0,-0x32(%ebp)
+  101837:	c6 45 cd 68          	movb   $0x68,-0x33(%ebp)
+  10183b:	0f b6 45 cd          	movzbl -0x33(%ebp),%eax
+  10183f:	0f b7 55 ce          	movzwl -0x32(%ebp),%edx
+  101843:	ee                   	out    %al,(%dx)
+  101844:	66 c7 45 ca a0 00    	movw   $0xa0,-0x36(%ebp)
+  10184a:	c6 45 c9 0a          	movb   $0xa,-0x37(%ebp)
+  10184e:	0f b6 45 c9          	movzbl -0x37(%ebp),%eax
+  101852:	0f b7 55 ca          	movzwl -0x36(%ebp),%edx
+  101856:	ee                   	out    %al,(%dx)
+    outb(IO_PIC1, 0x0a);    // read IRR by default
+
+    outb(IO_PIC2, 0x68);    // OCW3
+    outb(IO_PIC2, 0x0a);    // OCW3
+
+    if (irq_mask != 0xFFFF) {
+  101857:	0f b7 05 50 e5 10 00 	movzwl 0x10e550,%eax
+  10185e:	66 83 f8 ff          	cmp    $0xffff,%ax
+  101862:	74 12                	je     101876 <pic_init+0x139>
+        pic_setmask(irq_mask);
+  101864:	0f b7 05 50 e5 10 00 	movzwl 0x10e550,%eax
+  10186b:	0f b7 c0             	movzwl %ax,%eax
+  10186e:	89 04 24             	mov    %eax,(%esp)
+  101871:	e8 3a fe ff ff       	call   1016b0 <pic_setmask>
+    }
+}
+  101876:	c9                   	leave  
+  101877:	c3                   	ret    
+
+00101878 <intr_enable>:
+#include <x86.h>
+#include <intr.h>
+
+/* intr_enable - enable irq interrupt */
+void
+intr_enable(void) {
+  101878:	55                   	push   %ebp
+  101879:	89 e5                	mov    %esp,%ebp
+    asm volatile ("lidt (%0)" :: "r" (pd));
+}
+
+static inline void
+sti(void) {
+    asm volatile ("sti");
+  10187b:	fb                   	sti    
+    sti();
+}
+  10187c:	5d                   	pop    %ebp
+  10187d:	c3                   	ret    
+
+0010187e <intr_disable>:
+
+/* intr_disable - disable irq interrupt */
+void
+intr_disable(void) {
+  10187e:	55                   	push   %ebp
+  10187f:	89 e5                	mov    %esp,%ebp
+}
+
+static inline void
+cli(void) {
+    asm volatile ("cli");
+  101881:	fa                   	cli    
+    cli();
+}
+  101882:	5d                   	pop    %ebp
+  101883:	c3                   	ret    
+
+00101884 <print_ticks>:
+#include <console.h>
+#include <kdebug.h>
+
+#define TICK_NUM 100
+
+static void print_ticks() {
+  101884:	55                   	push   %ebp
+  101885:	89 e5                	mov    %esp,%ebp
+  101887:	83 ec 18             	sub    $0x18,%esp
+    cprintf("%d ticks\n",TICK_NUM);
+  10188a:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
+  101891:	00 
+  101892:	c7 04 24 80 37 10 00 	movl   $0x103780,(%esp)
+  101899:	e8 c0 e9 ff ff       	call   10025e <cprintf>
+#ifdef DEBUG_GRADE
+    cprintf("End of Test.\n");
+    panic("EOT: kernel seems ok.");
+#endif
+}
+  10189e:	c9                   	leave  
+  10189f:	c3                   	ret    
+
+001018a0 <idt_init>:
+    sizeof(idt) - 1, (uintptr_t)idt
+};
+
+/* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */
+void
+idt_init(void) {
+  1018a0:	55                   	push   %ebp
+  1018a1:	89 e5                	mov    %esp,%ebp
+      *     Can you see idt[256] in this file? Yes, it's IDT! you can use SETGATE macro to setup each item of IDT
+      * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using 'lidt' instruction.
+      *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.
+      *     Notice: the argument of lidt is idt_pd. try to find it!
+      */
+}
+  1018a3:	5d                   	pop    %ebp
+  1018a4:	c3                   	ret    
+
+001018a5 <trapname>:
+
+static const char *
+trapname(int trapno) {
+  1018a5:	55                   	push   %ebp
+  1018a6:	89 e5                	mov    %esp,%ebp
+        "Alignment Check",
+        "Machine-Check",
+        "SIMD Floating-Point Exception"
+    };
+
+    if (trapno < sizeof(excnames)/sizeof(const char * const)) {
+  1018a8:	8b 45 08             	mov    0x8(%ebp),%eax
+  1018ab:	83 f8 13             	cmp    $0x13,%eax
+  1018ae:	77 0c                	ja     1018bc <trapname+0x17>
+        return excnames[trapno];
+  1018b0:	8b 45 08             	mov    0x8(%ebp),%eax
+  1018b3:	8b 04 85 e0 3a 10 00 	mov    0x103ae0(,%eax,4),%eax
+  1018ba:	eb 18                	jmp    1018d4 <trapname+0x2f>
+    }
+    if (trapno >= IRQ_OFFSET && trapno < IRQ_OFFSET + 16) {
+  1018bc:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
+  1018c0:	7e 0d                	jle    1018cf <trapname+0x2a>
+  1018c2:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
+  1018c6:	7f 07                	jg     1018cf <trapname+0x2a>
+        return "Hardware Interrupt";
+  1018c8:	b8 8a 37 10 00       	mov    $0x10378a,%eax
+  1018cd:	eb 05                	jmp    1018d4 <trapname+0x2f>
+    }
+    return "(unknown trap)";
+  1018cf:	b8 9d 37 10 00       	mov    $0x10379d,%eax
+}
+  1018d4:	5d                   	pop    %ebp
+  1018d5:	c3                   	ret    
+
+001018d6 <trap_in_kernel>:
+
+/* trap_in_kernel - test if trap happened in kernel */
+bool
+trap_in_kernel(struct trapframe *tf) {
+  1018d6:	55                   	push   %ebp
+  1018d7:	89 e5                	mov    %esp,%ebp
+    return (tf->tf_cs == (uint16_t)KERNEL_CS);
+  1018d9:	8b 45 08             	mov    0x8(%ebp),%eax
+  1018dc:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+  1018e0:	66 83 f8 08          	cmp    $0x8,%ax
+  1018e4:	0f 94 c0             	sete   %al
+  1018e7:	0f b6 c0             	movzbl %al,%eax
+}
+  1018ea:	5d                   	pop    %ebp
+  1018eb:	c3                   	ret    
+
+001018ec <print_trapframe>:
+    "TF", "IF", "DF", "OF", NULL, NULL, "NT", NULL,
+    "RF", "VM", "AC", "VIF", "VIP", "ID", NULL, NULL,
+};
+
+void
+print_trapframe(struct trapframe *tf) {
+  1018ec:	55                   	push   %ebp
+  1018ed:	89 e5                	mov    %esp,%ebp
+  1018ef:	83 ec 28             	sub    $0x28,%esp
+    cprintf("trapframe at %p\n", tf);
+  1018f2:	8b 45 08             	mov    0x8(%ebp),%eax
+  1018f5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1018f9:	c7 04 24 de 37 10 00 	movl   $0x1037de,(%esp)
+  101900:	e8 59 e9 ff ff       	call   10025e <cprintf>
+    print_regs(&tf->tf_regs);
+  101905:	8b 45 08             	mov    0x8(%ebp),%eax
+  101908:	89 04 24             	mov    %eax,(%esp)
+  10190b:	e8 a1 01 00 00       	call   101ab1 <print_regs>
+    cprintf("  ds   0x----%04x\n", tf->tf_ds);
+  101910:	8b 45 08             	mov    0x8(%ebp),%eax
+  101913:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
+  101917:	0f b7 c0             	movzwl %ax,%eax
+  10191a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10191e:	c7 04 24 ef 37 10 00 	movl   $0x1037ef,(%esp)
+  101925:	e8 34 e9 ff ff       	call   10025e <cprintf>
+    cprintf("  es   0x----%04x\n", tf->tf_es);
+  10192a:	8b 45 08             	mov    0x8(%ebp),%eax
+  10192d:	0f b7 40 28          	movzwl 0x28(%eax),%eax
+  101931:	0f b7 c0             	movzwl %ax,%eax
+  101934:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101938:	c7 04 24 02 38 10 00 	movl   $0x103802,(%esp)
+  10193f:	e8 1a e9 ff ff       	call   10025e <cprintf>
+    cprintf("  fs   0x----%04x\n", tf->tf_fs);
+  101944:	8b 45 08             	mov    0x8(%ebp),%eax
+  101947:	0f b7 40 24          	movzwl 0x24(%eax),%eax
+  10194b:	0f b7 c0             	movzwl %ax,%eax
+  10194e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101952:	c7 04 24 15 38 10 00 	movl   $0x103815,(%esp)
+  101959:	e8 00 e9 ff ff       	call   10025e <cprintf>
+    cprintf("  gs   0x----%04x\n", tf->tf_gs);
+  10195e:	8b 45 08             	mov    0x8(%ebp),%eax
+  101961:	0f b7 40 20          	movzwl 0x20(%eax),%eax
+  101965:	0f b7 c0             	movzwl %ax,%eax
+  101968:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10196c:	c7 04 24 28 38 10 00 	movl   $0x103828,(%esp)
+  101973:	e8 e6 e8 ff ff       	call   10025e <cprintf>
+    cprintf("  trap 0x%08x %s\n", tf->tf_trapno, trapname(tf->tf_trapno));
+  101978:	8b 45 08             	mov    0x8(%ebp),%eax
+  10197b:	8b 40 30             	mov    0x30(%eax),%eax
+  10197e:	89 04 24             	mov    %eax,(%esp)
+  101981:	e8 1f ff ff ff       	call   1018a5 <trapname>
+  101986:	8b 55 08             	mov    0x8(%ebp),%edx
+  101989:	8b 52 30             	mov    0x30(%edx),%edx
+  10198c:	89 44 24 08          	mov    %eax,0x8(%esp)
+  101990:	89 54 24 04          	mov    %edx,0x4(%esp)
+  101994:	c7 04 24 3b 38 10 00 	movl   $0x10383b,(%esp)
+  10199b:	e8 be e8 ff ff       	call   10025e <cprintf>
+    cprintf("  err  0x%08x\n", tf->tf_err);
+  1019a0:	8b 45 08             	mov    0x8(%ebp),%eax
+  1019a3:	8b 40 34             	mov    0x34(%eax),%eax
+  1019a6:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1019aa:	c7 04 24 4d 38 10 00 	movl   $0x10384d,(%esp)
+  1019b1:	e8 a8 e8 ff ff       	call   10025e <cprintf>
+    cprintf("  eip  0x%08x\n", tf->tf_eip);
+  1019b6:	8b 45 08             	mov    0x8(%ebp),%eax
+  1019b9:	8b 40 38             	mov    0x38(%eax),%eax
+  1019bc:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1019c0:	c7 04 24 5c 38 10 00 	movl   $0x10385c,(%esp)
+  1019c7:	e8 92 e8 ff ff       	call   10025e <cprintf>
+    cprintf("  cs   0x----%04x\n", tf->tf_cs);
+  1019cc:	8b 45 08             	mov    0x8(%ebp),%eax
+  1019cf:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+  1019d3:	0f b7 c0             	movzwl %ax,%eax
+  1019d6:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1019da:	c7 04 24 6b 38 10 00 	movl   $0x10386b,(%esp)
+  1019e1:	e8 78 e8 ff ff       	call   10025e <cprintf>
+    cprintf("  flag 0x%08x ", tf->tf_eflags);
+  1019e6:	8b 45 08             	mov    0x8(%ebp),%eax
+  1019e9:	8b 40 40             	mov    0x40(%eax),%eax
+  1019ec:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1019f0:	c7 04 24 7e 38 10 00 	movl   $0x10387e,(%esp)
+  1019f7:	e8 62 e8 ff ff       	call   10025e <cprintf>
+
+    int i, j;
+    for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i ++, j <<= 1) {
+  1019fc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+  101a03:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
+  101a0a:	eb 3e                	jmp    101a4a <print_trapframe+0x15e>
+        if ((tf->tf_eflags & j) && IA32flags[i] != NULL) {
+  101a0c:	8b 45 08             	mov    0x8(%ebp),%eax
+  101a0f:	8b 50 40             	mov    0x40(%eax),%edx
+  101a12:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  101a15:	21 d0                	and    %edx,%eax
+  101a17:	85 c0                	test   %eax,%eax
+  101a19:	74 28                	je     101a43 <print_trapframe+0x157>
+  101a1b:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  101a1e:	8b 04 85 80 e5 10 00 	mov    0x10e580(,%eax,4),%eax
+  101a25:	85 c0                	test   %eax,%eax
+  101a27:	74 1a                	je     101a43 <print_trapframe+0x157>
+            cprintf("%s,", IA32flags[i]);
+  101a29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  101a2c:	8b 04 85 80 e5 10 00 	mov    0x10e580(,%eax,4),%eax
+  101a33:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101a37:	c7 04 24 8d 38 10 00 	movl   $0x10388d,(%esp)
+  101a3e:	e8 1b e8 ff ff       	call   10025e <cprintf>
+    for (i = 0, j = 1; i < sizeof(IA32flags) / sizeof(IA32flags[0]); i ++, j <<= 1) {
+  101a43:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
+  101a47:	d1 65 f0             	shll   -0x10(%ebp)
+  101a4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  101a4d:	83 f8 17             	cmp    $0x17,%eax
+  101a50:	76 ba                	jbe    101a0c <print_trapframe+0x120>
+        }
+    }
+    cprintf("IOPL=%d\n", (tf->tf_eflags & FL_IOPL_MASK) >> 12);
+  101a52:	8b 45 08             	mov    0x8(%ebp),%eax
+  101a55:	8b 40 40             	mov    0x40(%eax),%eax
+  101a58:	25 00 30 00 00       	and    $0x3000,%eax
+  101a5d:	c1 e8 0c             	shr    $0xc,%eax
+  101a60:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101a64:	c7 04 24 91 38 10 00 	movl   $0x103891,(%esp)
+  101a6b:	e8 ee e7 ff ff       	call   10025e <cprintf>
+
+    if (!trap_in_kernel(tf)) {
+  101a70:	8b 45 08             	mov    0x8(%ebp),%eax
+  101a73:	89 04 24             	mov    %eax,(%esp)
+  101a76:	e8 5b fe ff ff       	call   1018d6 <trap_in_kernel>
+  101a7b:	85 c0                	test   %eax,%eax
+  101a7d:	75 30                	jne    101aaf <print_trapframe+0x1c3>
+        cprintf("  esp  0x%08x\n", tf->tf_esp);
+  101a7f:	8b 45 08             	mov    0x8(%ebp),%eax
+  101a82:	8b 40 44             	mov    0x44(%eax),%eax
+  101a85:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101a89:	c7 04 24 9a 38 10 00 	movl   $0x10389a,(%esp)
+  101a90:	e8 c9 e7 ff ff       	call   10025e <cprintf>
+        cprintf("  ss   0x----%04x\n", tf->tf_ss);
+  101a95:	8b 45 08             	mov    0x8(%ebp),%eax
+  101a98:	0f b7 40 48          	movzwl 0x48(%eax),%eax
+  101a9c:	0f b7 c0             	movzwl %ax,%eax
+  101a9f:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101aa3:	c7 04 24 a9 38 10 00 	movl   $0x1038a9,(%esp)
+  101aaa:	e8 af e7 ff ff       	call   10025e <cprintf>
+    }
+}
+  101aaf:	c9                   	leave  
+  101ab0:	c3                   	ret    
+
+00101ab1 <print_regs>:
+
+void
+print_regs(struct pushregs *regs) {
+  101ab1:	55                   	push   %ebp
+  101ab2:	89 e5                	mov    %esp,%ebp
+  101ab4:	83 ec 18             	sub    $0x18,%esp
+    cprintf("  edi  0x%08x\n", regs->reg_edi);
+  101ab7:	8b 45 08             	mov    0x8(%ebp),%eax
+  101aba:	8b 00                	mov    (%eax),%eax
+  101abc:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101ac0:	c7 04 24 bc 38 10 00 	movl   $0x1038bc,(%esp)
+  101ac7:	e8 92 e7 ff ff       	call   10025e <cprintf>
+    cprintf("  esi  0x%08x\n", regs->reg_esi);
+  101acc:	8b 45 08             	mov    0x8(%ebp),%eax
+  101acf:	8b 40 04             	mov    0x4(%eax),%eax
+  101ad2:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101ad6:	c7 04 24 cb 38 10 00 	movl   $0x1038cb,(%esp)
+  101add:	e8 7c e7 ff ff       	call   10025e <cprintf>
+    cprintf("  ebp  0x%08x\n", regs->reg_ebp);
+  101ae2:	8b 45 08             	mov    0x8(%ebp),%eax
+  101ae5:	8b 40 08             	mov    0x8(%eax),%eax
+  101ae8:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101aec:	c7 04 24 da 38 10 00 	movl   $0x1038da,(%esp)
+  101af3:	e8 66 e7 ff ff       	call   10025e <cprintf>
+    cprintf("  oesp 0x%08x\n", regs->reg_oesp);
+  101af8:	8b 45 08             	mov    0x8(%ebp),%eax
+  101afb:	8b 40 0c             	mov    0xc(%eax),%eax
+  101afe:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101b02:	c7 04 24 e9 38 10 00 	movl   $0x1038e9,(%esp)
+  101b09:	e8 50 e7 ff ff       	call   10025e <cprintf>
+    cprintf("  ebx  0x%08x\n", regs->reg_ebx);
+  101b0e:	8b 45 08             	mov    0x8(%ebp),%eax
+  101b11:	8b 40 10             	mov    0x10(%eax),%eax
+  101b14:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101b18:	c7 04 24 f8 38 10 00 	movl   $0x1038f8,(%esp)
+  101b1f:	e8 3a e7 ff ff       	call   10025e <cprintf>
+    cprintf("  edx  0x%08x\n", regs->reg_edx);
+  101b24:	8b 45 08             	mov    0x8(%ebp),%eax
+  101b27:	8b 40 14             	mov    0x14(%eax),%eax
+  101b2a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101b2e:	c7 04 24 07 39 10 00 	movl   $0x103907,(%esp)
+  101b35:	e8 24 e7 ff ff       	call   10025e <cprintf>
+    cprintf("  ecx  0x%08x\n", regs->reg_ecx);
+  101b3a:	8b 45 08             	mov    0x8(%ebp),%eax
+  101b3d:	8b 40 18             	mov    0x18(%eax),%eax
+  101b40:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101b44:	c7 04 24 16 39 10 00 	movl   $0x103916,(%esp)
+  101b4b:	e8 0e e7 ff ff       	call   10025e <cprintf>
+    cprintf("  eax  0x%08x\n", regs->reg_eax);
+  101b50:	8b 45 08             	mov    0x8(%ebp),%eax
+  101b53:	8b 40 1c             	mov    0x1c(%eax),%eax
+  101b56:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101b5a:	c7 04 24 25 39 10 00 	movl   $0x103925,(%esp)
+  101b61:	e8 f8 e6 ff ff       	call   10025e <cprintf>
+}
+  101b66:	c9                   	leave  
+  101b67:	c3                   	ret    
+
+00101b68 <trap_dispatch>:
+
+/* trap_dispatch - dispatch based on what type of trap occurred */
+static void
+trap_dispatch(struct trapframe *tf) {
+  101b68:	55                   	push   %ebp
+  101b69:	89 e5                	mov    %esp,%ebp
+  101b6b:	83 ec 28             	sub    $0x28,%esp
+    char c;
+
+    switch (tf->tf_trapno) {
+  101b6e:	8b 45 08             	mov    0x8(%ebp),%eax
+  101b71:	8b 40 30             	mov    0x30(%eax),%eax
+  101b74:	83 f8 2f             	cmp    $0x2f,%eax
+  101b77:	77 1e                	ja     101b97 <trap_dispatch+0x2f>
+  101b79:	83 f8 2e             	cmp    $0x2e,%eax
+  101b7c:	0f 83 bf 00 00 00    	jae    101c41 <trap_dispatch+0xd9>
+  101b82:	83 f8 21             	cmp    $0x21,%eax
+  101b85:	74 40                	je     101bc7 <trap_dispatch+0x5f>
+  101b87:	83 f8 24             	cmp    $0x24,%eax
+  101b8a:	74 15                	je     101ba1 <trap_dispatch+0x39>
+  101b8c:	83 f8 20             	cmp    $0x20,%eax
+  101b8f:	0f 84 af 00 00 00    	je     101c44 <trap_dispatch+0xdc>
+  101b95:	eb 72                	jmp    101c09 <trap_dispatch+0xa1>
+  101b97:	83 e8 78             	sub    $0x78,%eax
+  101b9a:	83 f8 01             	cmp    $0x1,%eax
+  101b9d:	77 6a                	ja     101c09 <trap_dispatch+0xa1>
+  101b9f:	eb 4c                	jmp    101bed <trap_dispatch+0x85>
+         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().
+         * (3) Too Simple? Yes, I think so!
+         */
+        break;
+    case IRQ_OFFSET + IRQ_COM1:
+        c = cons_getc();
+  101ba1:	e8 af fa ff ff       	call   101655 <cons_getc>
+  101ba6:	88 45 f7             	mov    %al,-0x9(%ebp)
+        cprintf("serial [%03d] %c\n", c, c);
+  101ba9:	0f be 55 f7          	movsbl -0x9(%ebp),%edx
+  101bad:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  101bb1:	89 54 24 08          	mov    %edx,0x8(%esp)
+  101bb5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101bb9:	c7 04 24 34 39 10 00 	movl   $0x103934,(%esp)
+  101bc0:	e8 99 e6 ff ff       	call   10025e <cprintf>
+        break;
+  101bc5:	eb 7e                	jmp    101c45 <trap_dispatch+0xdd>
+    case IRQ_OFFSET + IRQ_KBD:
+        c = cons_getc();
+  101bc7:	e8 89 fa ff ff       	call   101655 <cons_getc>
+  101bcc:	88 45 f7             	mov    %al,-0x9(%ebp)
+        cprintf("kbd [%03d] %c\n", c, c);
+  101bcf:	0f be 55 f7          	movsbl -0x9(%ebp),%edx
+  101bd3:	0f be 45 f7          	movsbl -0x9(%ebp),%eax
+  101bd7:	89 54 24 08          	mov    %edx,0x8(%esp)
+  101bdb:	89 44 24 04          	mov    %eax,0x4(%esp)
+  101bdf:	c7 04 24 46 39 10 00 	movl   $0x103946,(%esp)
+  101be6:	e8 73 e6 ff ff       	call   10025e <cprintf>
+        break;
+  101beb:	eb 58                	jmp    101c45 <trap_dispatch+0xdd>
+    //LAB1 CHALLENGE 1 : YOUR CODE you should modify below codes.
+    case T_SWITCH_TOU:
+    case T_SWITCH_TOK:
+        panic("T_SWITCH_** ??\n");
+  101bed:	c7 44 24 08 55 39 10 	movl   $0x103955,0x8(%esp)
+  101bf4:	00 
+  101bf5:	c7 44 24 04 a2 00 00 	movl   $0xa2,0x4(%esp)
+  101bfc:	00 
+  101bfd:	c7 04 24 65 39 10 00 	movl   $0x103965,(%esp)
+  101c04:	e8 b2 e7 ff ff       	call   1003bb <__panic>
+    case IRQ_OFFSET + IRQ_IDE2:
+        /* do nothing */
+        break;
+    default:
+        // in kernel, it must be a mistake
+        if ((tf->tf_cs & 3) == 0) {
+  101c09:	8b 45 08             	mov    0x8(%ebp),%eax
+  101c0c:	0f b7 40 3c          	movzwl 0x3c(%eax),%eax
+  101c10:	0f b7 c0             	movzwl %ax,%eax
+  101c13:	83 e0 03             	and    $0x3,%eax
+  101c16:	85 c0                	test   %eax,%eax
+  101c18:	75 2b                	jne    101c45 <trap_dispatch+0xdd>
+            print_trapframe(tf);
+  101c1a:	8b 45 08             	mov    0x8(%ebp),%eax
+  101c1d:	89 04 24             	mov    %eax,(%esp)
+  101c20:	e8 c7 fc ff ff       	call   1018ec <print_trapframe>
+            panic("unexpected trap in kernel.\n");
+  101c25:	c7 44 24 08 76 39 10 	movl   $0x103976,0x8(%esp)
+  101c2c:	00 
+  101c2d:	c7 44 24 04 ac 00 00 	movl   $0xac,0x4(%esp)
+  101c34:	00 
+  101c35:	c7 04 24 65 39 10 00 	movl   $0x103965,(%esp)
+  101c3c:	e8 7a e7 ff ff       	call   1003bb <__panic>
+        break;
+  101c41:	90                   	nop
+  101c42:	eb 01                	jmp    101c45 <trap_dispatch+0xdd>
+        break;
+  101c44:	90                   	nop
+        }
+    }
+}
+  101c45:	c9                   	leave  
+  101c46:	c3                   	ret    
+
+00101c47 <trap>:
+ * trap - handles or dispatches an exception/interrupt. if and when trap() returns,
+ * the code in kern/trap/trapentry.S restores the old CPU state saved in the
+ * trapframe and then uses the iret instruction to return from the exception.
+ * */
+void
+trap(struct trapframe *tf) {
+  101c47:	55                   	push   %ebp
+  101c48:	89 e5                	mov    %esp,%ebp
+  101c4a:	83 ec 18             	sub    $0x18,%esp
+    // dispatch based on what type of trap occurred
+    trap_dispatch(tf);
+  101c4d:	8b 45 08             	mov    0x8(%ebp),%eax
+  101c50:	89 04 24             	mov    %eax,(%esp)
+  101c53:	e8 10 ff ff ff       	call   101b68 <trap_dispatch>
+}
+  101c58:	c9                   	leave  
+  101c59:	c3                   	ret    
+
+00101c5a <vector0>:
+# handler
+.text
+.globl __alltraps
+.globl vector0
+vector0:
+  pushl $0
+  101c5a:	6a 00                	push   $0x0
+  pushl $0
+  101c5c:	6a 00                	push   $0x0
+  jmp __alltraps
+  101c5e:	e9 69 0a 00 00       	jmp    1026cc <__alltraps>
+
+00101c63 <vector1>:
+.globl vector1
+vector1:
+  pushl $0
+  101c63:	6a 00                	push   $0x0
+  pushl $1
+  101c65:	6a 01                	push   $0x1
+  jmp __alltraps
+  101c67:	e9 60 0a 00 00       	jmp    1026cc <__alltraps>
+
+00101c6c <vector2>:
+.globl vector2
+vector2:
+  pushl $0
+  101c6c:	6a 00                	push   $0x0
+  pushl $2
+  101c6e:	6a 02                	push   $0x2
+  jmp __alltraps
+  101c70:	e9 57 0a 00 00       	jmp    1026cc <__alltraps>
+
+00101c75 <vector3>:
+.globl vector3
+vector3:
+  pushl $0
+  101c75:	6a 00                	push   $0x0
+  pushl $3
+  101c77:	6a 03                	push   $0x3
+  jmp __alltraps
+  101c79:	e9 4e 0a 00 00       	jmp    1026cc <__alltraps>
+
+00101c7e <vector4>:
+.globl vector4
+vector4:
+  pushl $0
+  101c7e:	6a 00                	push   $0x0
+  pushl $4
+  101c80:	6a 04                	push   $0x4
+  jmp __alltraps
+  101c82:	e9 45 0a 00 00       	jmp    1026cc <__alltraps>
+
+00101c87 <vector5>:
+.globl vector5
+vector5:
+  pushl $0
+  101c87:	6a 00                	push   $0x0
+  pushl $5
+  101c89:	6a 05                	push   $0x5
+  jmp __alltraps
+  101c8b:	e9 3c 0a 00 00       	jmp    1026cc <__alltraps>
+
+00101c90 <vector6>:
+.globl vector6
+vector6:
+  pushl $0
+  101c90:	6a 00                	push   $0x0
+  pushl $6
+  101c92:	6a 06                	push   $0x6
+  jmp __alltraps
+  101c94:	e9 33 0a 00 00       	jmp    1026cc <__alltraps>
+
+00101c99 <vector7>:
+.globl vector7
+vector7:
+  pushl $0
+  101c99:	6a 00                	push   $0x0
+  pushl $7
+  101c9b:	6a 07                	push   $0x7
+  jmp __alltraps
+  101c9d:	e9 2a 0a 00 00       	jmp    1026cc <__alltraps>
+
+00101ca2 <vector8>:
+.globl vector8
+vector8:
+  pushl $8
+  101ca2:	6a 08                	push   $0x8
+  jmp __alltraps
+  101ca4:	e9 23 0a 00 00       	jmp    1026cc <__alltraps>
+
+00101ca9 <vector9>:
+.globl vector9
+vector9:
+  pushl $0
+  101ca9:	6a 00                	push   $0x0
+  pushl $9
+  101cab:	6a 09                	push   $0x9
+  jmp __alltraps
+  101cad:	e9 1a 0a 00 00       	jmp    1026cc <__alltraps>
+
+00101cb2 <vector10>:
+.globl vector10
+vector10:
+  pushl $10
+  101cb2:	6a 0a                	push   $0xa
+  jmp __alltraps
+  101cb4:	e9 13 0a 00 00       	jmp    1026cc <__alltraps>
+
+00101cb9 <vector11>:
+.globl vector11
+vector11:
+  pushl $11
+  101cb9:	6a 0b                	push   $0xb
+  jmp __alltraps
+  101cbb:	e9 0c 0a 00 00       	jmp    1026cc <__alltraps>
+
+00101cc0 <vector12>:
+.globl vector12
+vector12:
+  pushl $12
+  101cc0:	6a 0c                	push   $0xc
+  jmp __alltraps
+  101cc2:	e9 05 0a 00 00       	jmp    1026cc <__alltraps>
+
+00101cc7 <vector13>:
+.globl vector13
+vector13:
+  pushl $13
+  101cc7:	6a 0d                	push   $0xd
+  jmp __alltraps
+  101cc9:	e9 fe 09 00 00       	jmp    1026cc <__alltraps>
+
+00101cce <vector14>:
+.globl vector14
+vector14:
+  pushl $14
+  101cce:	6a 0e                	push   $0xe
+  jmp __alltraps
+  101cd0:	e9 f7 09 00 00       	jmp    1026cc <__alltraps>
+
+00101cd5 <vector15>:
+.globl vector15
+vector15:
+  pushl $0
+  101cd5:	6a 00                	push   $0x0
+  pushl $15
+  101cd7:	6a 0f                	push   $0xf
+  jmp __alltraps
+  101cd9:	e9 ee 09 00 00       	jmp    1026cc <__alltraps>
+
+00101cde <vector16>:
+.globl vector16
+vector16:
+  pushl $0
+  101cde:	6a 00                	push   $0x0
+  pushl $16
+  101ce0:	6a 10                	push   $0x10
+  jmp __alltraps
+  101ce2:	e9 e5 09 00 00       	jmp    1026cc <__alltraps>
+
+00101ce7 <vector17>:
+.globl vector17
+vector17:
+  pushl $17
+  101ce7:	6a 11                	push   $0x11
+  jmp __alltraps
+  101ce9:	e9 de 09 00 00       	jmp    1026cc <__alltraps>
+
+00101cee <vector18>:
+.globl vector18
+vector18:
+  pushl $0
+  101cee:	6a 00                	push   $0x0
+  pushl $18
+  101cf0:	6a 12                	push   $0x12
+  jmp __alltraps
+  101cf2:	e9 d5 09 00 00       	jmp    1026cc <__alltraps>
+
+00101cf7 <vector19>:
+.globl vector19
+vector19:
+  pushl $0
+  101cf7:	6a 00                	push   $0x0
+  pushl $19
+  101cf9:	6a 13                	push   $0x13
+  jmp __alltraps
+  101cfb:	e9 cc 09 00 00       	jmp    1026cc <__alltraps>
+
+00101d00 <vector20>:
+.globl vector20
+vector20:
+  pushl $0
+  101d00:	6a 00                	push   $0x0
+  pushl $20
+  101d02:	6a 14                	push   $0x14
+  jmp __alltraps
+  101d04:	e9 c3 09 00 00       	jmp    1026cc <__alltraps>
+
+00101d09 <vector21>:
+.globl vector21
+vector21:
+  pushl $0
+  101d09:	6a 00                	push   $0x0
+  pushl $21
+  101d0b:	6a 15                	push   $0x15
+  jmp __alltraps
+  101d0d:	e9 ba 09 00 00       	jmp    1026cc <__alltraps>
+
+00101d12 <vector22>:
+.globl vector22
+vector22:
+  pushl $0
+  101d12:	6a 00                	push   $0x0
+  pushl $22
+  101d14:	6a 16                	push   $0x16
+  jmp __alltraps
+  101d16:	e9 b1 09 00 00       	jmp    1026cc <__alltraps>
+
+00101d1b <vector23>:
+.globl vector23
+vector23:
+  pushl $0
+  101d1b:	6a 00                	push   $0x0
+  pushl $23
+  101d1d:	6a 17                	push   $0x17
+  jmp __alltraps
+  101d1f:	e9 a8 09 00 00       	jmp    1026cc <__alltraps>
+
+00101d24 <vector24>:
+.globl vector24
+vector24:
+  pushl $0
+  101d24:	6a 00                	push   $0x0
+  pushl $24
+  101d26:	6a 18                	push   $0x18
+  jmp __alltraps
+  101d28:	e9 9f 09 00 00       	jmp    1026cc <__alltraps>
+
+00101d2d <vector25>:
+.globl vector25
+vector25:
+  pushl $0
+  101d2d:	6a 00                	push   $0x0
+  pushl $25
+  101d2f:	6a 19                	push   $0x19
+  jmp __alltraps
+  101d31:	e9 96 09 00 00       	jmp    1026cc <__alltraps>
+
+00101d36 <vector26>:
+.globl vector26
+vector26:
+  pushl $0
+  101d36:	6a 00                	push   $0x0
+  pushl $26
+  101d38:	6a 1a                	push   $0x1a
+  jmp __alltraps
+  101d3a:	e9 8d 09 00 00       	jmp    1026cc <__alltraps>
+
+00101d3f <vector27>:
+.globl vector27
+vector27:
+  pushl $0
+  101d3f:	6a 00                	push   $0x0
+  pushl $27
+  101d41:	6a 1b                	push   $0x1b
+  jmp __alltraps
+  101d43:	e9 84 09 00 00       	jmp    1026cc <__alltraps>
+
+00101d48 <vector28>:
+.globl vector28
+vector28:
+  pushl $0
+  101d48:	6a 00                	push   $0x0
+  pushl $28
+  101d4a:	6a 1c                	push   $0x1c
+  jmp __alltraps
+  101d4c:	e9 7b 09 00 00       	jmp    1026cc <__alltraps>
+
+00101d51 <vector29>:
+.globl vector29
+vector29:
+  pushl $0
+  101d51:	6a 00                	push   $0x0
+  pushl $29
+  101d53:	6a 1d                	push   $0x1d
+  jmp __alltraps
+  101d55:	e9 72 09 00 00       	jmp    1026cc <__alltraps>
+
+00101d5a <vector30>:
+.globl vector30
+vector30:
+  pushl $0
+  101d5a:	6a 00                	push   $0x0
+  pushl $30
+  101d5c:	6a 1e                	push   $0x1e
+  jmp __alltraps
+  101d5e:	e9 69 09 00 00       	jmp    1026cc <__alltraps>
+
+00101d63 <vector31>:
+.globl vector31
+vector31:
+  pushl $0
+  101d63:	6a 00                	push   $0x0
+  pushl $31
+  101d65:	6a 1f                	push   $0x1f
+  jmp __alltraps
+  101d67:	e9 60 09 00 00       	jmp    1026cc <__alltraps>
+
+00101d6c <vector32>:
+.globl vector32
+vector32:
+  pushl $0
+  101d6c:	6a 00                	push   $0x0
+  pushl $32
+  101d6e:	6a 20                	push   $0x20
+  jmp __alltraps
+  101d70:	e9 57 09 00 00       	jmp    1026cc <__alltraps>
+
+00101d75 <vector33>:
+.globl vector33
+vector33:
+  pushl $0
+  101d75:	6a 00                	push   $0x0
+  pushl $33
+  101d77:	6a 21                	push   $0x21
+  jmp __alltraps
+  101d79:	e9 4e 09 00 00       	jmp    1026cc <__alltraps>
+
+00101d7e <vector34>:
+.globl vector34
+vector34:
+  pushl $0
+  101d7e:	6a 00                	push   $0x0
+  pushl $34
+  101d80:	6a 22                	push   $0x22
+  jmp __alltraps
+  101d82:	e9 45 09 00 00       	jmp    1026cc <__alltraps>
+
+00101d87 <vector35>:
+.globl vector35
+vector35:
+  pushl $0
+  101d87:	6a 00                	push   $0x0
+  pushl $35
+  101d89:	6a 23                	push   $0x23
+  jmp __alltraps
+  101d8b:	e9 3c 09 00 00       	jmp    1026cc <__alltraps>
+
+00101d90 <vector36>:
+.globl vector36
+vector36:
+  pushl $0
+  101d90:	6a 00                	push   $0x0
+  pushl $36
+  101d92:	6a 24                	push   $0x24
+  jmp __alltraps
+  101d94:	e9 33 09 00 00       	jmp    1026cc <__alltraps>
+
+00101d99 <vector37>:
+.globl vector37
+vector37:
+  pushl $0
+  101d99:	6a 00                	push   $0x0
+  pushl $37
+  101d9b:	6a 25                	push   $0x25
+  jmp __alltraps
+  101d9d:	e9 2a 09 00 00       	jmp    1026cc <__alltraps>
+
+00101da2 <vector38>:
+.globl vector38
+vector38:
+  pushl $0
+  101da2:	6a 00                	push   $0x0
+  pushl $38
+  101da4:	6a 26                	push   $0x26
+  jmp __alltraps
+  101da6:	e9 21 09 00 00       	jmp    1026cc <__alltraps>
+
+00101dab <vector39>:
+.globl vector39
+vector39:
+  pushl $0
+  101dab:	6a 00                	push   $0x0
+  pushl $39
+  101dad:	6a 27                	push   $0x27
+  jmp __alltraps
+  101daf:	e9 18 09 00 00       	jmp    1026cc <__alltraps>
+
+00101db4 <vector40>:
+.globl vector40
+vector40:
+  pushl $0
+  101db4:	6a 00                	push   $0x0
+  pushl $40
+  101db6:	6a 28                	push   $0x28
+  jmp __alltraps
+  101db8:	e9 0f 09 00 00       	jmp    1026cc <__alltraps>
+
+00101dbd <vector41>:
+.globl vector41
+vector41:
+  pushl $0
+  101dbd:	6a 00                	push   $0x0
+  pushl $41
+  101dbf:	6a 29                	push   $0x29
+  jmp __alltraps
+  101dc1:	e9 06 09 00 00       	jmp    1026cc <__alltraps>
+
+00101dc6 <vector42>:
+.globl vector42
+vector42:
+  pushl $0
+  101dc6:	6a 00                	push   $0x0
+  pushl $42
+  101dc8:	6a 2a                	push   $0x2a
+  jmp __alltraps
+  101dca:	e9 fd 08 00 00       	jmp    1026cc <__alltraps>
+
+00101dcf <vector43>:
+.globl vector43
+vector43:
+  pushl $0
+  101dcf:	6a 00                	push   $0x0
+  pushl $43
+  101dd1:	6a 2b                	push   $0x2b
+  jmp __alltraps
+  101dd3:	e9 f4 08 00 00       	jmp    1026cc <__alltraps>
+
+00101dd8 <vector44>:
+.globl vector44
+vector44:
+  pushl $0
+  101dd8:	6a 00                	push   $0x0
+  pushl $44
+  101dda:	6a 2c                	push   $0x2c
+  jmp __alltraps
+  101ddc:	e9 eb 08 00 00       	jmp    1026cc <__alltraps>
+
+00101de1 <vector45>:
+.globl vector45
+vector45:
+  pushl $0
+  101de1:	6a 00                	push   $0x0
+  pushl $45
+  101de3:	6a 2d                	push   $0x2d
+  jmp __alltraps
+  101de5:	e9 e2 08 00 00       	jmp    1026cc <__alltraps>
+
+00101dea <vector46>:
+.globl vector46
+vector46:
+  pushl $0
+  101dea:	6a 00                	push   $0x0
+  pushl $46
+  101dec:	6a 2e                	push   $0x2e
+  jmp __alltraps
+  101dee:	e9 d9 08 00 00       	jmp    1026cc <__alltraps>
+
+00101df3 <vector47>:
+.globl vector47
+vector47:
+  pushl $0
+  101df3:	6a 00                	push   $0x0
+  pushl $47
+  101df5:	6a 2f                	push   $0x2f
+  jmp __alltraps
+  101df7:	e9 d0 08 00 00       	jmp    1026cc <__alltraps>
+
+00101dfc <vector48>:
+.globl vector48
+vector48:
+  pushl $0
+  101dfc:	6a 00                	push   $0x0
+  pushl $48
+  101dfe:	6a 30                	push   $0x30
+  jmp __alltraps
+  101e00:	e9 c7 08 00 00       	jmp    1026cc <__alltraps>
+
+00101e05 <vector49>:
+.globl vector49
+vector49:
+  pushl $0
+  101e05:	6a 00                	push   $0x0
+  pushl $49
+  101e07:	6a 31                	push   $0x31
+  jmp __alltraps
+  101e09:	e9 be 08 00 00       	jmp    1026cc <__alltraps>
+
+00101e0e <vector50>:
+.globl vector50
+vector50:
+  pushl $0
+  101e0e:	6a 00                	push   $0x0
+  pushl $50
+  101e10:	6a 32                	push   $0x32
+  jmp __alltraps
+  101e12:	e9 b5 08 00 00       	jmp    1026cc <__alltraps>
+
+00101e17 <vector51>:
+.globl vector51
+vector51:
+  pushl $0
+  101e17:	6a 00                	push   $0x0
+  pushl $51
+  101e19:	6a 33                	push   $0x33
+  jmp __alltraps
+  101e1b:	e9 ac 08 00 00       	jmp    1026cc <__alltraps>
+
+00101e20 <vector52>:
+.globl vector52
+vector52:
+  pushl $0
+  101e20:	6a 00                	push   $0x0
+  pushl $52
+  101e22:	6a 34                	push   $0x34
+  jmp __alltraps
+  101e24:	e9 a3 08 00 00       	jmp    1026cc <__alltraps>
+
+00101e29 <vector53>:
+.globl vector53
+vector53:
+  pushl $0
+  101e29:	6a 00                	push   $0x0
+  pushl $53
+  101e2b:	6a 35                	push   $0x35
+  jmp __alltraps
+  101e2d:	e9 9a 08 00 00       	jmp    1026cc <__alltraps>
+
+00101e32 <vector54>:
+.globl vector54
+vector54:
+  pushl $0
+  101e32:	6a 00                	push   $0x0
+  pushl $54
+  101e34:	6a 36                	push   $0x36
+  jmp __alltraps
+  101e36:	e9 91 08 00 00       	jmp    1026cc <__alltraps>
+
+00101e3b <vector55>:
+.globl vector55
+vector55:
+  pushl $0
+  101e3b:	6a 00                	push   $0x0
+  pushl $55
+  101e3d:	6a 37                	push   $0x37
+  jmp __alltraps
+  101e3f:	e9 88 08 00 00       	jmp    1026cc <__alltraps>
+
+00101e44 <vector56>:
+.globl vector56
+vector56:
+  pushl $0
+  101e44:	6a 00                	push   $0x0
+  pushl $56
+  101e46:	6a 38                	push   $0x38
+  jmp __alltraps
+  101e48:	e9 7f 08 00 00       	jmp    1026cc <__alltraps>
+
+00101e4d <vector57>:
+.globl vector57
+vector57:
+  pushl $0
+  101e4d:	6a 00                	push   $0x0
+  pushl $57
+  101e4f:	6a 39                	push   $0x39
+  jmp __alltraps
+  101e51:	e9 76 08 00 00       	jmp    1026cc <__alltraps>
+
+00101e56 <vector58>:
+.globl vector58
+vector58:
+  pushl $0
+  101e56:	6a 00                	push   $0x0
+  pushl $58
+  101e58:	6a 3a                	push   $0x3a
+  jmp __alltraps
+  101e5a:	e9 6d 08 00 00       	jmp    1026cc <__alltraps>
+
+00101e5f <vector59>:
+.globl vector59
+vector59:
+  pushl $0
+  101e5f:	6a 00                	push   $0x0
+  pushl $59
+  101e61:	6a 3b                	push   $0x3b
+  jmp __alltraps
+  101e63:	e9 64 08 00 00       	jmp    1026cc <__alltraps>
+
+00101e68 <vector60>:
+.globl vector60
+vector60:
+  pushl $0
+  101e68:	6a 00                	push   $0x0
+  pushl $60
+  101e6a:	6a 3c                	push   $0x3c
+  jmp __alltraps
+  101e6c:	e9 5b 08 00 00       	jmp    1026cc <__alltraps>
+
+00101e71 <vector61>:
+.globl vector61
+vector61:
+  pushl $0
+  101e71:	6a 00                	push   $0x0
+  pushl $61
+  101e73:	6a 3d                	push   $0x3d
+  jmp __alltraps
+  101e75:	e9 52 08 00 00       	jmp    1026cc <__alltraps>
+
+00101e7a <vector62>:
+.globl vector62
+vector62:
+  pushl $0
+  101e7a:	6a 00                	push   $0x0
+  pushl $62
+  101e7c:	6a 3e                	push   $0x3e
+  jmp __alltraps
+  101e7e:	e9 49 08 00 00       	jmp    1026cc <__alltraps>
+
+00101e83 <vector63>:
+.globl vector63
+vector63:
+  pushl $0
+  101e83:	6a 00                	push   $0x0
+  pushl $63
+  101e85:	6a 3f                	push   $0x3f
+  jmp __alltraps
+  101e87:	e9 40 08 00 00       	jmp    1026cc <__alltraps>
+
+00101e8c <vector64>:
+.globl vector64
+vector64:
+  pushl $0
+  101e8c:	6a 00                	push   $0x0
+  pushl $64
+  101e8e:	6a 40                	push   $0x40
+  jmp __alltraps
+  101e90:	e9 37 08 00 00       	jmp    1026cc <__alltraps>
+
+00101e95 <vector65>:
+.globl vector65
+vector65:
+  pushl $0
+  101e95:	6a 00                	push   $0x0
+  pushl $65
+  101e97:	6a 41                	push   $0x41
+  jmp __alltraps
+  101e99:	e9 2e 08 00 00       	jmp    1026cc <__alltraps>
+
+00101e9e <vector66>:
+.globl vector66
+vector66:
+  pushl $0
+  101e9e:	6a 00                	push   $0x0
+  pushl $66
+  101ea0:	6a 42                	push   $0x42
+  jmp __alltraps
+  101ea2:	e9 25 08 00 00       	jmp    1026cc <__alltraps>
+
+00101ea7 <vector67>:
+.globl vector67
+vector67:
+  pushl $0
+  101ea7:	6a 00                	push   $0x0
+  pushl $67
+  101ea9:	6a 43                	push   $0x43
+  jmp __alltraps
+  101eab:	e9 1c 08 00 00       	jmp    1026cc <__alltraps>
+
+00101eb0 <vector68>:
+.globl vector68
+vector68:
+  pushl $0
+  101eb0:	6a 00                	push   $0x0
+  pushl $68
+  101eb2:	6a 44                	push   $0x44
+  jmp __alltraps
+  101eb4:	e9 13 08 00 00       	jmp    1026cc <__alltraps>
+
+00101eb9 <vector69>:
+.globl vector69
+vector69:
+  pushl $0
+  101eb9:	6a 00                	push   $0x0
+  pushl $69
+  101ebb:	6a 45                	push   $0x45
+  jmp __alltraps
+  101ebd:	e9 0a 08 00 00       	jmp    1026cc <__alltraps>
+
+00101ec2 <vector70>:
+.globl vector70
+vector70:
+  pushl $0
+  101ec2:	6a 00                	push   $0x0
+  pushl $70
+  101ec4:	6a 46                	push   $0x46
+  jmp __alltraps
+  101ec6:	e9 01 08 00 00       	jmp    1026cc <__alltraps>
+
+00101ecb <vector71>:
+.globl vector71
+vector71:
+  pushl $0
+  101ecb:	6a 00                	push   $0x0
+  pushl $71
+  101ecd:	6a 47                	push   $0x47
+  jmp __alltraps
+  101ecf:	e9 f8 07 00 00       	jmp    1026cc <__alltraps>
+
+00101ed4 <vector72>:
+.globl vector72
+vector72:
+  pushl $0
+  101ed4:	6a 00                	push   $0x0
+  pushl $72
+  101ed6:	6a 48                	push   $0x48
+  jmp __alltraps
+  101ed8:	e9 ef 07 00 00       	jmp    1026cc <__alltraps>
+
+00101edd <vector73>:
+.globl vector73
+vector73:
+  pushl $0
+  101edd:	6a 00                	push   $0x0
+  pushl $73
+  101edf:	6a 49                	push   $0x49
+  jmp __alltraps
+  101ee1:	e9 e6 07 00 00       	jmp    1026cc <__alltraps>
+
+00101ee6 <vector74>:
+.globl vector74
+vector74:
+  pushl $0
+  101ee6:	6a 00                	push   $0x0
+  pushl $74
+  101ee8:	6a 4a                	push   $0x4a
+  jmp __alltraps
+  101eea:	e9 dd 07 00 00       	jmp    1026cc <__alltraps>
+
+00101eef <vector75>:
+.globl vector75
+vector75:
+  pushl $0
+  101eef:	6a 00                	push   $0x0
+  pushl $75
+  101ef1:	6a 4b                	push   $0x4b
+  jmp __alltraps
+  101ef3:	e9 d4 07 00 00       	jmp    1026cc <__alltraps>
+
+00101ef8 <vector76>:
+.globl vector76
+vector76:
+  pushl $0
+  101ef8:	6a 00                	push   $0x0
+  pushl $76
+  101efa:	6a 4c                	push   $0x4c
+  jmp __alltraps
+  101efc:	e9 cb 07 00 00       	jmp    1026cc <__alltraps>
+
+00101f01 <vector77>:
+.globl vector77
+vector77:
+  pushl $0
+  101f01:	6a 00                	push   $0x0
+  pushl $77
+  101f03:	6a 4d                	push   $0x4d
+  jmp __alltraps
+  101f05:	e9 c2 07 00 00       	jmp    1026cc <__alltraps>
+
+00101f0a <vector78>:
+.globl vector78
+vector78:
+  pushl $0
+  101f0a:	6a 00                	push   $0x0
+  pushl $78
+  101f0c:	6a 4e                	push   $0x4e
+  jmp __alltraps
+  101f0e:	e9 b9 07 00 00       	jmp    1026cc <__alltraps>
+
+00101f13 <vector79>:
+.globl vector79
+vector79:
+  pushl $0
+  101f13:	6a 00                	push   $0x0
+  pushl $79
+  101f15:	6a 4f                	push   $0x4f
+  jmp __alltraps
+  101f17:	e9 b0 07 00 00       	jmp    1026cc <__alltraps>
+
+00101f1c <vector80>:
+.globl vector80
+vector80:
+  pushl $0
+  101f1c:	6a 00                	push   $0x0
+  pushl $80
+  101f1e:	6a 50                	push   $0x50
+  jmp __alltraps
+  101f20:	e9 a7 07 00 00       	jmp    1026cc <__alltraps>
+
+00101f25 <vector81>:
+.globl vector81
+vector81:
+  pushl $0
+  101f25:	6a 00                	push   $0x0
+  pushl $81
+  101f27:	6a 51                	push   $0x51
+  jmp __alltraps
+  101f29:	e9 9e 07 00 00       	jmp    1026cc <__alltraps>
+
+00101f2e <vector82>:
+.globl vector82
+vector82:
+  pushl $0
+  101f2e:	6a 00                	push   $0x0
+  pushl $82
+  101f30:	6a 52                	push   $0x52
+  jmp __alltraps
+  101f32:	e9 95 07 00 00       	jmp    1026cc <__alltraps>
+
+00101f37 <vector83>:
+.globl vector83
+vector83:
+  pushl $0
+  101f37:	6a 00                	push   $0x0
+  pushl $83
+  101f39:	6a 53                	push   $0x53
+  jmp __alltraps
+  101f3b:	e9 8c 07 00 00       	jmp    1026cc <__alltraps>
+
+00101f40 <vector84>:
+.globl vector84
+vector84:
+  pushl $0
+  101f40:	6a 00                	push   $0x0
+  pushl $84
+  101f42:	6a 54                	push   $0x54
+  jmp __alltraps
+  101f44:	e9 83 07 00 00       	jmp    1026cc <__alltraps>
+
+00101f49 <vector85>:
+.globl vector85
+vector85:
+  pushl $0
+  101f49:	6a 00                	push   $0x0
+  pushl $85
+  101f4b:	6a 55                	push   $0x55
+  jmp __alltraps
+  101f4d:	e9 7a 07 00 00       	jmp    1026cc <__alltraps>
+
+00101f52 <vector86>:
+.globl vector86
+vector86:
+  pushl $0
+  101f52:	6a 00                	push   $0x0
+  pushl $86
+  101f54:	6a 56                	push   $0x56
+  jmp __alltraps
+  101f56:	e9 71 07 00 00       	jmp    1026cc <__alltraps>
+
+00101f5b <vector87>:
+.globl vector87
+vector87:
+  pushl $0
+  101f5b:	6a 00                	push   $0x0
+  pushl $87
+  101f5d:	6a 57                	push   $0x57
+  jmp __alltraps
+  101f5f:	e9 68 07 00 00       	jmp    1026cc <__alltraps>
+
+00101f64 <vector88>:
+.globl vector88
+vector88:
+  pushl $0
+  101f64:	6a 00                	push   $0x0
+  pushl $88
+  101f66:	6a 58                	push   $0x58
+  jmp __alltraps
+  101f68:	e9 5f 07 00 00       	jmp    1026cc <__alltraps>
+
+00101f6d <vector89>:
+.globl vector89
+vector89:
+  pushl $0
+  101f6d:	6a 00                	push   $0x0
+  pushl $89
+  101f6f:	6a 59                	push   $0x59
+  jmp __alltraps
+  101f71:	e9 56 07 00 00       	jmp    1026cc <__alltraps>
+
+00101f76 <vector90>:
+.globl vector90
+vector90:
+  pushl $0
+  101f76:	6a 00                	push   $0x0
+  pushl $90
+  101f78:	6a 5a                	push   $0x5a
+  jmp __alltraps
+  101f7a:	e9 4d 07 00 00       	jmp    1026cc <__alltraps>
+
+00101f7f <vector91>:
+.globl vector91
+vector91:
+  pushl $0
+  101f7f:	6a 00                	push   $0x0
+  pushl $91
+  101f81:	6a 5b                	push   $0x5b
+  jmp __alltraps
+  101f83:	e9 44 07 00 00       	jmp    1026cc <__alltraps>
+
+00101f88 <vector92>:
+.globl vector92
+vector92:
+  pushl $0
+  101f88:	6a 00                	push   $0x0
+  pushl $92
+  101f8a:	6a 5c                	push   $0x5c
+  jmp __alltraps
+  101f8c:	e9 3b 07 00 00       	jmp    1026cc <__alltraps>
+
+00101f91 <vector93>:
+.globl vector93
+vector93:
+  pushl $0
+  101f91:	6a 00                	push   $0x0
+  pushl $93
+  101f93:	6a 5d                	push   $0x5d
+  jmp __alltraps
+  101f95:	e9 32 07 00 00       	jmp    1026cc <__alltraps>
+
+00101f9a <vector94>:
+.globl vector94
+vector94:
+  pushl $0
+  101f9a:	6a 00                	push   $0x0
+  pushl $94
+  101f9c:	6a 5e                	push   $0x5e
+  jmp __alltraps
+  101f9e:	e9 29 07 00 00       	jmp    1026cc <__alltraps>
+
+00101fa3 <vector95>:
+.globl vector95
+vector95:
+  pushl $0
+  101fa3:	6a 00                	push   $0x0
+  pushl $95
+  101fa5:	6a 5f                	push   $0x5f
+  jmp __alltraps
+  101fa7:	e9 20 07 00 00       	jmp    1026cc <__alltraps>
+
+00101fac <vector96>:
+.globl vector96
+vector96:
+  pushl $0
+  101fac:	6a 00                	push   $0x0
+  pushl $96
+  101fae:	6a 60                	push   $0x60
+  jmp __alltraps
+  101fb0:	e9 17 07 00 00       	jmp    1026cc <__alltraps>
+
+00101fb5 <vector97>:
+.globl vector97
+vector97:
+  pushl $0
+  101fb5:	6a 00                	push   $0x0
+  pushl $97
+  101fb7:	6a 61                	push   $0x61
+  jmp __alltraps
+  101fb9:	e9 0e 07 00 00       	jmp    1026cc <__alltraps>
+
+00101fbe <vector98>:
+.globl vector98
+vector98:
+  pushl $0
+  101fbe:	6a 00                	push   $0x0
+  pushl $98
+  101fc0:	6a 62                	push   $0x62
+  jmp __alltraps
+  101fc2:	e9 05 07 00 00       	jmp    1026cc <__alltraps>
+
+00101fc7 <vector99>:
+.globl vector99
+vector99:
+  pushl $0
+  101fc7:	6a 00                	push   $0x0
+  pushl $99
+  101fc9:	6a 63                	push   $0x63
+  jmp __alltraps
+  101fcb:	e9 fc 06 00 00       	jmp    1026cc <__alltraps>
+
+00101fd0 <vector100>:
+.globl vector100
+vector100:
+  pushl $0
+  101fd0:	6a 00                	push   $0x0
+  pushl $100
+  101fd2:	6a 64                	push   $0x64
+  jmp __alltraps
+  101fd4:	e9 f3 06 00 00       	jmp    1026cc <__alltraps>
+
+00101fd9 <vector101>:
+.globl vector101
+vector101:
+  pushl $0
+  101fd9:	6a 00                	push   $0x0
+  pushl $101
+  101fdb:	6a 65                	push   $0x65
+  jmp __alltraps
+  101fdd:	e9 ea 06 00 00       	jmp    1026cc <__alltraps>
+
+00101fe2 <vector102>:
+.globl vector102
+vector102:
+  pushl $0
+  101fe2:	6a 00                	push   $0x0
+  pushl $102
+  101fe4:	6a 66                	push   $0x66
+  jmp __alltraps
+  101fe6:	e9 e1 06 00 00       	jmp    1026cc <__alltraps>
+
+00101feb <vector103>:
+.globl vector103
+vector103:
+  pushl $0
+  101feb:	6a 00                	push   $0x0
+  pushl $103
+  101fed:	6a 67                	push   $0x67
+  jmp __alltraps
+  101fef:	e9 d8 06 00 00       	jmp    1026cc <__alltraps>
+
+00101ff4 <vector104>:
+.globl vector104
+vector104:
+  pushl $0
+  101ff4:	6a 00                	push   $0x0
+  pushl $104
+  101ff6:	6a 68                	push   $0x68
+  jmp __alltraps
+  101ff8:	e9 cf 06 00 00       	jmp    1026cc <__alltraps>
+
+00101ffd <vector105>:
+.globl vector105
+vector105:
+  pushl $0
+  101ffd:	6a 00                	push   $0x0
+  pushl $105
+  101fff:	6a 69                	push   $0x69
+  jmp __alltraps
+  102001:	e9 c6 06 00 00       	jmp    1026cc <__alltraps>
+
+00102006 <vector106>:
+.globl vector106
+vector106:
+  pushl $0
+  102006:	6a 00                	push   $0x0
+  pushl $106
+  102008:	6a 6a                	push   $0x6a
+  jmp __alltraps
+  10200a:	e9 bd 06 00 00       	jmp    1026cc <__alltraps>
+
+0010200f <vector107>:
+.globl vector107
+vector107:
+  pushl $0
+  10200f:	6a 00                	push   $0x0
+  pushl $107
+  102011:	6a 6b                	push   $0x6b
+  jmp __alltraps
+  102013:	e9 b4 06 00 00       	jmp    1026cc <__alltraps>
+
+00102018 <vector108>:
+.globl vector108
+vector108:
+  pushl $0
+  102018:	6a 00                	push   $0x0
+  pushl $108
+  10201a:	6a 6c                	push   $0x6c
+  jmp __alltraps
+  10201c:	e9 ab 06 00 00       	jmp    1026cc <__alltraps>
+
+00102021 <vector109>:
+.globl vector109
+vector109:
+  pushl $0
+  102021:	6a 00                	push   $0x0
+  pushl $109
+  102023:	6a 6d                	push   $0x6d
+  jmp __alltraps
+  102025:	e9 a2 06 00 00       	jmp    1026cc <__alltraps>
+
+0010202a <vector110>:
+.globl vector110
+vector110:
+  pushl $0
+  10202a:	6a 00                	push   $0x0
+  pushl $110
+  10202c:	6a 6e                	push   $0x6e
+  jmp __alltraps
+  10202e:	e9 99 06 00 00       	jmp    1026cc <__alltraps>
+
+00102033 <vector111>:
+.globl vector111
+vector111:
+  pushl $0
+  102033:	6a 00                	push   $0x0
+  pushl $111
+  102035:	6a 6f                	push   $0x6f
+  jmp __alltraps
+  102037:	e9 90 06 00 00       	jmp    1026cc <__alltraps>
+
+0010203c <vector112>:
+.globl vector112
+vector112:
+  pushl $0
+  10203c:	6a 00                	push   $0x0
+  pushl $112
+  10203e:	6a 70                	push   $0x70
+  jmp __alltraps
+  102040:	e9 87 06 00 00       	jmp    1026cc <__alltraps>
+
+00102045 <vector113>:
+.globl vector113
+vector113:
+  pushl $0
+  102045:	6a 00                	push   $0x0
+  pushl $113
+  102047:	6a 71                	push   $0x71
+  jmp __alltraps
+  102049:	e9 7e 06 00 00       	jmp    1026cc <__alltraps>
+
+0010204e <vector114>:
+.globl vector114
+vector114:
+  pushl $0
+  10204e:	6a 00                	push   $0x0
+  pushl $114
+  102050:	6a 72                	push   $0x72
+  jmp __alltraps
+  102052:	e9 75 06 00 00       	jmp    1026cc <__alltraps>
+
+00102057 <vector115>:
+.globl vector115
+vector115:
+  pushl $0
+  102057:	6a 00                	push   $0x0
+  pushl $115
+  102059:	6a 73                	push   $0x73
+  jmp __alltraps
+  10205b:	e9 6c 06 00 00       	jmp    1026cc <__alltraps>
+
+00102060 <vector116>:
+.globl vector116
+vector116:
+  pushl $0
+  102060:	6a 00                	push   $0x0
+  pushl $116
+  102062:	6a 74                	push   $0x74
+  jmp __alltraps
+  102064:	e9 63 06 00 00       	jmp    1026cc <__alltraps>
+
+00102069 <vector117>:
+.globl vector117
+vector117:
+  pushl $0
+  102069:	6a 00                	push   $0x0
+  pushl $117
+  10206b:	6a 75                	push   $0x75
+  jmp __alltraps
+  10206d:	e9 5a 06 00 00       	jmp    1026cc <__alltraps>
+
+00102072 <vector118>:
+.globl vector118
+vector118:
+  pushl $0
+  102072:	6a 00                	push   $0x0
+  pushl $118
+  102074:	6a 76                	push   $0x76
+  jmp __alltraps
+  102076:	e9 51 06 00 00       	jmp    1026cc <__alltraps>
+
+0010207b <vector119>:
+.globl vector119
+vector119:
+  pushl $0
+  10207b:	6a 00                	push   $0x0
+  pushl $119
+  10207d:	6a 77                	push   $0x77
+  jmp __alltraps
+  10207f:	e9 48 06 00 00       	jmp    1026cc <__alltraps>
+
+00102084 <vector120>:
+.globl vector120
+vector120:
+  pushl $0
+  102084:	6a 00                	push   $0x0
+  pushl $120
+  102086:	6a 78                	push   $0x78
+  jmp __alltraps
+  102088:	e9 3f 06 00 00       	jmp    1026cc <__alltraps>
+
+0010208d <vector121>:
+.globl vector121
+vector121:
+  pushl $0
+  10208d:	6a 00                	push   $0x0
+  pushl $121
+  10208f:	6a 79                	push   $0x79
+  jmp __alltraps
+  102091:	e9 36 06 00 00       	jmp    1026cc <__alltraps>
+
+00102096 <vector122>:
+.globl vector122
+vector122:
+  pushl $0
+  102096:	6a 00                	push   $0x0
+  pushl $122
+  102098:	6a 7a                	push   $0x7a
+  jmp __alltraps
+  10209a:	e9 2d 06 00 00       	jmp    1026cc <__alltraps>
+
+0010209f <vector123>:
+.globl vector123
+vector123:
+  pushl $0
+  10209f:	6a 00                	push   $0x0
+  pushl $123
+  1020a1:	6a 7b                	push   $0x7b
+  jmp __alltraps
+  1020a3:	e9 24 06 00 00       	jmp    1026cc <__alltraps>
+
+001020a8 <vector124>:
+.globl vector124
+vector124:
+  pushl $0
+  1020a8:	6a 00                	push   $0x0
+  pushl $124
+  1020aa:	6a 7c                	push   $0x7c
+  jmp __alltraps
+  1020ac:	e9 1b 06 00 00       	jmp    1026cc <__alltraps>
+
+001020b1 <vector125>:
+.globl vector125
+vector125:
+  pushl $0
+  1020b1:	6a 00                	push   $0x0
+  pushl $125
+  1020b3:	6a 7d                	push   $0x7d
+  jmp __alltraps
+  1020b5:	e9 12 06 00 00       	jmp    1026cc <__alltraps>
+
+001020ba <vector126>:
+.globl vector126
+vector126:
+  pushl $0
+  1020ba:	6a 00                	push   $0x0
+  pushl $126
+  1020bc:	6a 7e                	push   $0x7e
+  jmp __alltraps
+  1020be:	e9 09 06 00 00       	jmp    1026cc <__alltraps>
+
+001020c3 <vector127>:
+.globl vector127
+vector127:
+  pushl $0
+  1020c3:	6a 00                	push   $0x0
+  pushl $127
+  1020c5:	6a 7f                	push   $0x7f
+  jmp __alltraps
+  1020c7:	e9 00 06 00 00       	jmp    1026cc <__alltraps>
+
+001020cc <vector128>:
+.globl vector128
+vector128:
+  pushl $0
+  1020cc:	6a 00                	push   $0x0
+  pushl $128
+  1020ce:	68 80 00 00 00       	push   $0x80
+  jmp __alltraps
+  1020d3:	e9 f4 05 00 00       	jmp    1026cc <__alltraps>
+
+001020d8 <vector129>:
+.globl vector129
+vector129:
+  pushl $0
+  1020d8:	6a 00                	push   $0x0
+  pushl $129
+  1020da:	68 81 00 00 00       	push   $0x81
+  jmp __alltraps
+  1020df:	e9 e8 05 00 00       	jmp    1026cc <__alltraps>
+
+001020e4 <vector130>:
+.globl vector130
+vector130:
+  pushl $0
+  1020e4:	6a 00                	push   $0x0
+  pushl $130
+  1020e6:	68 82 00 00 00       	push   $0x82
+  jmp __alltraps
+  1020eb:	e9 dc 05 00 00       	jmp    1026cc <__alltraps>
+
+001020f0 <vector131>:
+.globl vector131
+vector131:
+  pushl $0
+  1020f0:	6a 00                	push   $0x0
+  pushl $131
+  1020f2:	68 83 00 00 00       	push   $0x83
+  jmp __alltraps
+  1020f7:	e9 d0 05 00 00       	jmp    1026cc <__alltraps>
+
+001020fc <vector132>:
+.globl vector132
+vector132:
+  pushl $0
+  1020fc:	6a 00                	push   $0x0
+  pushl $132
+  1020fe:	68 84 00 00 00       	push   $0x84
+  jmp __alltraps
+  102103:	e9 c4 05 00 00       	jmp    1026cc <__alltraps>
+
+00102108 <vector133>:
+.globl vector133
+vector133:
+  pushl $0
+  102108:	6a 00                	push   $0x0
+  pushl $133
+  10210a:	68 85 00 00 00       	push   $0x85
+  jmp __alltraps
+  10210f:	e9 b8 05 00 00       	jmp    1026cc <__alltraps>
+
+00102114 <vector134>:
+.globl vector134
+vector134:
+  pushl $0
+  102114:	6a 00                	push   $0x0
+  pushl $134
+  102116:	68 86 00 00 00       	push   $0x86
+  jmp __alltraps
+  10211b:	e9 ac 05 00 00       	jmp    1026cc <__alltraps>
+
+00102120 <vector135>:
+.globl vector135
+vector135:
+  pushl $0
+  102120:	6a 00                	push   $0x0
+  pushl $135
+  102122:	68 87 00 00 00       	push   $0x87
+  jmp __alltraps
+  102127:	e9 a0 05 00 00       	jmp    1026cc <__alltraps>
+
+0010212c <vector136>:
+.globl vector136
+vector136:
+  pushl $0
+  10212c:	6a 00                	push   $0x0
+  pushl $136
+  10212e:	68 88 00 00 00       	push   $0x88
+  jmp __alltraps
+  102133:	e9 94 05 00 00       	jmp    1026cc <__alltraps>
+
+00102138 <vector137>:
+.globl vector137
+vector137:
+  pushl $0
+  102138:	6a 00                	push   $0x0
+  pushl $137
+  10213a:	68 89 00 00 00       	push   $0x89
+  jmp __alltraps
+  10213f:	e9 88 05 00 00       	jmp    1026cc <__alltraps>
+
+00102144 <vector138>:
+.globl vector138
+vector138:
+  pushl $0
+  102144:	6a 00                	push   $0x0
+  pushl $138
+  102146:	68 8a 00 00 00       	push   $0x8a
+  jmp __alltraps
+  10214b:	e9 7c 05 00 00       	jmp    1026cc <__alltraps>
+
+00102150 <vector139>:
+.globl vector139
+vector139:
+  pushl $0
+  102150:	6a 00                	push   $0x0
+  pushl $139
+  102152:	68 8b 00 00 00       	push   $0x8b
+  jmp __alltraps
+  102157:	e9 70 05 00 00       	jmp    1026cc <__alltraps>
+
+0010215c <vector140>:
+.globl vector140
+vector140:
+  pushl $0
+  10215c:	6a 00                	push   $0x0
+  pushl $140
+  10215e:	68 8c 00 00 00       	push   $0x8c
+  jmp __alltraps
+  102163:	e9 64 05 00 00       	jmp    1026cc <__alltraps>
+
+00102168 <vector141>:
+.globl vector141
+vector141:
+  pushl $0
+  102168:	6a 00                	push   $0x0
+  pushl $141
+  10216a:	68 8d 00 00 00       	push   $0x8d
+  jmp __alltraps
+  10216f:	e9 58 05 00 00       	jmp    1026cc <__alltraps>
+
+00102174 <vector142>:
+.globl vector142
+vector142:
+  pushl $0
+  102174:	6a 00                	push   $0x0
+  pushl $142
+  102176:	68 8e 00 00 00       	push   $0x8e
+  jmp __alltraps
+  10217b:	e9 4c 05 00 00       	jmp    1026cc <__alltraps>
+
+00102180 <vector143>:
+.globl vector143
+vector143:
+  pushl $0
+  102180:	6a 00                	push   $0x0
+  pushl $143
+  102182:	68 8f 00 00 00       	push   $0x8f
+  jmp __alltraps
+  102187:	e9 40 05 00 00       	jmp    1026cc <__alltraps>
+
+0010218c <vector144>:
+.globl vector144
+vector144:
+  pushl $0
+  10218c:	6a 00                	push   $0x0
+  pushl $144
+  10218e:	68 90 00 00 00       	push   $0x90
+  jmp __alltraps
+  102193:	e9 34 05 00 00       	jmp    1026cc <__alltraps>
+
+00102198 <vector145>:
+.globl vector145
+vector145:
+  pushl $0
+  102198:	6a 00                	push   $0x0
+  pushl $145
+  10219a:	68 91 00 00 00       	push   $0x91
+  jmp __alltraps
+  10219f:	e9 28 05 00 00       	jmp    1026cc <__alltraps>
+
+001021a4 <vector146>:
+.globl vector146
+vector146:
+  pushl $0
+  1021a4:	6a 00                	push   $0x0
+  pushl $146
+  1021a6:	68 92 00 00 00       	push   $0x92
+  jmp __alltraps
+  1021ab:	e9 1c 05 00 00       	jmp    1026cc <__alltraps>
+
+001021b0 <vector147>:
+.globl vector147
+vector147:
+  pushl $0
+  1021b0:	6a 00                	push   $0x0
+  pushl $147
+  1021b2:	68 93 00 00 00       	push   $0x93
+  jmp __alltraps
+  1021b7:	e9 10 05 00 00       	jmp    1026cc <__alltraps>
+
+001021bc <vector148>:
+.globl vector148
+vector148:
+  pushl $0
+  1021bc:	6a 00                	push   $0x0
+  pushl $148
+  1021be:	68 94 00 00 00       	push   $0x94
+  jmp __alltraps
+  1021c3:	e9 04 05 00 00       	jmp    1026cc <__alltraps>
+
+001021c8 <vector149>:
+.globl vector149
+vector149:
+  pushl $0
+  1021c8:	6a 00                	push   $0x0
+  pushl $149
+  1021ca:	68 95 00 00 00       	push   $0x95
+  jmp __alltraps
+  1021cf:	e9 f8 04 00 00       	jmp    1026cc <__alltraps>
+
+001021d4 <vector150>:
+.globl vector150
+vector150:
+  pushl $0
+  1021d4:	6a 00                	push   $0x0
+  pushl $150
+  1021d6:	68 96 00 00 00       	push   $0x96
+  jmp __alltraps
+  1021db:	e9 ec 04 00 00       	jmp    1026cc <__alltraps>
+
+001021e0 <vector151>:
+.globl vector151
+vector151:
+  pushl $0
+  1021e0:	6a 00                	push   $0x0
+  pushl $151
+  1021e2:	68 97 00 00 00       	push   $0x97
+  jmp __alltraps
+  1021e7:	e9 e0 04 00 00       	jmp    1026cc <__alltraps>
+
+001021ec <vector152>:
+.globl vector152
+vector152:
+  pushl $0
+  1021ec:	6a 00                	push   $0x0
+  pushl $152
+  1021ee:	68 98 00 00 00       	push   $0x98
+  jmp __alltraps
+  1021f3:	e9 d4 04 00 00       	jmp    1026cc <__alltraps>
+
+001021f8 <vector153>:
+.globl vector153
+vector153:
+  pushl $0
+  1021f8:	6a 00                	push   $0x0
+  pushl $153
+  1021fa:	68 99 00 00 00       	push   $0x99
+  jmp __alltraps
+  1021ff:	e9 c8 04 00 00       	jmp    1026cc <__alltraps>
+
+00102204 <vector154>:
+.globl vector154
+vector154:
+  pushl $0
+  102204:	6a 00                	push   $0x0
+  pushl $154
+  102206:	68 9a 00 00 00       	push   $0x9a
+  jmp __alltraps
+  10220b:	e9 bc 04 00 00       	jmp    1026cc <__alltraps>
+
+00102210 <vector155>:
+.globl vector155
+vector155:
+  pushl $0
+  102210:	6a 00                	push   $0x0
+  pushl $155
+  102212:	68 9b 00 00 00       	push   $0x9b
+  jmp __alltraps
+  102217:	e9 b0 04 00 00       	jmp    1026cc <__alltraps>
+
+0010221c <vector156>:
+.globl vector156
+vector156:
+  pushl $0
+  10221c:	6a 00                	push   $0x0
+  pushl $156
+  10221e:	68 9c 00 00 00       	push   $0x9c
+  jmp __alltraps
+  102223:	e9 a4 04 00 00       	jmp    1026cc <__alltraps>
+
+00102228 <vector157>:
+.globl vector157
+vector157:
+  pushl $0
+  102228:	6a 00                	push   $0x0
+  pushl $157
+  10222a:	68 9d 00 00 00       	push   $0x9d
+  jmp __alltraps
+  10222f:	e9 98 04 00 00       	jmp    1026cc <__alltraps>
+
+00102234 <vector158>:
+.globl vector158
+vector158:
+  pushl $0
+  102234:	6a 00                	push   $0x0
+  pushl $158
+  102236:	68 9e 00 00 00       	push   $0x9e
+  jmp __alltraps
+  10223b:	e9 8c 04 00 00       	jmp    1026cc <__alltraps>
+
+00102240 <vector159>:
+.globl vector159
+vector159:
+  pushl $0
+  102240:	6a 00                	push   $0x0
+  pushl $159
+  102242:	68 9f 00 00 00       	push   $0x9f
+  jmp __alltraps
+  102247:	e9 80 04 00 00       	jmp    1026cc <__alltraps>
+
+0010224c <vector160>:
+.globl vector160
+vector160:
+  pushl $0
+  10224c:	6a 00                	push   $0x0
+  pushl $160
+  10224e:	68 a0 00 00 00       	push   $0xa0
+  jmp __alltraps
+  102253:	e9 74 04 00 00       	jmp    1026cc <__alltraps>
+
+00102258 <vector161>:
+.globl vector161
+vector161:
+  pushl $0
+  102258:	6a 00                	push   $0x0
+  pushl $161
+  10225a:	68 a1 00 00 00       	push   $0xa1
+  jmp __alltraps
+  10225f:	e9 68 04 00 00       	jmp    1026cc <__alltraps>
+
+00102264 <vector162>:
+.globl vector162
+vector162:
+  pushl $0
+  102264:	6a 00                	push   $0x0
+  pushl $162
+  102266:	68 a2 00 00 00       	push   $0xa2
+  jmp __alltraps
+  10226b:	e9 5c 04 00 00       	jmp    1026cc <__alltraps>
+
+00102270 <vector163>:
+.globl vector163
+vector163:
+  pushl $0
+  102270:	6a 00                	push   $0x0
+  pushl $163
+  102272:	68 a3 00 00 00       	push   $0xa3
+  jmp __alltraps
+  102277:	e9 50 04 00 00       	jmp    1026cc <__alltraps>
+
+0010227c <vector164>:
+.globl vector164
+vector164:
+  pushl $0
+  10227c:	6a 00                	push   $0x0
+  pushl $164
+  10227e:	68 a4 00 00 00       	push   $0xa4
+  jmp __alltraps
+  102283:	e9 44 04 00 00       	jmp    1026cc <__alltraps>
+
+00102288 <vector165>:
+.globl vector165
+vector165:
+  pushl $0
+  102288:	6a 00                	push   $0x0
+  pushl $165
+  10228a:	68 a5 00 00 00       	push   $0xa5
+  jmp __alltraps
+  10228f:	e9 38 04 00 00       	jmp    1026cc <__alltraps>
+
+00102294 <vector166>:
+.globl vector166
+vector166:
+  pushl $0
+  102294:	6a 00                	push   $0x0
+  pushl $166
+  102296:	68 a6 00 00 00       	push   $0xa6
+  jmp __alltraps
+  10229b:	e9 2c 04 00 00       	jmp    1026cc <__alltraps>
+
+001022a0 <vector167>:
+.globl vector167
+vector167:
+  pushl $0
+  1022a0:	6a 00                	push   $0x0
+  pushl $167
+  1022a2:	68 a7 00 00 00       	push   $0xa7
+  jmp __alltraps
+  1022a7:	e9 20 04 00 00       	jmp    1026cc <__alltraps>
+
+001022ac <vector168>:
+.globl vector168
+vector168:
+  pushl $0
+  1022ac:	6a 00                	push   $0x0
+  pushl $168
+  1022ae:	68 a8 00 00 00       	push   $0xa8
+  jmp __alltraps
+  1022b3:	e9 14 04 00 00       	jmp    1026cc <__alltraps>
+
+001022b8 <vector169>:
+.globl vector169
+vector169:
+  pushl $0
+  1022b8:	6a 00                	push   $0x0
+  pushl $169
+  1022ba:	68 a9 00 00 00       	push   $0xa9
+  jmp __alltraps
+  1022bf:	e9 08 04 00 00       	jmp    1026cc <__alltraps>
+
+001022c4 <vector170>:
+.globl vector170
+vector170:
+  pushl $0
+  1022c4:	6a 00                	push   $0x0
+  pushl $170
+  1022c6:	68 aa 00 00 00       	push   $0xaa
+  jmp __alltraps
+  1022cb:	e9 fc 03 00 00       	jmp    1026cc <__alltraps>
+
+001022d0 <vector171>:
+.globl vector171
+vector171:
+  pushl $0
+  1022d0:	6a 00                	push   $0x0
+  pushl $171
+  1022d2:	68 ab 00 00 00       	push   $0xab
+  jmp __alltraps
+  1022d7:	e9 f0 03 00 00       	jmp    1026cc <__alltraps>
+
+001022dc <vector172>:
+.globl vector172
+vector172:
+  pushl $0
+  1022dc:	6a 00                	push   $0x0
+  pushl $172
+  1022de:	68 ac 00 00 00       	push   $0xac
+  jmp __alltraps
+  1022e3:	e9 e4 03 00 00       	jmp    1026cc <__alltraps>
+
+001022e8 <vector173>:
+.globl vector173
+vector173:
+  pushl $0
+  1022e8:	6a 00                	push   $0x0
+  pushl $173
+  1022ea:	68 ad 00 00 00       	push   $0xad
+  jmp __alltraps
+  1022ef:	e9 d8 03 00 00       	jmp    1026cc <__alltraps>
+
+001022f4 <vector174>:
+.globl vector174
+vector174:
+  pushl $0
+  1022f4:	6a 00                	push   $0x0
+  pushl $174
+  1022f6:	68 ae 00 00 00       	push   $0xae
+  jmp __alltraps
+  1022fb:	e9 cc 03 00 00       	jmp    1026cc <__alltraps>
+
+00102300 <vector175>:
+.globl vector175
+vector175:
+  pushl $0
+  102300:	6a 00                	push   $0x0
+  pushl $175
+  102302:	68 af 00 00 00       	push   $0xaf
+  jmp __alltraps
+  102307:	e9 c0 03 00 00       	jmp    1026cc <__alltraps>
+
+0010230c <vector176>:
+.globl vector176
+vector176:
+  pushl $0
+  10230c:	6a 00                	push   $0x0
+  pushl $176
+  10230e:	68 b0 00 00 00       	push   $0xb0
+  jmp __alltraps
+  102313:	e9 b4 03 00 00       	jmp    1026cc <__alltraps>
+
+00102318 <vector177>:
+.globl vector177
+vector177:
+  pushl $0
+  102318:	6a 00                	push   $0x0
+  pushl $177
+  10231a:	68 b1 00 00 00       	push   $0xb1
+  jmp __alltraps
+  10231f:	e9 a8 03 00 00       	jmp    1026cc <__alltraps>
+
+00102324 <vector178>:
+.globl vector178
+vector178:
+  pushl $0
+  102324:	6a 00                	push   $0x0
+  pushl $178
+  102326:	68 b2 00 00 00       	push   $0xb2
+  jmp __alltraps
+  10232b:	e9 9c 03 00 00       	jmp    1026cc <__alltraps>
+
+00102330 <vector179>:
+.globl vector179
+vector179:
+  pushl $0
+  102330:	6a 00                	push   $0x0
+  pushl $179
+  102332:	68 b3 00 00 00       	push   $0xb3
+  jmp __alltraps
+  102337:	e9 90 03 00 00       	jmp    1026cc <__alltraps>
+
+0010233c <vector180>:
+.globl vector180
+vector180:
+  pushl $0
+  10233c:	6a 00                	push   $0x0
+  pushl $180
+  10233e:	68 b4 00 00 00       	push   $0xb4
+  jmp __alltraps
+  102343:	e9 84 03 00 00       	jmp    1026cc <__alltraps>
+
+00102348 <vector181>:
+.globl vector181
+vector181:
+  pushl $0
+  102348:	6a 00                	push   $0x0
+  pushl $181
+  10234a:	68 b5 00 00 00       	push   $0xb5
+  jmp __alltraps
+  10234f:	e9 78 03 00 00       	jmp    1026cc <__alltraps>
+
+00102354 <vector182>:
+.globl vector182
+vector182:
+  pushl $0
+  102354:	6a 00                	push   $0x0
+  pushl $182
+  102356:	68 b6 00 00 00       	push   $0xb6
+  jmp __alltraps
+  10235b:	e9 6c 03 00 00       	jmp    1026cc <__alltraps>
+
+00102360 <vector183>:
+.globl vector183
+vector183:
+  pushl $0
+  102360:	6a 00                	push   $0x0
+  pushl $183
+  102362:	68 b7 00 00 00       	push   $0xb7
+  jmp __alltraps
+  102367:	e9 60 03 00 00       	jmp    1026cc <__alltraps>
+
+0010236c <vector184>:
+.globl vector184
+vector184:
+  pushl $0
+  10236c:	6a 00                	push   $0x0
+  pushl $184
+  10236e:	68 b8 00 00 00       	push   $0xb8
+  jmp __alltraps
+  102373:	e9 54 03 00 00       	jmp    1026cc <__alltraps>
+
+00102378 <vector185>:
+.globl vector185
+vector185:
+  pushl $0
+  102378:	6a 00                	push   $0x0
+  pushl $185
+  10237a:	68 b9 00 00 00       	push   $0xb9
+  jmp __alltraps
+  10237f:	e9 48 03 00 00       	jmp    1026cc <__alltraps>
+
+00102384 <vector186>:
+.globl vector186
+vector186:
+  pushl $0
+  102384:	6a 00                	push   $0x0
+  pushl $186
+  102386:	68 ba 00 00 00       	push   $0xba
+  jmp __alltraps
+  10238b:	e9 3c 03 00 00       	jmp    1026cc <__alltraps>
+
+00102390 <vector187>:
+.globl vector187
+vector187:
+  pushl $0
+  102390:	6a 00                	push   $0x0
+  pushl $187
+  102392:	68 bb 00 00 00       	push   $0xbb
+  jmp __alltraps
+  102397:	e9 30 03 00 00       	jmp    1026cc <__alltraps>
+
+0010239c <vector188>:
+.globl vector188
+vector188:
+  pushl $0
+  10239c:	6a 00                	push   $0x0
+  pushl $188
+  10239e:	68 bc 00 00 00       	push   $0xbc
+  jmp __alltraps
+  1023a3:	e9 24 03 00 00       	jmp    1026cc <__alltraps>
+
+001023a8 <vector189>:
+.globl vector189
+vector189:
+  pushl $0
+  1023a8:	6a 00                	push   $0x0
+  pushl $189
+  1023aa:	68 bd 00 00 00       	push   $0xbd
+  jmp __alltraps
+  1023af:	e9 18 03 00 00       	jmp    1026cc <__alltraps>
+
+001023b4 <vector190>:
+.globl vector190
+vector190:
+  pushl $0
+  1023b4:	6a 00                	push   $0x0
+  pushl $190
+  1023b6:	68 be 00 00 00       	push   $0xbe
+  jmp __alltraps
+  1023bb:	e9 0c 03 00 00       	jmp    1026cc <__alltraps>
+
+001023c0 <vector191>:
+.globl vector191
+vector191:
+  pushl $0
+  1023c0:	6a 00                	push   $0x0
+  pushl $191
+  1023c2:	68 bf 00 00 00       	push   $0xbf
+  jmp __alltraps
+  1023c7:	e9 00 03 00 00       	jmp    1026cc <__alltraps>
+
+001023cc <vector192>:
+.globl vector192
+vector192:
+  pushl $0
+  1023cc:	6a 00                	push   $0x0
+  pushl $192
+  1023ce:	68 c0 00 00 00       	push   $0xc0
+  jmp __alltraps
+  1023d3:	e9 f4 02 00 00       	jmp    1026cc <__alltraps>
+
+001023d8 <vector193>:
+.globl vector193
+vector193:
+  pushl $0
+  1023d8:	6a 00                	push   $0x0
+  pushl $193
+  1023da:	68 c1 00 00 00       	push   $0xc1
+  jmp __alltraps
+  1023df:	e9 e8 02 00 00       	jmp    1026cc <__alltraps>
+
+001023e4 <vector194>:
+.globl vector194
+vector194:
+  pushl $0
+  1023e4:	6a 00                	push   $0x0
+  pushl $194
+  1023e6:	68 c2 00 00 00       	push   $0xc2
+  jmp __alltraps
+  1023eb:	e9 dc 02 00 00       	jmp    1026cc <__alltraps>
+
+001023f0 <vector195>:
+.globl vector195
+vector195:
+  pushl $0
+  1023f0:	6a 00                	push   $0x0
+  pushl $195
+  1023f2:	68 c3 00 00 00       	push   $0xc3
+  jmp __alltraps
+  1023f7:	e9 d0 02 00 00       	jmp    1026cc <__alltraps>
+
+001023fc <vector196>:
+.globl vector196
+vector196:
+  pushl $0
+  1023fc:	6a 00                	push   $0x0
+  pushl $196
+  1023fe:	68 c4 00 00 00       	push   $0xc4
+  jmp __alltraps
+  102403:	e9 c4 02 00 00       	jmp    1026cc <__alltraps>
+
+00102408 <vector197>:
+.globl vector197
+vector197:
+  pushl $0
+  102408:	6a 00                	push   $0x0
+  pushl $197
+  10240a:	68 c5 00 00 00       	push   $0xc5
+  jmp __alltraps
+  10240f:	e9 b8 02 00 00       	jmp    1026cc <__alltraps>
+
+00102414 <vector198>:
+.globl vector198
+vector198:
+  pushl $0
+  102414:	6a 00                	push   $0x0
+  pushl $198
+  102416:	68 c6 00 00 00       	push   $0xc6
+  jmp __alltraps
+  10241b:	e9 ac 02 00 00       	jmp    1026cc <__alltraps>
+
+00102420 <vector199>:
+.globl vector199
+vector199:
+  pushl $0
+  102420:	6a 00                	push   $0x0
+  pushl $199
+  102422:	68 c7 00 00 00       	push   $0xc7
+  jmp __alltraps
+  102427:	e9 a0 02 00 00       	jmp    1026cc <__alltraps>
+
+0010242c <vector200>:
+.globl vector200
+vector200:
+  pushl $0
+  10242c:	6a 00                	push   $0x0
+  pushl $200
+  10242e:	68 c8 00 00 00       	push   $0xc8
+  jmp __alltraps
+  102433:	e9 94 02 00 00       	jmp    1026cc <__alltraps>
+
+00102438 <vector201>:
+.globl vector201
+vector201:
+  pushl $0
+  102438:	6a 00                	push   $0x0
+  pushl $201
+  10243a:	68 c9 00 00 00       	push   $0xc9
+  jmp __alltraps
+  10243f:	e9 88 02 00 00       	jmp    1026cc <__alltraps>
+
+00102444 <vector202>:
+.globl vector202
+vector202:
+  pushl $0
+  102444:	6a 00                	push   $0x0
+  pushl $202
+  102446:	68 ca 00 00 00       	push   $0xca
+  jmp __alltraps
+  10244b:	e9 7c 02 00 00       	jmp    1026cc <__alltraps>
+
+00102450 <vector203>:
+.globl vector203
+vector203:
+  pushl $0
+  102450:	6a 00                	push   $0x0
+  pushl $203
+  102452:	68 cb 00 00 00       	push   $0xcb
+  jmp __alltraps
+  102457:	e9 70 02 00 00       	jmp    1026cc <__alltraps>
+
+0010245c <vector204>:
+.globl vector204
+vector204:
+  pushl $0
+  10245c:	6a 00                	push   $0x0
+  pushl $204
+  10245e:	68 cc 00 00 00       	push   $0xcc
+  jmp __alltraps
+  102463:	e9 64 02 00 00       	jmp    1026cc <__alltraps>
+
+00102468 <vector205>:
+.globl vector205
+vector205:
+  pushl $0
+  102468:	6a 00                	push   $0x0
+  pushl $205
+  10246a:	68 cd 00 00 00       	push   $0xcd
+  jmp __alltraps
+  10246f:	e9 58 02 00 00       	jmp    1026cc <__alltraps>
+
+00102474 <vector206>:
+.globl vector206
+vector206:
+  pushl $0
+  102474:	6a 00                	push   $0x0
+  pushl $206
+  102476:	68 ce 00 00 00       	push   $0xce
+  jmp __alltraps
+  10247b:	e9 4c 02 00 00       	jmp    1026cc <__alltraps>
+
+00102480 <vector207>:
+.globl vector207
+vector207:
+  pushl $0
+  102480:	6a 00                	push   $0x0
+  pushl $207
+  102482:	68 cf 00 00 00       	push   $0xcf
+  jmp __alltraps
+  102487:	e9 40 02 00 00       	jmp    1026cc <__alltraps>
+
+0010248c <vector208>:
+.globl vector208
+vector208:
+  pushl $0
+  10248c:	6a 00                	push   $0x0
+  pushl $208
+  10248e:	68 d0 00 00 00       	push   $0xd0
+  jmp __alltraps
+  102493:	e9 34 02 00 00       	jmp    1026cc <__alltraps>
+
+00102498 <vector209>:
+.globl vector209
+vector209:
+  pushl $0
+  102498:	6a 00                	push   $0x0
+  pushl $209
+  10249a:	68 d1 00 00 00       	push   $0xd1
+  jmp __alltraps
+  10249f:	e9 28 02 00 00       	jmp    1026cc <__alltraps>
+
+001024a4 <vector210>:
+.globl vector210
+vector210:
+  pushl $0
+  1024a4:	6a 00                	push   $0x0
+  pushl $210
+  1024a6:	68 d2 00 00 00       	push   $0xd2
+  jmp __alltraps
+  1024ab:	e9 1c 02 00 00       	jmp    1026cc <__alltraps>
+
+001024b0 <vector211>:
+.globl vector211
+vector211:
+  pushl $0
+  1024b0:	6a 00                	push   $0x0
+  pushl $211
+  1024b2:	68 d3 00 00 00       	push   $0xd3
+  jmp __alltraps
+  1024b7:	e9 10 02 00 00       	jmp    1026cc <__alltraps>
+
+001024bc <vector212>:
+.globl vector212
+vector212:
+  pushl $0
+  1024bc:	6a 00                	push   $0x0
+  pushl $212
+  1024be:	68 d4 00 00 00       	push   $0xd4
+  jmp __alltraps
+  1024c3:	e9 04 02 00 00       	jmp    1026cc <__alltraps>
+
+001024c8 <vector213>:
+.globl vector213
+vector213:
+  pushl $0
+  1024c8:	6a 00                	push   $0x0
+  pushl $213
+  1024ca:	68 d5 00 00 00       	push   $0xd5
+  jmp __alltraps
+  1024cf:	e9 f8 01 00 00       	jmp    1026cc <__alltraps>
+
+001024d4 <vector214>:
+.globl vector214
+vector214:
+  pushl $0
+  1024d4:	6a 00                	push   $0x0
+  pushl $214
+  1024d6:	68 d6 00 00 00       	push   $0xd6
+  jmp __alltraps
+  1024db:	e9 ec 01 00 00       	jmp    1026cc <__alltraps>
+
+001024e0 <vector215>:
+.globl vector215
+vector215:
+  pushl $0
+  1024e0:	6a 00                	push   $0x0
+  pushl $215
+  1024e2:	68 d7 00 00 00       	push   $0xd7
+  jmp __alltraps
+  1024e7:	e9 e0 01 00 00       	jmp    1026cc <__alltraps>
+
+001024ec <vector216>:
+.globl vector216
+vector216:
+  pushl $0
+  1024ec:	6a 00                	push   $0x0
+  pushl $216
+  1024ee:	68 d8 00 00 00       	push   $0xd8
+  jmp __alltraps
+  1024f3:	e9 d4 01 00 00       	jmp    1026cc <__alltraps>
+
+001024f8 <vector217>:
+.globl vector217
+vector217:
+  pushl $0
+  1024f8:	6a 00                	push   $0x0
+  pushl $217
+  1024fa:	68 d9 00 00 00       	push   $0xd9
+  jmp __alltraps
+  1024ff:	e9 c8 01 00 00       	jmp    1026cc <__alltraps>
+
+00102504 <vector218>:
+.globl vector218
+vector218:
+  pushl $0
+  102504:	6a 00                	push   $0x0
+  pushl $218
+  102506:	68 da 00 00 00       	push   $0xda
+  jmp __alltraps
+  10250b:	e9 bc 01 00 00       	jmp    1026cc <__alltraps>
+
+00102510 <vector219>:
+.globl vector219
+vector219:
+  pushl $0
+  102510:	6a 00                	push   $0x0
+  pushl $219
+  102512:	68 db 00 00 00       	push   $0xdb
+  jmp __alltraps
+  102517:	e9 b0 01 00 00       	jmp    1026cc <__alltraps>
+
+0010251c <vector220>:
+.globl vector220
+vector220:
+  pushl $0
+  10251c:	6a 00                	push   $0x0
+  pushl $220
+  10251e:	68 dc 00 00 00       	push   $0xdc
+  jmp __alltraps
+  102523:	e9 a4 01 00 00       	jmp    1026cc <__alltraps>
+
+00102528 <vector221>:
+.globl vector221
+vector221:
+  pushl $0
+  102528:	6a 00                	push   $0x0
+  pushl $221
+  10252a:	68 dd 00 00 00       	push   $0xdd
+  jmp __alltraps
+  10252f:	e9 98 01 00 00       	jmp    1026cc <__alltraps>
+
+00102534 <vector222>:
+.globl vector222
+vector222:
+  pushl $0
+  102534:	6a 00                	push   $0x0
+  pushl $222
+  102536:	68 de 00 00 00       	push   $0xde
+  jmp __alltraps
+  10253b:	e9 8c 01 00 00       	jmp    1026cc <__alltraps>
+
+00102540 <vector223>:
+.globl vector223
+vector223:
+  pushl $0
+  102540:	6a 00                	push   $0x0
+  pushl $223
+  102542:	68 df 00 00 00       	push   $0xdf
+  jmp __alltraps
+  102547:	e9 80 01 00 00       	jmp    1026cc <__alltraps>
+
+0010254c <vector224>:
+.globl vector224
+vector224:
+  pushl $0
+  10254c:	6a 00                	push   $0x0
+  pushl $224
+  10254e:	68 e0 00 00 00       	push   $0xe0
+  jmp __alltraps
+  102553:	e9 74 01 00 00       	jmp    1026cc <__alltraps>
+
+00102558 <vector225>:
+.globl vector225
+vector225:
+  pushl $0
+  102558:	6a 00                	push   $0x0
+  pushl $225
+  10255a:	68 e1 00 00 00       	push   $0xe1
+  jmp __alltraps
+  10255f:	e9 68 01 00 00       	jmp    1026cc <__alltraps>
+
+00102564 <vector226>:
+.globl vector226
+vector226:
+  pushl $0
+  102564:	6a 00                	push   $0x0
+  pushl $226
+  102566:	68 e2 00 00 00       	push   $0xe2
+  jmp __alltraps
+  10256b:	e9 5c 01 00 00       	jmp    1026cc <__alltraps>
+
+00102570 <vector227>:
+.globl vector227
+vector227:
+  pushl $0
+  102570:	6a 00                	push   $0x0
+  pushl $227
+  102572:	68 e3 00 00 00       	push   $0xe3
+  jmp __alltraps
+  102577:	e9 50 01 00 00       	jmp    1026cc <__alltraps>
+
+0010257c <vector228>:
+.globl vector228
+vector228:
+  pushl $0
+  10257c:	6a 00                	push   $0x0
+  pushl $228
+  10257e:	68 e4 00 00 00       	push   $0xe4
+  jmp __alltraps
+  102583:	e9 44 01 00 00       	jmp    1026cc <__alltraps>
+
+00102588 <vector229>:
+.globl vector229
+vector229:
+  pushl $0
+  102588:	6a 00                	push   $0x0
+  pushl $229
+  10258a:	68 e5 00 00 00       	push   $0xe5
+  jmp __alltraps
+  10258f:	e9 38 01 00 00       	jmp    1026cc <__alltraps>
+
+00102594 <vector230>:
+.globl vector230
+vector230:
+  pushl $0
+  102594:	6a 00                	push   $0x0
+  pushl $230
+  102596:	68 e6 00 00 00       	push   $0xe6
+  jmp __alltraps
+  10259b:	e9 2c 01 00 00       	jmp    1026cc <__alltraps>
+
+001025a0 <vector231>:
+.globl vector231
+vector231:
+  pushl $0
+  1025a0:	6a 00                	push   $0x0
+  pushl $231
+  1025a2:	68 e7 00 00 00       	push   $0xe7
+  jmp __alltraps
+  1025a7:	e9 20 01 00 00       	jmp    1026cc <__alltraps>
+
+001025ac <vector232>:
+.globl vector232
+vector232:
+  pushl $0
+  1025ac:	6a 00                	push   $0x0
+  pushl $232
+  1025ae:	68 e8 00 00 00       	push   $0xe8
+  jmp __alltraps
+  1025b3:	e9 14 01 00 00       	jmp    1026cc <__alltraps>
+
+001025b8 <vector233>:
+.globl vector233
+vector233:
+  pushl $0
+  1025b8:	6a 00                	push   $0x0
+  pushl $233
+  1025ba:	68 e9 00 00 00       	push   $0xe9
+  jmp __alltraps
+  1025bf:	e9 08 01 00 00       	jmp    1026cc <__alltraps>
+
+001025c4 <vector234>:
+.globl vector234
+vector234:
+  pushl $0
+  1025c4:	6a 00                	push   $0x0
+  pushl $234
+  1025c6:	68 ea 00 00 00       	push   $0xea
+  jmp __alltraps
+  1025cb:	e9 fc 00 00 00       	jmp    1026cc <__alltraps>
+
+001025d0 <vector235>:
+.globl vector235
+vector235:
+  pushl $0
+  1025d0:	6a 00                	push   $0x0
+  pushl $235
+  1025d2:	68 eb 00 00 00       	push   $0xeb
+  jmp __alltraps
+  1025d7:	e9 f0 00 00 00       	jmp    1026cc <__alltraps>
+
+001025dc <vector236>:
+.globl vector236
+vector236:
+  pushl $0
+  1025dc:	6a 00                	push   $0x0
+  pushl $236
+  1025de:	68 ec 00 00 00       	push   $0xec
+  jmp __alltraps
+  1025e3:	e9 e4 00 00 00       	jmp    1026cc <__alltraps>
+
+001025e8 <vector237>:
+.globl vector237
+vector237:
+  pushl $0
+  1025e8:	6a 00                	push   $0x0
+  pushl $237
+  1025ea:	68 ed 00 00 00       	push   $0xed
+  jmp __alltraps
+  1025ef:	e9 d8 00 00 00       	jmp    1026cc <__alltraps>
+
+001025f4 <vector238>:
+.globl vector238
+vector238:
+  pushl $0
+  1025f4:	6a 00                	push   $0x0
+  pushl $238
+  1025f6:	68 ee 00 00 00       	push   $0xee
+  jmp __alltraps
+  1025fb:	e9 cc 00 00 00       	jmp    1026cc <__alltraps>
+
+00102600 <vector239>:
+.globl vector239
+vector239:
+  pushl $0
+  102600:	6a 00                	push   $0x0
+  pushl $239
+  102602:	68 ef 00 00 00       	push   $0xef
+  jmp __alltraps
+  102607:	e9 c0 00 00 00       	jmp    1026cc <__alltraps>
+
+0010260c <vector240>:
+.globl vector240
+vector240:
+  pushl $0
+  10260c:	6a 00                	push   $0x0
+  pushl $240
+  10260e:	68 f0 00 00 00       	push   $0xf0
+  jmp __alltraps
+  102613:	e9 b4 00 00 00       	jmp    1026cc <__alltraps>
+
+00102618 <vector241>:
+.globl vector241
+vector241:
+  pushl $0
+  102618:	6a 00                	push   $0x0
+  pushl $241
+  10261a:	68 f1 00 00 00       	push   $0xf1
+  jmp __alltraps
+  10261f:	e9 a8 00 00 00       	jmp    1026cc <__alltraps>
+
+00102624 <vector242>:
+.globl vector242
+vector242:
+  pushl $0
+  102624:	6a 00                	push   $0x0
+  pushl $242
+  102626:	68 f2 00 00 00       	push   $0xf2
+  jmp __alltraps
+  10262b:	e9 9c 00 00 00       	jmp    1026cc <__alltraps>
+
+00102630 <vector243>:
+.globl vector243
+vector243:
+  pushl $0
+  102630:	6a 00                	push   $0x0
+  pushl $243
+  102632:	68 f3 00 00 00       	push   $0xf3
+  jmp __alltraps
+  102637:	e9 90 00 00 00       	jmp    1026cc <__alltraps>
+
+0010263c <vector244>:
+.globl vector244
+vector244:
+  pushl $0
+  10263c:	6a 00                	push   $0x0
+  pushl $244
+  10263e:	68 f4 00 00 00       	push   $0xf4
+  jmp __alltraps
+  102643:	e9 84 00 00 00       	jmp    1026cc <__alltraps>
+
+00102648 <vector245>:
+.globl vector245
+vector245:
+  pushl $0
+  102648:	6a 00                	push   $0x0
+  pushl $245
+  10264a:	68 f5 00 00 00       	push   $0xf5
+  jmp __alltraps
+  10264f:	e9 78 00 00 00       	jmp    1026cc <__alltraps>
+
+00102654 <vector246>:
+.globl vector246
+vector246:
+  pushl $0
+  102654:	6a 00                	push   $0x0
+  pushl $246
+  102656:	68 f6 00 00 00       	push   $0xf6
+  jmp __alltraps
+  10265b:	e9 6c 00 00 00       	jmp    1026cc <__alltraps>
+
+00102660 <vector247>:
+.globl vector247
+vector247:
+  pushl $0
+  102660:	6a 00                	push   $0x0
+  pushl $247
+  102662:	68 f7 00 00 00       	push   $0xf7
+  jmp __alltraps
+  102667:	e9 60 00 00 00       	jmp    1026cc <__alltraps>
+
+0010266c <vector248>:
+.globl vector248
+vector248:
+  pushl $0
+  10266c:	6a 00                	push   $0x0
+  pushl $248
+  10266e:	68 f8 00 00 00       	push   $0xf8
+  jmp __alltraps
+  102673:	e9 54 00 00 00       	jmp    1026cc <__alltraps>
+
+00102678 <vector249>:
+.globl vector249
+vector249:
+  pushl $0
+  102678:	6a 00                	push   $0x0
+  pushl $249
+  10267a:	68 f9 00 00 00       	push   $0xf9
+  jmp __alltraps
+  10267f:	e9 48 00 00 00       	jmp    1026cc <__alltraps>
+
+00102684 <vector250>:
+.globl vector250
+vector250:
+  pushl $0
+  102684:	6a 00                	push   $0x0
+  pushl $250
+  102686:	68 fa 00 00 00       	push   $0xfa
+  jmp __alltraps
+  10268b:	e9 3c 00 00 00       	jmp    1026cc <__alltraps>
+
+00102690 <vector251>:
+.globl vector251
+vector251:
+  pushl $0
+  102690:	6a 00                	push   $0x0
+  pushl $251
+  102692:	68 fb 00 00 00       	push   $0xfb
+  jmp __alltraps
+  102697:	e9 30 00 00 00       	jmp    1026cc <__alltraps>
+
+0010269c <vector252>:
+.globl vector252
+vector252:
+  pushl $0
+  10269c:	6a 00                	push   $0x0
+  pushl $252
+  10269e:	68 fc 00 00 00       	push   $0xfc
+  jmp __alltraps
+  1026a3:	e9 24 00 00 00       	jmp    1026cc <__alltraps>
+
+001026a8 <vector253>:
+.globl vector253
+vector253:
+  pushl $0
+  1026a8:	6a 00                	push   $0x0
+  pushl $253
+  1026aa:	68 fd 00 00 00       	push   $0xfd
+  jmp __alltraps
+  1026af:	e9 18 00 00 00       	jmp    1026cc <__alltraps>
+
+001026b4 <vector254>:
+.globl vector254
+vector254:
+  pushl $0
+  1026b4:	6a 00                	push   $0x0
+  pushl $254
+  1026b6:	68 fe 00 00 00       	push   $0xfe
+  jmp __alltraps
+  1026bb:	e9 0c 00 00 00       	jmp    1026cc <__alltraps>
+
+001026c0 <vector255>:
+.globl vector255
+vector255:
+  pushl $0
+  1026c0:	6a 00                	push   $0x0
+  pushl $255
+  1026c2:	68 ff 00 00 00       	push   $0xff
+  jmp __alltraps
+  1026c7:	e9 00 00 00 00       	jmp    1026cc <__alltraps>
+
+001026cc <__alltraps>:
+.text
+.globl __alltraps
+__alltraps:
+    # push registers to build a trap frame
+    # therefore make the stack look like a struct trapframe
+    pushl %ds
+  1026cc:	1e                   	push   %ds
+    pushl %es
+  1026cd:	06                   	push   %es
+    pushl %fs
+  1026ce:	0f a0                	push   %fs
+    pushl %gs
+  1026d0:	0f a8                	push   %gs
+    pushal
+  1026d2:	60                   	pusha  
+
+    # load GD_KDATA into %ds and %es to set up data segments for kernel
+    movl $GD_KDATA, %eax
+  1026d3:	b8 10 00 00 00       	mov    $0x10,%eax
+    movw %ax, %ds
+  1026d8:	8e d8                	mov    %eax,%ds
+    movw %ax, %es
+  1026da:	8e c0                	mov    %eax,%es
+
+    # push %esp to pass a pointer to the trapframe as an argument to trap()
+    pushl %esp
+  1026dc:	54                   	push   %esp
+
+    # call trap(tf), where tf=%esp
+    call trap
+  1026dd:	e8 65 f5 ff ff       	call   101c47 <trap>
+
+    # pop the pushed stack pointer
+    popl %esp
+  1026e2:	5c                   	pop    %esp
+
+001026e3 <__trapret>:
+
+    # return falls through to trapret...
+.globl __trapret
+__trapret:
+    # restore registers from stack
+    popal
+  1026e3:	61                   	popa   
+
+    # restore %ds, %es, %fs and %gs
+    popl %gs
+  1026e4:	0f a9                	pop    %gs
+    popl %fs
+  1026e6:	0f a1                	pop    %fs
+    popl %es
+  1026e8:	07                   	pop    %es
+    popl %ds
+  1026e9:	1f                   	pop    %ds
+
+    # get rid of the trap number and error code
+    addl $0x8, %esp
+  1026ea:	83 c4 08             	add    $0x8,%esp
+    iret
+  1026ed:	cf                   	iret   
+
+001026ee <lgdt>:
+/* *
+ * lgdt - load the global descriptor table register and reset the
+ * data/code segement registers for kernel.
+ * */
+static inline void
+lgdt(struct pseudodesc *pd) {
+  1026ee:	55                   	push   %ebp
+  1026ef:	89 e5                	mov    %esp,%ebp
+    asm volatile ("lgdt (%0)" :: "r" (pd));
+  1026f1:	8b 45 08             	mov    0x8(%ebp),%eax
+  1026f4:	0f 01 10             	lgdtl  (%eax)
+    asm volatile ("movw %%ax, %%gs" :: "a" (USER_DS));
+  1026f7:	b8 23 00 00 00       	mov    $0x23,%eax
+  1026fc:	8e e8                	mov    %eax,%gs
+    asm volatile ("movw %%ax, %%fs" :: "a" (USER_DS));
+  1026fe:	b8 23 00 00 00       	mov    $0x23,%eax
+  102703:	8e e0                	mov    %eax,%fs
+    asm volatile ("movw %%ax, %%es" :: "a" (KERNEL_DS));
+  102705:	b8 10 00 00 00       	mov    $0x10,%eax
+  10270a:	8e c0                	mov    %eax,%es
+    asm volatile ("movw %%ax, %%ds" :: "a" (KERNEL_DS));
+  10270c:	b8 10 00 00 00       	mov    $0x10,%eax
+  102711:	8e d8                	mov    %eax,%ds
+    asm volatile ("movw %%ax, %%ss" :: "a" (KERNEL_DS));
+  102713:	b8 10 00 00 00       	mov    $0x10,%eax
+  102718:	8e d0                	mov    %eax,%ss
+    // reload cs
+    asm volatile ("ljmp %0, $1f\n 1:\n" :: "i" (KERNEL_CS));
+  10271a:	ea 21 27 10 00 08 00 	ljmp   $0x8,$0x102721
+}
+  102721:	5d                   	pop    %ebp
+  102722:	c3                   	ret    
+
+00102723 <gdt_init>:
+/* temporary kernel stack */
+uint8_t stack0[1024];
+
+/* gdt_init - initialize the default GDT and TSS */
+static void
+gdt_init(void) {
+  102723:	55                   	push   %ebp
+  102724:	89 e5                	mov    %esp,%ebp
+  102726:	83 ec 14             	sub    $0x14,%esp
+    // Setup a TSS so that we can get the right stack when we trap from
+    // user to the kernel. But not safe here, it's only a temporary value,
+    // it will be set to KSTACKTOP in lab2.
+    ts.ts_esp0 = (uint32_t)&stack0 + sizeof(stack0);
+  102729:	b8 20 f9 10 00       	mov    $0x10f920,%eax
+  10272e:	05 00 04 00 00       	add    $0x400,%eax
+  102733:	a3 a4 f8 10 00       	mov    %eax,0x10f8a4
+    ts.ts_ss0 = KERNEL_DS;
+  102738:	66 c7 05 a8 f8 10 00 	movw   $0x10,0x10f8a8
+  10273f:	10 00 
+
+    // initialize the TSS filed of the gdt
+    gdt[SEG_TSS] = SEG16(STS_T32A, (uint32_t)&ts, sizeof(ts), DPL_KERNEL);
+  102741:	66 c7 05 08 ea 10 00 	movw   $0x68,0x10ea08
+  102748:	68 00 
+  10274a:	b8 a0 f8 10 00       	mov    $0x10f8a0,%eax
+  10274f:	66 a3 0a ea 10 00    	mov    %ax,0x10ea0a
+  102755:	b8 a0 f8 10 00       	mov    $0x10f8a0,%eax
+  10275a:	c1 e8 10             	shr    $0x10,%eax
+  10275d:	a2 0c ea 10 00       	mov    %al,0x10ea0c
+  102762:	0f b6 05 0d ea 10 00 	movzbl 0x10ea0d,%eax
+  102769:	83 e0 f0             	and    $0xfffffff0,%eax
+  10276c:	83 c8 09             	or     $0x9,%eax
+  10276f:	a2 0d ea 10 00       	mov    %al,0x10ea0d
+  102774:	0f b6 05 0d ea 10 00 	movzbl 0x10ea0d,%eax
+  10277b:	83 c8 10             	or     $0x10,%eax
+  10277e:	a2 0d ea 10 00       	mov    %al,0x10ea0d
+  102783:	0f b6 05 0d ea 10 00 	movzbl 0x10ea0d,%eax
+  10278a:	83 e0 9f             	and    $0xffffff9f,%eax
+  10278d:	a2 0d ea 10 00       	mov    %al,0x10ea0d
+  102792:	0f b6 05 0d ea 10 00 	movzbl 0x10ea0d,%eax
+  102799:	83 c8 80             	or     $0xffffff80,%eax
+  10279c:	a2 0d ea 10 00       	mov    %al,0x10ea0d
+  1027a1:	0f b6 05 0e ea 10 00 	movzbl 0x10ea0e,%eax
+  1027a8:	83 e0 f0             	and    $0xfffffff0,%eax
+  1027ab:	a2 0e ea 10 00       	mov    %al,0x10ea0e
+  1027b0:	0f b6 05 0e ea 10 00 	movzbl 0x10ea0e,%eax
+  1027b7:	83 e0 ef             	and    $0xffffffef,%eax
+  1027ba:	a2 0e ea 10 00       	mov    %al,0x10ea0e
+  1027bf:	0f b6 05 0e ea 10 00 	movzbl 0x10ea0e,%eax
+  1027c6:	83 e0 df             	and    $0xffffffdf,%eax
+  1027c9:	a2 0e ea 10 00       	mov    %al,0x10ea0e
+  1027ce:	0f b6 05 0e ea 10 00 	movzbl 0x10ea0e,%eax
+  1027d5:	83 c8 40             	or     $0x40,%eax
+  1027d8:	a2 0e ea 10 00       	mov    %al,0x10ea0e
+  1027dd:	0f b6 05 0e ea 10 00 	movzbl 0x10ea0e,%eax
+  1027e4:	83 e0 7f             	and    $0x7f,%eax
+  1027e7:	a2 0e ea 10 00       	mov    %al,0x10ea0e
+  1027ec:	b8 a0 f8 10 00       	mov    $0x10f8a0,%eax
+  1027f1:	c1 e8 18             	shr    $0x18,%eax
+  1027f4:	a2 0f ea 10 00       	mov    %al,0x10ea0f
+    gdt[SEG_TSS].sd_s = 0;
+  1027f9:	0f b6 05 0d ea 10 00 	movzbl 0x10ea0d,%eax
+  102800:	83 e0 ef             	and    $0xffffffef,%eax
+  102803:	a2 0d ea 10 00       	mov    %al,0x10ea0d
+
+    // reload all segment registers
+    lgdt(&gdt_pd);
+  102808:	c7 04 24 10 ea 10 00 	movl   $0x10ea10,(%esp)
+  10280f:	e8 da fe ff ff       	call   1026ee <lgdt>
+  102814:	66 c7 45 fe 28 00    	movw   $0x28,-0x2(%ebp)
+}
+
+static inline void
+ltr(uint16_t sel) {
+    asm volatile ("ltr %0" :: "r" (sel));
+  10281a:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
+  10281e:	0f 00 d8             	ltr    %ax
+
+    // load the TSS
+    ltr(GD_TSS);
+}
+  102821:	c9                   	leave  
+  102822:	c3                   	ret    
+
+00102823 <pmm_init>:
+
+/* pmm_init - initialize the physical memory management */
+void
+pmm_init(void) {
+  102823:	55                   	push   %ebp
+  102824:	89 e5                	mov    %esp,%ebp
+    gdt_init();
+  102826:	e8 f8 fe ff ff       	call   102723 <gdt_init>
+}
+  10282b:	5d                   	pop    %ebp
+  10282c:	c3                   	ret    
+
+0010282d <strlen>:
+ * @s:        the input string
+ *
+ * The strlen() function returns the length of string @s.
+ * */
+size_t
+strlen(const char *s) {
+  10282d:	55                   	push   %ebp
+  10282e:	89 e5                	mov    %esp,%ebp
+  102830:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  102833:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  10283a:	eb 04                	jmp    102840 <strlen+0x13>
+        cnt ++;
+  10283c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+    while (*s ++ != '\0') {
+  102840:	8b 45 08             	mov    0x8(%ebp),%eax
+  102843:	0f b6 00             	movzbl (%eax),%eax
+  102846:	84 c0                	test   %al,%al
+  102848:	0f 95 c0             	setne  %al
+  10284b:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  10284f:	84 c0                	test   %al,%al
+  102851:	75 e9                	jne    10283c <strlen+0xf>
+    }
+    return cnt;
+  102853:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  102856:	c9                   	leave  
+  102857:	c3                   	ret    
+
+00102858 <strnlen>:
+ * The return value is strlen(s), if that is less than @len, or
+ * @len if there is no '\0' character among the first @len characters
+ * pointed by @s.
+ * */
+size_t
+strnlen(const char *s, size_t len) {
+  102858:	55                   	push   %ebp
+  102859:	89 e5                	mov    %esp,%ebp
+  10285b:	83 ec 10             	sub    $0x10,%esp
+    size_t cnt = 0;
+  10285e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  102865:	eb 04                	jmp    10286b <strnlen+0x13>
+        cnt ++;
+  102867:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+    while (cnt < len && *s ++ != '\0') {
+  10286b:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  10286e:	3b 45 0c             	cmp    0xc(%ebp),%eax
+  102871:	73 13                	jae    102886 <strnlen+0x2e>
+  102873:	8b 45 08             	mov    0x8(%ebp),%eax
+  102876:	0f b6 00             	movzbl (%eax),%eax
+  102879:	84 c0                	test   %al,%al
+  10287b:	0f 95 c0             	setne  %al
+  10287e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  102882:	84 c0                	test   %al,%al
+  102884:	75 e1                	jne    102867 <strnlen+0xf>
+    }
+    return cnt;
+  102886:	8b 45 fc             	mov    -0x4(%ebp),%eax
+}
+  102889:	c9                   	leave  
+  10288a:	c3                   	ret    
+
+0010288b <strcpy>:
+ * To avoid overflows, the size of array pointed by @dst should be long enough to
+ * contain the same string as @src (including the terminating null character), and
+ * should not overlap in memory with @src.
+ * */
+char *
+strcpy(char *dst, const char *src) {
+  10288b:	55                   	push   %ebp
+  10288c:	89 e5                	mov    %esp,%ebp
+  10288e:	57                   	push   %edi
+  10288f:	56                   	push   %esi
+  102890:	53                   	push   %ebx
+  102891:	83 ec 24             	sub    $0x24,%esp
+  102894:	8b 45 08             	mov    0x8(%ebp),%eax
+  102897:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  10289a:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10289d:	89 45 ec             	mov    %eax,-0x14(%ebp)
+#ifndef __HAVE_ARCH_STRCPY
+#define __HAVE_ARCH_STRCPY
+static inline char *
+__strcpy(char *dst, const char *src) {
+    int d0, d1, d2;
+    asm volatile (
+  1028a0:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  1028a3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1028a6:	89 d6                	mov    %edx,%esi
+  1028a8:	89 c3                	mov    %eax,%ebx
+  1028aa:	89 df                	mov    %ebx,%edi
+  1028ac:	ac                   	lods   %ds:(%esi),%al
+  1028ad:	aa                   	stos   %al,%es:(%edi)
+  1028ae:	84 c0                	test   %al,%al
+  1028b0:	75 fa                	jne    1028ac <strcpy+0x21>
+  1028b2:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  1028b5:	89 fb                	mov    %edi,%ebx
+  1028b7:	89 75 e8             	mov    %esi,-0x18(%ebp)
+  1028ba:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
+  1028bd:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  1028c0:	89 45 e0             	mov    %eax,-0x20(%ebp)
+            "stosb;"
+            "testb %%al, %%al;"
+            "jne 1b;"
+            : "=&S" (d0), "=&D" (d1), "=&a" (d2)
+            : "0" (src), "1" (dst) : "memory");
+    return dst;
+  1028c3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    char *p = dst;
+    while ((*p ++ = *src ++) != '\0')
+        /* nothing */;
+    return dst;
+#endif /* __HAVE_ARCH_STRCPY */
+}
+  1028c6:	83 c4 24             	add    $0x24,%esp
+  1028c9:	5b                   	pop    %ebx
+  1028ca:	5e                   	pop    %esi
+  1028cb:	5f                   	pop    %edi
+  1028cc:	5d                   	pop    %ebp
+  1028cd:	c3                   	ret    
+
+001028ce <strncpy>:
+ * @len:    maximum number of characters to be copied from @src
+ *
+ * The return value is @dst
+ * */
+char *
+strncpy(char *dst, const char *src, size_t len) {
+  1028ce:	55                   	push   %ebp
+  1028cf:	89 e5                	mov    %esp,%ebp
+  1028d1:	83 ec 10             	sub    $0x10,%esp
+    char *p = dst;
+  1028d4:	8b 45 08             	mov    0x8(%ebp),%eax
+  1028d7:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    while (len > 0) {
+  1028da:	eb 21                	jmp    1028fd <strncpy+0x2f>
+        if ((*p = *src) != '\0') {
+  1028dc:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1028df:	0f b6 10             	movzbl (%eax),%edx
+  1028e2:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  1028e5:	88 10                	mov    %dl,(%eax)
+  1028e7:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  1028ea:	0f b6 00             	movzbl (%eax),%eax
+  1028ed:	84 c0                	test   %al,%al
+  1028ef:	74 04                	je     1028f5 <strncpy+0x27>
+            src ++;
+  1028f1:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+        }
+        p ++, len --;
+  1028f5:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  1028f9:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+    while (len > 0) {
+  1028fd:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  102901:	75 d9                	jne    1028dc <strncpy+0xe>
+    }
+    return dst;
+  102903:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  102906:	c9                   	leave  
+  102907:	c3                   	ret    
+
+00102908 <strcmp>:
+ * - A value greater than zero indicates that the first character that does
+ *   not match has a greater value in @s1 than in @s2;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+strcmp(const char *s1, const char *s2) {
+  102908:	55                   	push   %ebp
+  102909:	89 e5                	mov    %esp,%ebp
+  10290b:	57                   	push   %edi
+  10290c:	56                   	push   %esi
+  10290d:	53                   	push   %ebx
+  10290e:	83 ec 24             	sub    $0x24,%esp
+  102911:	8b 45 08             	mov    0x8(%ebp),%eax
+  102914:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  102917:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10291a:	89 45 ec             	mov    %eax,-0x14(%ebp)
+    asm volatile (
+  10291d:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  102920:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  102923:	89 d6                	mov    %edx,%esi
+  102925:	89 c3                	mov    %eax,%ebx
+  102927:	89 df                	mov    %ebx,%edi
+  102929:	ac                   	lods   %ds:(%esi),%al
+  10292a:	ae                   	scas   %es:(%edi),%al
+  10292b:	75 08                	jne    102935 <strcmp+0x2d>
+  10292d:	84 c0                	test   %al,%al
+  10292f:	75 f8                	jne    102929 <strcmp+0x21>
+  102931:	31 c0                	xor    %eax,%eax
+  102933:	eb 04                	jmp    102939 <strcmp+0x31>
+  102935:	19 c0                	sbb    %eax,%eax
+  102937:	0c 01                	or     $0x1,%al
+  102939:	89 fb                	mov    %edi,%ebx
+  10293b:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  10293e:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  102941:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  102944:	89 75 e4             	mov    %esi,-0x1c(%ebp)
+  102947:	89 5d e0             	mov    %ebx,-0x20(%ebp)
+    return ret;
+  10294a:	8b 45 e8             	mov    -0x18(%ebp),%eax
+    while (*s1 != '\0' && *s1 == *s2) {
+        s1 ++, s2 ++;
+    }
+    return (int)((unsigned char)*s1 - (unsigned char)*s2);
+#endif /* __HAVE_ARCH_STRCMP */
+}
+  10294d:	83 c4 24             	add    $0x24,%esp
+  102950:	5b                   	pop    %ebx
+  102951:	5e                   	pop    %esi
+  102952:	5f                   	pop    %edi
+  102953:	5d                   	pop    %ebp
+  102954:	c3                   	ret    
+
+00102955 <strncmp>:
+ * they are equal to each other, it continues with the following pairs until
+ * the characters differ, until a terminating null-character is reached, or
+ * until @n characters match in both strings, whichever happens first.
+ * */
+int
+strncmp(const char *s1, const char *s2, size_t n) {
+  102955:	55                   	push   %ebp
+  102956:	89 e5                	mov    %esp,%ebp
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  102958:	eb 0c                	jmp    102966 <strncmp+0x11>
+        n --, s1 ++, s2 ++;
+  10295a:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  10295e:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  102962:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
+    while (n > 0 && *s1 != '\0' && *s1 == *s2) {
+  102966:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  10296a:	74 1a                	je     102986 <strncmp+0x31>
+  10296c:	8b 45 08             	mov    0x8(%ebp),%eax
+  10296f:	0f b6 00             	movzbl (%eax),%eax
+  102972:	84 c0                	test   %al,%al
+  102974:	74 10                	je     102986 <strncmp+0x31>
+  102976:	8b 45 08             	mov    0x8(%ebp),%eax
+  102979:	0f b6 10             	movzbl (%eax),%edx
+  10297c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10297f:	0f b6 00             	movzbl (%eax),%eax
+  102982:	38 c2                	cmp    %al,%dl
+  102984:	74 d4                	je     10295a <strncmp+0x5>
+    }
+    return (n == 0) ? 0 : (int)((unsigned char)*s1 - (unsigned char)*s2);
+  102986:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  10298a:	74 1a                	je     1029a6 <strncmp+0x51>
+  10298c:	8b 45 08             	mov    0x8(%ebp),%eax
+  10298f:	0f b6 00             	movzbl (%eax),%eax
+  102992:	0f b6 d0             	movzbl %al,%edx
+  102995:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102998:	0f b6 00             	movzbl (%eax),%eax
+  10299b:	0f b6 c0             	movzbl %al,%eax
+  10299e:	89 d1                	mov    %edx,%ecx
+  1029a0:	29 c1                	sub    %eax,%ecx
+  1029a2:	89 c8                	mov    %ecx,%eax
+  1029a4:	eb 05                	jmp    1029ab <strncmp+0x56>
+  1029a6:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  1029ab:	5d                   	pop    %ebp
+  1029ac:	c3                   	ret    
+
+001029ad <strchr>:
+ *
+ * The strchr() function returns a pointer to the first occurrence of
+ * character in @s. If the value is not found, the function returns 'NULL'.
+ * */
+char *
+strchr(const char *s, char c) {
+  1029ad:	55                   	push   %ebp
+  1029ae:	89 e5                	mov    %esp,%ebp
+  1029b0:	83 ec 04             	sub    $0x4,%esp
+  1029b3:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1029b6:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  1029b9:	eb 14                	jmp    1029cf <strchr+0x22>
+        if (*s == c) {
+  1029bb:	8b 45 08             	mov    0x8(%ebp),%eax
+  1029be:	0f b6 00             	movzbl (%eax),%eax
+  1029c1:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  1029c4:	75 05                	jne    1029cb <strchr+0x1e>
+            return (char *)s;
+  1029c6:	8b 45 08             	mov    0x8(%ebp),%eax
+  1029c9:	eb 13                	jmp    1029de <strchr+0x31>
+        }
+        s ++;
+  1029cb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+    while (*s != '\0') {
+  1029cf:	8b 45 08             	mov    0x8(%ebp),%eax
+  1029d2:	0f b6 00             	movzbl (%eax),%eax
+  1029d5:	84 c0                	test   %al,%al
+  1029d7:	75 e2                	jne    1029bb <strchr+0xe>
+    }
+    return NULL;
+  1029d9:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  1029de:	c9                   	leave  
+  1029df:	c3                   	ret    
+
+001029e0 <strfind>:
+ * The strfind() function is like strchr() except that if @c is
+ * not found in @s, then it returns a pointer to the null byte at the
+ * end of @s, rather than 'NULL'.
+ * */
+char *
+strfind(const char *s, char c) {
+  1029e0:	55                   	push   %ebp
+  1029e1:	89 e5                	mov    %esp,%ebp
+  1029e3:	83 ec 04             	sub    $0x4,%esp
+  1029e6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1029e9:	88 45 fc             	mov    %al,-0x4(%ebp)
+    while (*s != '\0') {
+  1029ec:	eb 0f                	jmp    1029fd <strfind+0x1d>
+        if (*s == c) {
+  1029ee:	8b 45 08             	mov    0x8(%ebp),%eax
+  1029f1:	0f b6 00             	movzbl (%eax),%eax
+  1029f4:	3a 45 fc             	cmp    -0x4(%ebp),%al
+  1029f7:	74 10                	je     102a09 <strfind+0x29>
+            break;
+        }
+        s ++;
+  1029f9:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+    while (*s != '\0') {
+  1029fd:	8b 45 08             	mov    0x8(%ebp),%eax
+  102a00:	0f b6 00             	movzbl (%eax),%eax
+  102a03:	84 c0                	test   %al,%al
+  102a05:	75 e7                	jne    1029ee <strfind+0xe>
+  102a07:	eb 01                	jmp    102a0a <strfind+0x2a>
+            break;
+  102a09:	90                   	nop
+    }
+    return (char *)s;
+  102a0a:	8b 45 08             	mov    0x8(%ebp),%eax
+}
+  102a0d:	c9                   	leave  
+  102a0e:	c3                   	ret    
+
+00102a0f <strtol>:
+ * an optional "0x" or "0X" prefix.
+ *
+ * The strtol() function returns the converted integral number as a long int value.
+ * */
+long
+strtol(const char *s, char **endptr, int base) {
+  102a0f:	55                   	push   %ebp
+  102a10:	89 e5                	mov    %esp,%ebp
+  102a12:	83 ec 10             	sub    $0x10,%esp
+    int neg = 0;
+  102a15:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
+    long val = 0;
+  102a1c:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
+
+    // gobble initial whitespace
+    while (*s == ' ' || *s == '\t') {
+  102a23:	eb 04                	jmp    102a29 <strtol+0x1a>
+        s ++;
+  102a25:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+    while (*s == ' ' || *s == '\t') {
+  102a29:	8b 45 08             	mov    0x8(%ebp),%eax
+  102a2c:	0f b6 00             	movzbl (%eax),%eax
+  102a2f:	3c 20                	cmp    $0x20,%al
+  102a31:	74 f2                	je     102a25 <strtol+0x16>
+  102a33:	8b 45 08             	mov    0x8(%ebp),%eax
+  102a36:	0f b6 00             	movzbl (%eax),%eax
+  102a39:	3c 09                	cmp    $0x9,%al
+  102a3b:	74 e8                	je     102a25 <strtol+0x16>
+    }
+
+    // plus/minus sign
+    if (*s == '+') {
+  102a3d:	8b 45 08             	mov    0x8(%ebp),%eax
+  102a40:	0f b6 00             	movzbl (%eax),%eax
+  102a43:	3c 2b                	cmp    $0x2b,%al
+  102a45:	75 06                	jne    102a4d <strtol+0x3e>
+        s ++;
+  102a47:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  102a4b:	eb 15                	jmp    102a62 <strtol+0x53>
+    }
+    else if (*s == '-') {
+  102a4d:	8b 45 08             	mov    0x8(%ebp),%eax
+  102a50:	0f b6 00             	movzbl (%eax),%eax
+  102a53:	3c 2d                	cmp    $0x2d,%al
+  102a55:	75 0b                	jne    102a62 <strtol+0x53>
+        s ++, neg = 1;
+  102a57:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  102a5b:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)
+    }
+
+    // hex or octal base prefix
+    if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x')) {
+  102a62:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  102a66:	74 06                	je     102a6e <strtol+0x5f>
+  102a68:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
+  102a6c:	75 24                	jne    102a92 <strtol+0x83>
+  102a6e:	8b 45 08             	mov    0x8(%ebp),%eax
+  102a71:	0f b6 00             	movzbl (%eax),%eax
+  102a74:	3c 30                	cmp    $0x30,%al
+  102a76:	75 1a                	jne    102a92 <strtol+0x83>
+  102a78:	8b 45 08             	mov    0x8(%ebp),%eax
+  102a7b:	83 c0 01             	add    $0x1,%eax
+  102a7e:	0f b6 00             	movzbl (%eax),%eax
+  102a81:	3c 78                	cmp    $0x78,%al
+  102a83:	75 0d                	jne    102a92 <strtol+0x83>
+        s += 2, base = 16;
+  102a85:	83 45 08 02          	addl   $0x2,0x8(%ebp)
+  102a89:	c7 45 10 10 00 00 00 	movl   $0x10,0x10(%ebp)
+  102a90:	eb 2a                	jmp    102abc <strtol+0xad>
+    }
+    else if (base == 0 && s[0] == '0') {
+  102a92:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  102a96:	75 17                	jne    102aaf <strtol+0xa0>
+  102a98:	8b 45 08             	mov    0x8(%ebp),%eax
+  102a9b:	0f b6 00             	movzbl (%eax),%eax
+  102a9e:	3c 30                	cmp    $0x30,%al
+  102aa0:	75 0d                	jne    102aaf <strtol+0xa0>
+        s ++, base = 8;
+  102aa2:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  102aa6:	c7 45 10 08 00 00 00 	movl   $0x8,0x10(%ebp)
+  102aad:	eb 0d                	jmp    102abc <strtol+0xad>
+    }
+    else if (base == 0) {
+  102aaf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  102ab3:	75 07                	jne    102abc <strtol+0xad>
+        base = 10;
+  102ab5:	c7 45 10 0a 00 00 00 	movl   $0xa,0x10(%ebp)
+
+    // digits
+    while (1) {
+        int dig;
+
+        if (*s >= '0' && *s <= '9') {
+  102abc:	8b 45 08             	mov    0x8(%ebp),%eax
+  102abf:	0f b6 00             	movzbl (%eax),%eax
+  102ac2:	3c 2f                	cmp    $0x2f,%al
+  102ac4:	7e 1b                	jle    102ae1 <strtol+0xd2>
+  102ac6:	8b 45 08             	mov    0x8(%ebp),%eax
+  102ac9:	0f b6 00             	movzbl (%eax),%eax
+  102acc:	3c 39                	cmp    $0x39,%al
+  102ace:	7f 11                	jg     102ae1 <strtol+0xd2>
+            dig = *s - '0';
+  102ad0:	8b 45 08             	mov    0x8(%ebp),%eax
+  102ad3:	0f b6 00             	movzbl (%eax),%eax
+  102ad6:	0f be c0             	movsbl %al,%eax
+  102ad9:	83 e8 30             	sub    $0x30,%eax
+  102adc:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  102adf:	eb 48                	jmp    102b29 <strtol+0x11a>
+        }
+        else if (*s >= 'a' && *s <= 'z') {
+  102ae1:	8b 45 08             	mov    0x8(%ebp),%eax
+  102ae4:	0f b6 00             	movzbl (%eax),%eax
+  102ae7:	3c 60                	cmp    $0x60,%al
+  102ae9:	7e 1b                	jle    102b06 <strtol+0xf7>
+  102aeb:	8b 45 08             	mov    0x8(%ebp),%eax
+  102aee:	0f b6 00             	movzbl (%eax),%eax
+  102af1:	3c 7a                	cmp    $0x7a,%al
+  102af3:	7f 11                	jg     102b06 <strtol+0xf7>
+            dig = *s - 'a' + 10;
+  102af5:	8b 45 08             	mov    0x8(%ebp),%eax
+  102af8:	0f b6 00             	movzbl (%eax),%eax
+  102afb:	0f be c0             	movsbl %al,%eax
+  102afe:	83 e8 57             	sub    $0x57,%eax
+  102b01:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  102b04:	eb 23                	jmp    102b29 <strtol+0x11a>
+        }
+        else if (*s >= 'A' && *s <= 'Z') {
+  102b06:	8b 45 08             	mov    0x8(%ebp),%eax
+  102b09:	0f b6 00             	movzbl (%eax),%eax
+  102b0c:	3c 40                	cmp    $0x40,%al
+  102b0e:	7e 3c                	jle    102b4c <strtol+0x13d>
+  102b10:	8b 45 08             	mov    0x8(%ebp),%eax
+  102b13:	0f b6 00             	movzbl (%eax),%eax
+  102b16:	3c 5a                	cmp    $0x5a,%al
+  102b18:	7f 32                	jg     102b4c <strtol+0x13d>
+            dig = *s - 'A' + 10;
+  102b1a:	8b 45 08             	mov    0x8(%ebp),%eax
+  102b1d:	0f b6 00             	movzbl (%eax),%eax
+  102b20:	0f be c0             	movsbl %al,%eax
+  102b23:	83 e8 37             	sub    $0x37,%eax
+  102b26:	89 45 f4             	mov    %eax,-0xc(%ebp)
+        }
+        else {
+            break;
+        }
+        if (dig >= base) {
+  102b29:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102b2c:	3b 45 10             	cmp    0x10(%ebp),%eax
+  102b2f:	7d 1a                	jge    102b4b <strtol+0x13c>
+            break;
+        }
+        s ++, val = (val * base) + dig;
+  102b31:	83 45 08 01          	addl   $0x1,0x8(%ebp)
+  102b35:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  102b38:	89 c2                	mov    %eax,%edx
+  102b3a:	0f af 55 10          	imul   0x10(%ebp),%edx
+  102b3e:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102b41:	01 d0                	add    %edx,%eax
+  102b43:	89 45 f8             	mov    %eax,-0x8(%ebp)
+        // we don't properly detect overflow!
+    }
+  102b46:	e9 71 ff ff ff       	jmp    102abc <strtol+0xad>
+            break;
+  102b4b:	90                   	nop
+
+    if (endptr) {
+  102b4c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  102b50:	74 08                	je     102b5a <strtol+0x14b>
+        *endptr = (char *) s;
+  102b52:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102b55:	8b 55 08             	mov    0x8(%ebp),%edx
+  102b58:	89 10                	mov    %edx,(%eax)
+    }
+    return (neg ? -val : val);
+  102b5a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
+  102b5e:	74 07                	je     102b67 <strtol+0x158>
+  102b60:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  102b63:	f7 d8                	neg    %eax
+  102b65:	eb 03                	jmp    102b6a <strtol+0x15b>
+  102b67:	8b 45 f8             	mov    -0x8(%ebp),%eax
+}
+  102b6a:	c9                   	leave  
+  102b6b:	c3                   	ret    
+
+00102b6c <memset>:
+ * @n:        number of bytes to be set to the value
+ *
+ * The memset() function returns @s.
+ * */
+void *
+memset(void *s, char c, size_t n) {
+  102b6c:	55                   	push   %ebp
+  102b6d:	89 e5                	mov    %esp,%ebp
+  102b6f:	57                   	push   %edi
+  102b70:	56                   	push   %esi
+  102b71:	53                   	push   %ebx
+  102b72:	83 ec 24             	sub    $0x24,%esp
+  102b75:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102b78:	88 45 d0             	mov    %al,-0x30(%ebp)
+#ifdef __HAVE_ARCH_MEMSET
+    return __memset(s, c, n);
+  102b7b:	0f be 45 d0          	movsbl -0x30(%ebp),%eax
+  102b7f:	8b 55 08             	mov    0x8(%ebp),%edx
+  102b82:	89 55 f0             	mov    %edx,-0x10(%ebp)
+  102b85:	88 45 ef             	mov    %al,-0x11(%ebp)
+  102b88:	8b 45 10             	mov    0x10(%ebp),%eax
+  102b8b:	89 45 e8             	mov    %eax,-0x18(%ebp)
+#ifndef __HAVE_ARCH_MEMSET
+#define __HAVE_ARCH_MEMSET
+static inline void *
+__memset(void *s, char c, size_t n) {
+    int d0, d1;
+    asm volatile (
+  102b8e:	8b 4d e8             	mov    -0x18(%ebp),%ecx
+  102b91:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
+  102b95:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  102b98:	89 ce                	mov    %ecx,%esi
+  102b9a:	89 d3                	mov    %edx,%ebx
+  102b9c:	89 f1                	mov    %esi,%ecx
+  102b9e:	89 df                	mov    %ebx,%edi
+  102ba0:	f3 aa                	rep stos %al,%es:(%edi)
+  102ba2:	89 fb                	mov    %edi,%ebx
+  102ba4:	89 ce                	mov    %ecx,%esi
+  102ba6:	89 75 e4             	mov    %esi,-0x1c(%ebp)
+  102ba9:	89 5d e0             	mov    %ebx,-0x20(%ebp)
+            "rep; stosb;"
+            : "=&c" (d0), "=&D" (d1)
+            : "0" (n), "a" (c), "1" (s)
+            : "memory");
+    return s;
+  102bac:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    while (n -- > 0) {
+        *p ++ = c;
+    }
+    return s;
+#endif /* __HAVE_ARCH_MEMSET */
+}
+  102baf:	83 c4 24             	add    $0x24,%esp
+  102bb2:	5b                   	pop    %ebx
+  102bb3:	5e                   	pop    %esi
+  102bb4:	5f                   	pop    %edi
+  102bb5:	5d                   	pop    %ebp
+  102bb6:	c3                   	ret    
+
+00102bb7 <memmove>:
+ * @n:        number of bytes to copy
+ *
+ * The memmove() function returns @dst.
+ * */
+void *
+memmove(void *dst, const void *src, size_t n) {
+  102bb7:	55                   	push   %ebp
+  102bb8:	89 e5                	mov    %esp,%ebp
+  102bba:	57                   	push   %edi
+  102bbb:	56                   	push   %esi
+  102bbc:	53                   	push   %ebx
+  102bbd:	83 ec 38             	sub    $0x38,%esp
+  102bc0:	8b 45 08             	mov    0x8(%ebp),%eax
+  102bc3:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  102bc6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102bc9:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  102bcc:	8b 45 10             	mov    0x10(%ebp),%eax
+  102bcf:	89 45 e8             	mov    %eax,-0x18(%ebp)
+
+#ifndef __HAVE_ARCH_MEMMOVE
+#define __HAVE_ARCH_MEMMOVE
+static inline void *
+__memmove(void *dst, const void *src, size_t n) {
+    if (dst < src) {
+  102bd2:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102bd5:	3b 45 ec             	cmp    -0x14(%ebp),%eax
+  102bd8:	73 4e                	jae    102c28 <memmove+0x71>
+  102bda:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102bdd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  102be0:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  102be3:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  102be6:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  102be9:	89 45 dc             	mov    %eax,-0x24(%ebp)
+            "andl $3, %%ecx;"
+            "jz 1f;"
+            "rep; movsb;"
+            "1:"
+            : "=&c" (d0), "=&D" (d1), "=&S" (d2)
+            : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  102bec:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  102bef:	89 c1                	mov    %eax,%ecx
+  102bf1:	c1 e9 02             	shr    $0x2,%ecx
+    asm volatile (
+  102bf4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  102bf7:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  102bfa:	89 4d c0             	mov    %ecx,-0x40(%ebp)
+  102bfd:	89 d7                	mov    %edx,%edi
+  102bff:	89 c3                	mov    %eax,%ebx
+  102c01:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+  102c04:	89 de                	mov    %ebx,%esi
+  102c06:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  102c08:	8b 4d dc             	mov    -0x24(%ebp),%ecx
+  102c0b:	83 e1 03             	and    $0x3,%ecx
+  102c0e:	74 02                	je     102c12 <memmove+0x5b>
+  102c10:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  102c12:	89 f3                	mov    %esi,%ebx
+  102c14:	89 4d c0             	mov    %ecx,-0x40(%ebp)
+  102c17:	8b 4d c0             	mov    -0x40(%ebp),%ecx
+  102c1a:	89 4d d8             	mov    %ecx,-0x28(%ebp)
+  102c1d:	89 7d d4             	mov    %edi,-0x2c(%ebp)
+  102c20:	89 5d d0             	mov    %ebx,-0x30(%ebp)
+            : "memory");
+    return dst;
+  102c23:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  102c26:	eb 3e                	jmp    102c66 <memmove+0xaf>
+            : "0" (n), "1" (n - 1 + src), "2" (n - 1 + dst)
+  102c28:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  102c2b:	8d 50 ff             	lea    -0x1(%eax),%edx
+  102c2e:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  102c31:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
+  102c34:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  102c37:	8d 50 ff             	lea    -0x1(%eax),%edx
+  102c3a:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102c3d:	01 c2                	add    %eax,%edx
+    asm volatile (
+  102c3f:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  102c42:	89 45 bc             	mov    %eax,-0x44(%ebp)
+  102c45:	89 ce                	mov    %ecx,%esi
+  102c47:	89 d3                	mov    %edx,%ebx
+  102c49:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+  102c4c:	89 df                	mov    %ebx,%edi
+  102c4e:	fd                   	std    
+  102c4f:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  102c51:	fc                   	cld    
+  102c52:	89 fb                	mov    %edi,%ebx
+  102c54:	89 4d bc             	mov    %ecx,-0x44(%ebp)
+  102c57:	8b 4d bc             	mov    -0x44(%ebp),%ecx
+  102c5a:	89 4d cc             	mov    %ecx,-0x34(%ebp)
+  102c5d:	89 75 c8             	mov    %esi,-0x38(%ebp)
+  102c60:	89 5d c4             	mov    %ebx,-0x3c(%ebp)
+    return dst;
+  102c63:	8b 45 f0             	mov    -0x10(%ebp),%eax
+            *d ++ = *s ++;
+        }
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMMOVE */
+}
+  102c66:	83 c4 38             	add    $0x38,%esp
+  102c69:	5b                   	pop    %ebx
+  102c6a:	5e                   	pop    %esi
+  102c6b:	5f                   	pop    %edi
+  102c6c:	5d                   	pop    %ebp
+  102c6d:	c3                   	ret    
+
+00102c6e <memcpy>:
+ * it always copies exactly @n bytes. To avoid overflows, the size of arrays pointed
+ * by both @src and @dst, should be at least @n bytes, and should not overlap
+ * (for overlapping memory area, memmove is a safer approach).
+ * */
+void *
+memcpy(void *dst, const void *src, size_t n) {
+  102c6e:	55                   	push   %ebp
+  102c6f:	89 e5                	mov    %esp,%ebp
+  102c71:	57                   	push   %edi
+  102c72:	56                   	push   %esi
+  102c73:	53                   	push   %ebx
+  102c74:	83 ec 24             	sub    $0x24,%esp
+  102c77:	8b 45 08             	mov    0x8(%ebp),%eax
+  102c7a:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  102c7d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102c80:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  102c83:	8b 45 10             	mov    0x10(%ebp),%eax
+  102c86:	89 45 e8             	mov    %eax,-0x18(%ebp)
+            : "0" (n / 4), "g" (n), "1" (dst), "2" (src)
+  102c89:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  102c8c:	89 c1                	mov    %eax,%ecx
+  102c8e:	c1 e9 02             	shr    $0x2,%ecx
+    asm volatile (
+  102c91:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  102c94:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  102c97:	89 4d d0             	mov    %ecx,-0x30(%ebp)
+  102c9a:	89 d7                	mov    %edx,%edi
+  102c9c:	89 c3                	mov    %eax,%ebx
+  102c9e:	8b 4d d0             	mov    -0x30(%ebp),%ecx
+  102ca1:	89 de                	mov    %ebx,%esi
+  102ca3:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
+  102ca5:	8b 4d e8             	mov    -0x18(%ebp),%ecx
+  102ca8:	83 e1 03             	and    $0x3,%ecx
+  102cab:	74 02                	je     102caf <memcpy+0x41>
+  102cad:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
+  102caf:	89 f3                	mov    %esi,%ebx
+  102cb1:	89 4d d0             	mov    %ecx,-0x30(%ebp)
+  102cb4:	8b 4d d0             	mov    -0x30(%ebp),%ecx
+  102cb7:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
+  102cba:	89 7d e0             	mov    %edi,-0x20(%ebp)
+  102cbd:	89 5d dc             	mov    %ebx,-0x24(%ebp)
+    return dst;
+  102cc0:	8b 45 f0             	mov    -0x10(%ebp),%eax
+    while (n -- > 0) {
+        *d ++ = *s ++;
+    }
+    return dst;
+#endif /* __HAVE_ARCH_MEMCPY */
+}
+  102cc3:	83 c4 24             	add    $0x24,%esp
+  102cc6:	5b                   	pop    %ebx
+  102cc7:	5e                   	pop    %esi
+  102cc8:	5f                   	pop    %edi
+  102cc9:	5d                   	pop    %ebp
+  102cca:	c3                   	ret    
+
+00102ccb <memcmp>:
+ *   match in both memory blocks has a greater value in @v1 than in @v2
+ *   as if evaluated as unsigned char values;
+ * - And a value less than zero indicates the opposite.
+ * */
+int
+memcmp(const void *v1, const void *v2, size_t n) {
+  102ccb:	55                   	push   %ebp
+  102ccc:	89 e5                	mov    %esp,%ebp
+  102cce:	83 ec 10             	sub    $0x10,%esp
+    const char *s1 = (const char *)v1;
+  102cd1:	8b 45 08             	mov    0x8(%ebp),%eax
+  102cd4:	89 45 fc             	mov    %eax,-0x4(%ebp)
+    const char *s2 = (const char *)v2;
+  102cd7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102cda:	89 45 f8             	mov    %eax,-0x8(%ebp)
+    while (n -- > 0) {
+  102cdd:	eb 32                	jmp    102d11 <memcmp+0x46>
+        if (*s1 != *s2) {
+  102cdf:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  102ce2:	0f b6 10             	movzbl (%eax),%edx
+  102ce5:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  102ce8:	0f b6 00             	movzbl (%eax),%eax
+  102ceb:	38 c2                	cmp    %al,%dl
+  102ced:	74 1a                	je     102d09 <memcmp+0x3e>
+            return (int)((unsigned char)*s1 - (unsigned char)*s2);
+  102cef:	8b 45 fc             	mov    -0x4(%ebp),%eax
+  102cf2:	0f b6 00             	movzbl (%eax),%eax
+  102cf5:	0f b6 d0             	movzbl %al,%edx
+  102cf8:	8b 45 f8             	mov    -0x8(%ebp),%eax
+  102cfb:	0f b6 00             	movzbl (%eax),%eax
+  102cfe:	0f b6 c0             	movzbl %al,%eax
+  102d01:	89 d1                	mov    %edx,%ecx
+  102d03:	29 c1                	sub    %eax,%ecx
+  102d05:	89 c8                	mov    %ecx,%eax
+  102d07:	eb 1c                	jmp    102d25 <memcmp+0x5a>
+        }
+        s1 ++, s2 ++;
+  102d09:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
+  102d0d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
+    while (n -- > 0) {
+  102d11:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
+  102d15:	0f 95 c0             	setne  %al
+  102d18:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  102d1c:	84 c0                	test   %al,%al
+  102d1e:	75 bf                	jne    102cdf <memcmp+0x14>
+    }
+    return 0;
+  102d20:	b8 00 00 00 00       	mov    $0x0,%eax
+}
+  102d25:	c9                   	leave  
+  102d26:	c3                   	ret    
+
+00102d27 <printnum>:
+ * @width:         maximum number of digits, if the actual width is less than @width, use @padc instead
+ * @padc:        character that padded on the left if the actual width is less than @width
+ * */
+static void
+printnum(void (*putch)(int, void*), void *putdat,
+        unsigned long long num, unsigned base, int width, int padc) {
+  102d27:	55                   	push   %ebp
+  102d28:	89 e5                	mov    %esp,%ebp
+  102d2a:	56                   	push   %esi
+  102d2b:	53                   	push   %ebx
+  102d2c:	83 ec 60             	sub    $0x60,%esp
+  102d2f:	8b 45 10             	mov    0x10(%ebp),%eax
+  102d32:	89 45 d0             	mov    %eax,-0x30(%ebp)
+  102d35:	8b 45 14             	mov    0x14(%ebp),%eax
+  102d38:	89 45 d4             	mov    %eax,-0x2c(%ebp)
+    unsigned long long result = num;
+  102d3b:	8b 45 d0             	mov    -0x30(%ebp),%eax
+  102d3e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
+  102d41:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  102d44:	89 55 ec             	mov    %edx,-0x14(%ebp)
+    unsigned mod = do_div(result, base);
+  102d47:	8b 45 18             	mov    0x18(%ebp),%eax
+  102d4a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+  102d4d:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  102d50:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  102d53:	89 45 c8             	mov    %eax,-0x38(%ebp)
+  102d56:	89 55 cc             	mov    %edx,-0x34(%ebp)
+  102d59:	8b 45 c8             	mov    -0x38(%ebp),%eax
+  102d5c:	8b 55 cc             	mov    -0x34(%ebp),%edx
+  102d5f:	89 d3                	mov    %edx,%ebx
+  102d61:	89 c6                	mov    %eax,%esi
+  102d63:	89 75 e0             	mov    %esi,-0x20(%ebp)
+  102d66:	89 5d f0             	mov    %ebx,-0x10(%ebp)
+  102d69:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102d6c:	89 45 f4             	mov    %eax,-0xc(%ebp)
+  102d6f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
+  102d73:	74 1c                	je     102d91 <printnum+0x6a>
+  102d75:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102d78:	ba 00 00 00 00       	mov    $0x0,%edx
+  102d7d:	f7 75 e4             	divl   -0x1c(%ebp)
+  102d80:	89 55 f4             	mov    %edx,-0xc(%ebp)
+  102d83:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  102d86:	ba 00 00 00 00       	mov    $0x0,%edx
+  102d8b:	f7 75 e4             	divl   -0x1c(%ebp)
+  102d8e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  102d91:	8b 55 e0             	mov    -0x20(%ebp),%edx
+  102d94:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102d97:	89 d6                	mov    %edx,%esi
+  102d99:	89 c3                	mov    %eax,%ebx
+  102d9b:	89 f0                	mov    %esi,%eax
+  102d9d:	89 da                	mov    %ebx,%edx
+  102d9f:	f7 75 e4             	divl   -0x1c(%ebp)
+  102da2:	89 d3                	mov    %edx,%ebx
+  102da4:	89 c6                	mov    %eax,%esi
+  102da6:	89 75 e0             	mov    %esi,-0x20(%ebp)
+  102da9:	89 5d dc             	mov    %ebx,-0x24(%ebp)
+  102dac:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  102daf:	89 45 c8             	mov    %eax,-0x38(%ebp)
+  102db2:	8b 55 f0             	mov    -0x10(%ebp),%edx
+  102db5:	89 55 c4             	mov    %edx,-0x3c(%ebp)
+  102db8:	8b 45 c8             	mov    -0x38(%ebp),%eax
+  102dbb:	8b 55 c4             	mov    -0x3c(%ebp),%edx
+  102dbe:	89 c3                	mov    %eax,%ebx
+  102dc0:	89 d6                	mov    %edx,%esi
+  102dc2:	89 5d e8             	mov    %ebx,-0x18(%ebp)
+  102dc5:	89 75 ec             	mov    %esi,-0x14(%ebp)
+  102dc8:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  102dcb:	89 45 d8             	mov    %eax,-0x28(%ebp)
+
+    // first recursively print all preceding (more significant) digits
+    if (num >= base) {
+  102dce:	8b 45 18             	mov    0x18(%ebp),%eax
+  102dd1:	ba 00 00 00 00       	mov    $0x0,%edx
+  102dd6:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  102dd9:	77 56                	ja     102e31 <printnum+0x10a>
+  102ddb:	3b 55 d4             	cmp    -0x2c(%ebp),%edx
+  102dde:	72 05                	jb     102de5 <printnum+0xbe>
+  102de0:	3b 45 d0             	cmp    -0x30(%ebp),%eax
+  102de3:	77 4c                	ja     102e31 <printnum+0x10a>
+        printnum(putch, putdat, result, base, width - 1, padc);
+  102de5:	8b 45 1c             	mov    0x1c(%ebp),%eax
+  102de8:	8d 50 ff             	lea    -0x1(%eax),%edx
+  102deb:	8b 45 20             	mov    0x20(%ebp),%eax
+  102dee:	89 44 24 18          	mov    %eax,0x18(%esp)
+  102df2:	89 54 24 14          	mov    %edx,0x14(%esp)
+  102df6:	8b 45 18             	mov    0x18(%ebp),%eax
+  102df9:	89 44 24 10          	mov    %eax,0x10(%esp)
+  102dfd:	8b 45 e8             	mov    -0x18(%ebp),%eax
+  102e00:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  102e03:	89 44 24 08          	mov    %eax,0x8(%esp)
+  102e07:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  102e0b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102e0e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  102e12:	8b 45 08             	mov    0x8(%ebp),%eax
+  102e15:	89 04 24             	mov    %eax,(%esp)
+  102e18:	e8 0a ff ff ff       	call   102d27 <printnum>
+  102e1d:	eb 1c                	jmp    102e3b <printnum+0x114>
+    } else {
+        // print any needed pad characters before first digit
+        while (-- width > 0)
+            putch(padc, putdat);
+  102e1f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102e22:	89 44 24 04          	mov    %eax,0x4(%esp)
+  102e26:	8b 45 20             	mov    0x20(%ebp),%eax
+  102e29:	89 04 24             	mov    %eax,(%esp)
+  102e2c:	8b 45 08             	mov    0x8(%ebp),%eax
+  102e2f:	ff d0                	call   *%eax
+        while (-- width > 0)
+  102e31:	83 6d 1c 01          	subl   $0x1,0x1c(%ebp)
+  102e35:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
+  102e39:	7f e4                	jg     102e1f <printnum+0xf8>
+    }
+    // then print this (the least significant) digit
+    putch("0123456789abcdef"[mod], putdat);
+  102e3b:	8b 45 d8             	mov    -0x28(%ebp),%eax
+  102e3e:	05 b0 3b 10 00       	add    $0x103bb0,%eax
+  102e43:	0f b6 00             	movzbl (%eax),%eax
+  102e46:	0f be c0             	movsbl %al,%eax
+  102e49:	8b 55 0c             	mov    0xc(%ebp),%edx
+  102e4c:	89 54 24 04          	mov    %edx,0x4(%esp)
+  102e50:	89 04 24             	mov    %eax,(%esp)
+  102e53:	8b 45 08             	mov    0x8(%ebp),%eax
+  102e56:	ff d0                	call   *%eax
+}
+  102e58:	83 c4 60             	add    $0x60,%esp
+  102e5b:	5b                   	pop    %ebx
+  102e5c:	5e                   	pop    %esi
+  102e5d:	5d                   	pop    %ebp
+  102e5e:	c3                   	ret    
+
+00102e5f <getuint>:
+ * getuint - get an unsigned int of various possible sizes from a varargs list
+ * @ap:            a varargs list pointer
+ * @lflag:        determines the size of the vararg that @ap points to
+ * */
+static unsigned long long
+getuint(va_list *ap, int lflag) {
+  102e5f:	55                   	push   %ebp
+  102e60:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  102e62:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  102e66:	7e 14                	jle    102e7c <getuint+0x1d>
+        return va_arg(*ap, unsigned long long);
+  102e68:	8b 45 08             	mov    0x8(%ebp),%eax
+  102e6b:	8b 00                	mov    (%eax),%eax
+  102e6d:	8d 48 08             	lea    0x8(%eax),%ecx
+  102e70:	8b 55 08             	mov    0x8(%ebp),%edx
+  102e73:	89 0a                	mov    %ecx,(%edx)
+  102e75:	8b 50 04             	mov    0x4(%eax),%edx
+  102e78:	8b 00                	mov    (%eax),%eax
+  102e7a:	eb 30                	jmp    102eac <getuint+0x4d>
+    }
+    else if (lflag) {
+  102e7c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  102e80:	74 16                	je     102e98 <getuint+0x39>
+        return va_arg(*ap, unsigned long);
+  102e82:	8b 45 08             	mov    0x8(%ebp),%eax
+  102e85:	8b 00                	mov    (%eax),%eax
+  102e87:	8d 48 04             	lea    0x4(%eax),%ecx
+  102e8a:	8b 55 08             	mov    0x8(%ebp),%edx
+  102e8d:	89 0a                	mov    %ecx,(%edx)
+  102e8f:	8b 00                	mov    (%eax),%eax
+  102e91:	ba 00 00 00 00       	mov    $0x0,%edx
+  102e96:	eb 14                	jmp    102eac <getuint+0x4d>
+    }
+    else {
+        return va_arg(*ap, unsigned int);
+  102e98:	8b 45 08             	mov    0x8(%ebp),%eax
+  102e9b:	8b 00                	mov    (%eax),%eax
+  102e9d:	8d 48 04             	lea    0x4(%eax),%ecx
+  102ea0:	8b 55 08             	mov    0x8(%ebp),%edx
+  102ea3:	89 0a                	mov    %ecx,(%edx)
+  102ea5:	8b 00                	mov    (%eax),%eax
+  102ea7:	ba 00 00 00 00       	mov    $0x0,%edx
+    }
+}
+  102eac:	5d                   	pop    %ebp
+  102ead:	c3                   	ret    
+
+00102eae <getint>:
+ * getint - same as getuint but signed, we can't use getuint because of sign extension
+ * @ap:            a varargs list pointer
+ * @lflag:        determines the size of the vararg that @ap points to
+ * */
+static long long
+getint(va_list *ap, int lflag) {
+  102eae:	55                   	push   %ebp
+  102eaf:	89 e5                	mov    %esp,%ebp
+    if (lflag >= 2) {
+  102eb1:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
+  102eb5:	7e 14                	jle    102ecb <getint+0x1d>
+        return va_arg(*ap, long long);
+  102eb7:	8b 45 08             	mov    0x8(%ebp),%eax
+  102eba:	8b 00                	mov    (%eax),%eax
+  102ebc:	8d 48 08             	lea    0x8(%eax),%ecx
+  102ebf:	8b 55 08             	mov    0x8(%ebp),%edx
+  102ec2:	89 0a                	mov    %ecx,(%edx)
+  102ec4:	8b 50 04             	mov    0x4(%eax),%edx
+  102ec7:	8b 00                	mov    (%eax),%eax
+  102ec9:	eb 30                	jmp    102efb <getint+0x4d>
+    }
+    else if (lflag) {
+  102ecb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
+  102ecf:	74 16                	je     102ee7 <getint+0x39>
+        return va_arg(*ap, long);
+  102ed1:	8b 45 08             	mov    0x8(%ebp),%eax
+  102ed4:	8b 00                	mov    (%eax),%eax
+  102ed6:	8d 48 04             	lea    0x4(%eax),%ecx
+  102ed9:	8b 55 08             	mov    0x8(%ebp),%edx
+  102edc:	89 0a                	mov    %ecx,(%edx)
+  102ede:	8b 00                	mov    (%eax),%eax
+  102ee0:	89 c2                	mov    %eax,%edx
+  102ee2:	c1 fa 1f             	sar    $0x1f,%edx
+  102ee5:	eb 14                	jmp    102efb <getint+0x4d>
+    }
+    else {
+        return va_arg(*ap, int);
+  102ee7:	8b 45 08             	mov    0x8(%ebp),%eax
+  102eea:	8b 00                	mov    (%eax),%eax
+  102eec:	8d 48 04             	lea    0x4(%eax),%ecx
+  102eef:	8b 55 08             	mov    0x8(%ebp),%edx
+  102ef2:	89 0a                	mov    %ecx,(%edx)
+  102ef4:	8b 00                	mov    (%eax),%eax
+  102ef6:	89 c2                	mov    %eax,%edx
+  102ef8:	c1 fa 1f             	sar    $0x1f,%edx
+    }
+}
+  102efb:	5d                   	pop    %ebp
+  102efc:	c3                   	ret    
+
+00102efd <printfmt>:
+ * @putch:        specified putch function, print a single character
+ * @putdat:        used by @putch function
+ * @fmt:        the format string to use
+ * */
+void
+printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...) {
+  102efd:	55                   	push   %ebp
+  102efe:	89 e5                	mov    %esp,%ebp
+  102f00:	83 ec 28             	sub    $0x28,%esp
+    va_list ap;
+
+    va_start(ap, fmt);
+  102f03:	8d 45 14             	lea    0x14(%ebp),%eax
+  102f06:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    vprintfmt(putch, putdat, fmt, ap);
+  102f09:	8b 45 f4             	mov    -0xc(%ebp),%eax
+  102f0c:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  102f10:	8b 45 10             	mov    0x10(%ebp),%eax
+  102f13:	89 44 24 08          	mov    %eax,0x8(%esp)
+  102f17:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102f1a:	89 44 24 04          	mov    %eax,0x4(%esp)
+  102f1e:	8b 45 08             	mov    0x8(%ebp),%eax
+  102f21:	89 04 24             	mov    %eax,(%esp)
+  102f24:	e8 02 00 00 00       	call   102f2b <vprintfmt>
+    va_end(ap);
+}
+  102f29:	c9                   	leave  
+  102f2a:	c3                   	ret    
+
+00102f2b <vprintfmt>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want printfmt() instead.
+ * */
+void
+vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap) {
+  102f2b:	55                   	push   %ebp
+  102f2c:	89 e5                	mov    %esp,%ebp
+  102f2e:	56                   	push   %esi
+  102f2f:	53                   	push   %ebx
+  102f30:	83 ec 40             	sub    $0x40,%esp
+    register int ch, err;
+    unsigned long long num;
+    int base, width, precision, lflag, altflag;
+
+    while (1) {
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  102f33:	eb 17                	jmp    102f4c <vprintfmt+0x21>
+            if (ch == '\0') {
+  102f35:	85 db                	test   %ebx,%ebx
+  102f37:	0f 84 db 03 00 00    	je     103318 <vprintfmt+0x3ed>
+                return;
+            }
+            putch(ch, putdat);
+  102f3d:	8b 45 0c             	mov    0xc(%ebp),%eax
+  102f40:	89 44 24 04          	mov    %eax,0x4(%esp)
+  102f44:	89 1c 24             	mov    %ebx,(%esp)
+  102f47:	8b 45 08             	mov    0x8(%ebp),%eax
+  102f4a:	ff d0                	call   *%eax
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  102f4c:	8b 45 10             	mov    0x10(%ebp),%eax
+  102f4f:	0f b6 00             	movzbl (%eax),%eax
+  102f52:	0f b6 d8             	movzbl %al,%ebx
+  102f55:	83 fb 25             	cmp    $0x25,%ebx
+  102f58:	0f 95 c0             	setne  %al
+  102f5b:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+  102f5f:	84 c0                	test   %al,%al
+  102f61:	75 d2                	jne    102f35 <vprintfmt+0xa>
+        }
+
+        // Process a %-escape sequence
+        char padc = ' ';
+  102f63:	c6 45 db 20          	movb   $0x20,-0x25(%ebp)
+        width = precision = -1;
+  102f67:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+  102f6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  102f71:	89 45 e8             	mov    %eax,-0x18(%ebp)
+        lflag = altflag = 0;
+  102f74:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
+  102f7b:	8b 45 dc             	mov    -0x24(%ebp),%eax
+  102f7e:	89 45 e0             	mov    %eax,-0x20(%ebp)
+  102f81:	eb 04                	jmp    102f87 <vprintfmt+0x5c>
+            goto process_precision;
+
+        case '.':
+            if (width < 0)
+                width = 0;
+            goto reswitch;
+  102f83:	90                   	nop
+  102f84:	eb 01                	jmp    102f87 <vprintfmt+0x5c>
+            goto reswitch;
+
+        process_precision:
+            if (width < 0)
+                width = precision, precision = -1;
+            goto reswitch;
+  102f86:	90                   	nop
+        switch (ch = *(unsigned char *)fmt ++) {
+  102f87:	8b 45 10             	mov    0x10(%ebp),%eax
+  102f8a:	0f b6 00             	movzbl (%eax),%eax
+  102f8d:	0f b6 d8             	movzbl %al,%ebx
+  102f90:	89 d8                	mov    %ebx,%eax
+  102f92:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+  102f96:	83 e8 23             	sub    $0x23,%eax
+  102f99:	83 f8 55             	cmp    $0x55,%eax
+  102f9c:	0f 87 45 03 00 00    	ja     1032e7 <vprintfmt+0x3bc>
+  102fa2:	8b 04 85 d4 3b 10 00 	mov    0x103bd4(,%eax,4),%eax
+  102fa9:	ff e0                	jmp    *%eax
+            padc = '-';
+  102fab:	c6 45 db 2d          	movb   $0x2d,-0x25(%ebp)
+            goto reswitch;
+  102faf:	eb d6                	jmp    102f87 <vprintfmt+0x5c>
+            padc = '0';
+  102fb1:	c6 45 db 30          	movb   $0x30,-0x25(%ebp)
+            goto reswitch;
+  102fb5:	eb d0                	jmp    102f87 <vprintfmt+0x5c>
+            for (precision = 0; ; ++ fmt) {
+  102fb7:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
+                precision = precision * 10 + ch - '0';
+  102fbe:	8b 55 e4             	mov    -0x1c(%ebp),%edx
+  102fc1:	89 d0                	mov    %edx,%eax
+  102fc3:	c1 e0 02             	shl    $0x2,%eax
+  102fc6:	01 d0                	add    %edx,%eax
+  102fc8:	01 c0                	add    %eax,%eax
+  102fca:	01 d8                	add    %ebx,%eax
+  102fcc:	83 e8 30             	sub    $0x30,%eax
+  102fcf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+                ch = *fmt;
+  102fd2:	8b 45 10             	mov    0x10(%ebp),%eax
+  102fd5:	0f b6 00             	movzbl (%eax),%eax
+  102fd8:	0f be d8             	movsbl %al,%ebx
+                if (ch < '0' || ch > '9') {
+  102fdb:	83 fb 2f             	cmp    $0x2f,%ebx
+  102fde:	7e 39                	jle    103019 <vprintfmt+0xee>
+  102fe0:	83 fb 39             	cmp    $0x39,%ebx
+  102fe3:	7f 34                	jg     103019 <vprintfmt+0xee>
+            for (precision = 0; ; ++ fmt) {
+  102fe5:	83 45 10 01          	addl   $0x1,0x10(%ebp)
+            }
+  102fe9:	eb d3                	jmp    102fbe <vprintfmt+0x93>
+            precision = va_arg(ap, int);
+  102feb:	8b 45 14             	mov    0x14(%ebp),%eax
+  102fee:	8d 50 04             	lea    0x4(%eax),%edx
+  102ff1:	89 55 14             	mov    %edx,0x14(%ebp)
+  102ff4:	8b 00                	mov    (%eax),%eax
+  102ff6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
+            goto process_precision;
+  102ff9:	eb 1f                	jmp    10301a <vprintfmt+0xef>
+            if (width < 0)
+  102ffb:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  102fff:	79 82                	jns    102f83 <vprintfmt+0x58>
+                width = 0;
+  103001:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
+            goto reswitch;
+  103008:	e9 76 ff ff ff       	jmp    102f83 <vprintfmt+0x58>
+            altflag = 1;
+  10300d:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
+            goto reswitch;
+  103014:	e9 6e ff ff ff       	jmp    102f87 <vprintfmt+0x5c>
+            goto process_precision;
+  103019:	90                   	nop
+            if (width < 0)
+  10301a:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  10301e:	0f 89 62 ff ff ff    	jns    102f86 <vprintfmt+0x5b>
+                width = precision, precision = -1;
+  103024:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  103027:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  10302a:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
+            goto reswitch;
+  103031:	e9 50 ff ff ff       	jmp    102f86 <vprintfmt+0x5b>
+
+        // long flag (doubled for long long)
+        case 'l':
+            lflag ++;
+  103036:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
+            goto reswitch;
+  10303a:	e9 48 ff ff ff       	jmp    102f87 <vprintfmt+0x5c>
+
+        // character
+        case 'c':
+            putch(va_arg(ap, int), putdat);
+  10303f:	8b 45 14             	mov    0x14(%ebp),%eax
+  103042:	8d 50 04             	lea    0x4(%eax),%edx
+  103045:	89 55 14             	mov    %edx,0x14(%ebp)
+  103048:	8b 00                	mov    (%eax),%eax
+  10304a:	8b 55 0c             	mov    0xc(%ebp),%edx
+  10304d:	89 54 24 04          	mov    %edx,0x4(%esp)
+  103051:	89 04 24             	mov    %eax,(%esp)
+  103054:	8b 45 08             	mov    0x8(%ebp),%eax
+  103057:	ff d0                	call   *%eax
+            break;
+  103059:	e9 b4 02 00 00       	jmp    103312 <vprintfmt+0x3e7>
+
+        // error message
+        case 'e':
+            err = va_arg(ap, int);
+  10305e:	8b 45 14             	mov    0x14(%ebp),%eax
+  103061:	8d 50 04             	lea    0x4(%eax),%edx
+  103064:	89 55 14             	mov    %edx,0x14(%ebp)
+  103067:	8b 18                	mov    (%eax),%ebx
+            if (err < 0) {
+  103069:	85 db                	test   %ebx,%ebx
+  10306b:	79 02                	jns    10306f <vprintfmt+0x144>
+                err = -err;
+  10306d:	f7 db                	neg    %ebx
+            }
+            if (err > MAXERROR || (p = error_string[err]) == NULL) {
+  10306f:	83 fb 06             	cmp    $0x6,%ebx
+  103072:	7f 0b                	jg     10307f <vprintfmt+0x154>
+  103074:	8b 34 9d 94 3b 10 00 	mov    0x103b94(,%ebx,4),%esi
+  10307b:	85 f6                	test   %esi,%esi
+  10307d:	75 23                	jne    1030a2 <vprintfmt+0x177>
+                printfmt(putch, putdat, "error %d", err);
+  10307f:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
+  103083:	c7 44 24 08 c1 3b 10 	movl   $0x103bc1,0x8(%esp)
+  10308a:	00 
+  10308b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10308e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  103092:	8b 45 08             	mov    0x8(%ebp),%eax
+  103095:	89 04 24             	mov    %eax,(%esp)
+  103098:	e8 60 fe ff ff       	call   102efd <printfmt>
+            }
+            else {
+                printfmt(putch, putdat, "%s", p);
+            }
+            break;
+  10309d:	e9 70 02 00 00       	jmp    103312 <vprintfmt+0x3e7>
+                printfmt(putch, putdat, "%s", p);
+  1030a2:	89 74 24 0c          	mov    %esi,0xc(%esp)
+  1030a6:	c7 44 24 08 ca 3b 10 	movl   $0x103bca,0x8(%esp)
+  1030ad:	00 
+  1030ae:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1030b1:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1030b5:	8b 45 08             	mov    0x8(%ebp),%eax
+  1030b8:	89 04 24             	mov    %eax,(%esp)
+  1030bb:	e8 3d fe ff ff       	call   102efd <printfmt>
+            break;
+  1030c0:	e9 4d 02 00 00       	jmp    103312 <vprintfmt+0x3e7>
+
+        // string
+        case 's':
+            if ((p = va_arg(ap, char *)) == NULL) {
+  1030c5:	8b 45 14             	mov    0x14(%ebp),%eax
+  1030c8:	8d 50 04             	lea    0x4(%eax),%edx
+  1030cb:	89 55 14             	mov    %edx,0x14(%ebp)
+  1030ce:	8b 30                	mov    (%eax),%esi
+  1030d0:	85 f6                	test   %esi,%esi
+  1030d2:	75 05                	jne    1030d9 <vprintfmt+0x1ae>
+                p = "(null)";
+  1030d4:	be cd 3b 10 00       	mov    $0x103bcd,%esi
+            }
+            if (width > 0 && padc != '-') {
+  1030d9:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  1030dd:	7e 7c                	jle    10315b <vprintfmt+0x230>
+  1030df:	80 7d db 2d          	cmpb   $0x2d,-0x25(%ebp)
+  1030e3:	74 76                	je     10315b <vprintfmt+0x230>
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  1030e5:	8b 5d e8             	mov    -0x18(%ebp),%ebx
+  1030e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
+  1030eb:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1030ef:	89 34 24             	mov    %esi,(%esp)
+  1030f2:	e8 61 f7 ff ff       	call   102858 <strnlen>
+  1030f7:	89 da                	mov    %ebx,%edx
+  1030f9:	29 c2                	sub    %eax,%edx
+  1030fb:	89 d0                	mov    %edx,%eax
+  1030fd:	89 45 e8             	mov    %eax,-0x18(%ebp)
+  103100:	eb 17                	jmp    103119 <vprintfmt+0x1ee>
+                    putch(padc, putdat);
+  103102:	0f be 45 db          	movsbl -0x25(%ebp),%eax
+  103106:	8b 55 0c             	mov    0xc(%ebp),%edx
+  103109:	89 54 24 04          	mov    %edx,0x4(%esp)
+  10310d:	89 04 24             	mov    %eax,(%esp)
+  103110:	8b 45 08             	mov    0x8(%ebp),%eax
+  103113:	ff d0                	call   *%eax
+                for (width -= strnlen(p, precision); width > 0; width --) {
+  103115:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  103119:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  10311d:	7f e3                	jg     103102 <vprintfmt+0x1d7>
+                }
+            }
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  10311f:	eb 3a                	jmp    10315b <vprintfmt+0x230>
+                if (altflag && (ch < ' ' || ch > '~')) {
+  103121:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
+  103125:	74 1f                	je     103146 <vprintfmt+0x21b>
+  103127:	83 fb 1f             	cmp    $0x1f,%ebx
+  10312a:	7e 05                	jle    103131 <vprintfmt+0x206>
+  10312c:	83 fb 7e             	cmp    $0x7e,%ebx
+  10312f:	7e 15                	jle    103146 <vprintfmt+0x21b>
+                    putch('?', putdat);
+  103131:	8b 45 0c             	mov    0xc(%ebp),%eax
+  103134:	89 44 24 04          	mov    %eax,0x4(%esp)
+  103138:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
+  10313f:	8b 45 08             	mov    0x8(%ebp),%eax
+  103142:	ff d0                	call   *%eax
+  103144:	eb 0f                	jmp    103155 <vprintfmt+0x22a>
+                }
+                else {
+                    putch(ch, putdat);
+  103146:	8b 45 0c             	mov    0xc(%ebp),%eax
+  103149:	89 44 24 04          	mov    %eax,0x4(%esp)
+  10314d:	89 1c 24             	mov    %ebx,(%esp)
+  103150:	8b 45 08             	mov    0x8(%ebp),%eax
+  103153:	ff d0                	call   *%eax
+            for (; (ch = *p ++) != '\0' && (precision < 0 || -- precision >= 0); width --) {
+  103155:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  103159:	eb 01                	jmp    10315c <vprintfmt+0x231>
+  10315b:	90                   	nop
+  10315c:	0f b6 06             	movzbl (%esi),%eax
+  10315f:	0f be d8             	movsbl %al,%ebx
+  103162:	85 db                	test   %ebx,%ebx
+  103164:	0f 95 c0             	setne  %al
+  103167:	83 c6 01             	add    $0x1,%esi
+  10316a:	84 c0                	test   %al,%al
+  10316c:	74 29                	je     103197 <vprintfmt+0x26c>
+  10316e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  103172:	78 ad                	js     103121 <vprintfmt+0x1f6>
+  103174:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
+  103178:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
+  10317c:	79 a3                	jns    103121 <vprintfmt+0x1f6>
+                }
+            }
+            for (; width > 0; width --) {
+  10317e:	eb 17                	jmp    103197 <vprintfmt+0x26c>
+                putch(' ', putdat);
+  103180:	8b 45 0c             	mov    0xc(%ebp),%eax
+  103183:	89 44 24 04          	mov    %eax,0x4(%esp)
+  103187:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
+  10318e:	8b 45 08             	mov    0x8(%ebp),%eax
+  103191:	ff d0                	call   *%eax
+            for (; width > 0; width --) {
+  103193:	83 6d e8 01          	subl   $0x1,-0x18(%ebp)
+  103197:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
+  10319b:	7f e3                	jg     103180 <vprintfmt+0x255>
+            }
+            break;
+  10319d:	e9 70 01 00 00       	jmp    103312 <vprintfmt+0x3e7>
+
+        // (signed) decimal
+        case 'd':
+            num = getint(&ap, lflag);
+  1031a2:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  1031a5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1031a9:	8d 45 14             	lea    0x14(%ebp),%eax
+  1031ac:	89 04 24             	mov    %eax,(%esp)
+  1031af:	e8 fa fc ff ff       	call   102eae <getint>
+  1031b4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  1031b7:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            if ((long long)num < 0) {
+  1031ba:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1031bd:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  1031c0:	85 d2                	test   %edx,%edx
+  1031c2:	79 26                	jns    1031ea <vprintfmt+0x2bf>
+                putch('-', putdat);
+  1031c4:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1031c7:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1031cb:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
+  1031d2:	8b 45 08             	mov    0x8(%ebp),%eax
+  1031d5:	ff d0                	call   *%eax
+                num = -(long long)num;
+  1031d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1031da:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  1031dd:	f7 d8                	neg    %eax
+  1031df:	83 d2 00             	adc    $0x0,%edx
+  1031e2:	f7 da                	neg    %edx
+  1031e4:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  1031e7:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            }
+            base = 10;
+  1031ea:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  1031f1:	e9 a8 00 00 00       	jmp    10329e <vprintfmt+0x373>
+
+        // unsigned decimal
+        case 'u':
+            num = getuint(&ap, lflag);
+  1031f6:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  1031f9:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1031fd:	8d 45 14             	lea    0x14(%ebp),%eax
+  103200:	89 04 24             	mov    %eax,(%esp)
+  103203:	e8 57 fc ff ff       	call   102e5f <getuint>
+  103208:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  10320b:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 10;
+  10320e:	c7 45 ec 0a 00 00 00 	movl   $0xa,-0x14(%ebp)
+            goto number;
+  103215:	e9 84 00 00 00       	jmp    10329e <vprintfmt+0x373>
+
+        // (unsigned) octal
+        case 'o':
+            num = getuint(&ap, lflag);
+  10321a:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  10321d:	89 44 24 04          	mov    %eax,0x4(%esp)
+  103221:	8d 45 14             	lea    0x14(%ebp),%eax
+  103224:	89 04 24             	mov    %eax,(%esp)
+  103227:	e8 33 fc ff ff       	call   102e5f <getuint>
+  10322c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  10322f:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 8;
+  103232:	c7 45 ec 08 00 00 00 	movl   $0x8,-0x14(%ebp)
+            goto number;
+  103239:	eb 63                	jmp    10329e <vprintfmt+0x373>
+
+        // pointer
+        case 'p':
+            putch('0', putdat);
+  10323b:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10323e:	89 44 24 04          	mov    %eax,0x4(%esp)
+  103242:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
+  103249:	8b 45 08             	mov    0x8(%ebp),%eax
+  10324c:	ff d0                	call   *%eax
+            putch('x', putdat);
+  10324e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  103251:	89 44 24 04          	mov    %eax,0x4(%esp)
+  103255:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
+  10325c:	8b 45 08             	mov    0x8(%ebp),%eax
+  10325f:	ff d0                	call   *%eax
+            num = (unsigned long long)(uintptr_t)va_arg(ap, void *);
+  103261:	8b 45 14             	mov    0x14(%ebp),%eax
+  103264:	8d 50 04             	lea    0x4(%eax),%edx
+  103267:	89 55 14             	mov    %edx,0x14(%ebp)
+  10326a:	8b 00                	mov    (%eax),%eax
+  10326c:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  10326f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+            base = 16;
+  103276:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+            goto number;
+  10327d:	eb 1f                	jmp    10329e <vprintfmt+0x373>
+
+        // (unsigned) hexadecimal
+        case 'x':
+            num = getuint(&ap, lflag);
+  10327f:	8b 45 e0             	mov    -0x20(%ebp),%eax
+  103282:	89 44 24 04          	mov    %eax,0x4(%esp)
+  103286:	8d 45 14             	lea    0x14(%ebp),%eax
+  103289:	89 04 24             	mov    %eax,(%esp)
+  10328c:	e8 ce fb ff ff       	call   102e5f <getuint>
+  103291:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  103294:	89 55 f4             	mov    %edx,-0xc(%ebp)
+            base = 16;
+  103297:	c7 45 ec 10 00 00 00 	movl   $0x10,-0x14(%ebp)
+        number:
+            printnum(putch, putdat, num, base, width, padc);
+  10329e:	0f be 55 db          	movsbl -0x25(%ebp),%edx
+  1032a2:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  1032a5:	89 54 24 18          	mov    %edx,0x18(%esp)
+  1032a9:	8b 55 e8             	mov    -0x18(%ebp),%edx
+  1032ac:	89 54 24 14          	mov    %edx,0x14(%esp)
+  1032b0:	89 44 24 10          	mov    %eax,0x10(%esp)
+  1032b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1032b7:	8b 55 f4             	mov    -0xc(%ebp),%edx
+  1032ba:	89 44 24 08          	mov    %eax,0x8(%esp)
+  1032be:	89 54 24 0c          	mov    %edx,0xc(%esp)
+  1032c2:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1032c5:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1032c9:	8b 45 08             	mov    0x8(%ebp),%eax
+  1032cc:	89 04 24             	mov    %eax,(%esp)
+  1032cf:	e8 53 fa ff ff       	call   102d27 <printnum>
+            break;
+  1032d4:	eb 3c                	jmp    103312 <vprintfmt+0x3e7>
+
+        // escaped '%' character
+        case '%':
+            putch(ch, putdat);
+  1032d6:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1032d9:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1032dd:	89 1c 24             	mov    %ebx,(%esp)
+  1032e0:	8b 45 08             	mov    0x8(%ebp),%eax
+  1032e3:	ff d0                	call   *%eax
+            break;
+  1032e5:	eb 2b                	jmp    103312 <vprintfmt+0x3e7>
+
+        // unrecognized escape sequence - just print it literally
+        default:
+            putch('%', putdat);
+  1032e7:	8b 45 0c             	mov    0xc(%ebp),%eax
+  1032ea:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1032ee:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
+  1032f5:	8b 45 08             	mov    0x8(%ebp),%eax
+  1032f8:	ff d0                	call   *%eax
+            for (fmt --; fmt[-1] != '%'; fmt --)
+  1032fa:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  1032fe:	eb 04                	jmp    103304 <vprintfmt+0x3d9>
+  103300:	83 6d 10 01          	subl   $0x1,0x10(%ebp)
+  103304:	8b 45 10             	mov    0x10(%ebp),%eax
+  103307:	83 e8 01             	sub    $0x1,%eax
+  10330a:	0f b6 00             	movzbl (%eax),%eax
+  10330d:	3c 25                	cmp    $0x25,%al
+  10330f:	75 ef                	jne    103300 <vprintfmt+0x3d5>
+                /* do nothing */;
+            break;
+  103311:	90                   	nop
+        }
+    }
+  103312:	90                   	nop
+        while ((ch = *(unsigned char *)fmt ++) != '%') {
+  103313:	e9 34 fc ff ff       	jmp    102f4c <vprintfmt+0x21>
+                return;
+  103318:	90                   	nop
+}
+  103319:	83 c4 40             	add    $0x40,%esp
+  10331c:	5b                   	pop    %ebx
+  10331d:	5e                   	pop    %esi
+  10331e:	5d                   	pop    %ebp
+  10331f:	c3                   	ret    
+
+00103320 <sprintputch>:
+ * sprintputch - 'print' a single character in a buffer
+ * @ch:            the character will be printed
+ * @b:            the buffer to place the character @ch
+ * */
+static void
+sprintputch(int ch, struct sprintbuf *b) {
+  103320:	55                   	push   %ebp
+  103321:	89 e5                	mov    %esp,%ebp
+    b->cnt ++;
+  103323:	8b 45 0c             	mov    0xc(%ebp),%eax
+  103326:	8b 40 08             	mov    0x8(%eax),%eax
+  103329:	8d 50 01             	lea    0x1(%eax),%edx
+  10332c:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10332f:	89 50 08             	mov    %edx,0x8(%eax)
+    if (b->buf < b->ebuf) {
+  103332:	8b 45 0c             	mov    0xc(%ebp),%eax
+  103335:	8b 10                	mov    (%eax),%edx
+  103337:	8b 45 0c             	mov    0xc(%ebp),%eax
+  10333a:	8b 40 04             	mov    0x4(%eax),%eax
+  10333d:	39 c2                	cmp    %eax,%edx
+  10333f:	73 12                	jae    103353 <sprintputch+0x33>
+        *b->buf ++ = ch;
+  103341:	8b 45 0c             	mov    0xc(%ebp),%eax
+  103344:	8b 00                	mov    (%eax),%eax
+  103346:	8b 55 08             	mov    0x8(%ebp),%edx
+  103349:	88 10                	mov    %dl,(%eax)
+  10334b:	8d 50 01             	lea    0x1(%eax),%edx
+  10334e:	8b 45 0c             	mov    0xc(%ebp),%eax
+  103351:	89 10                	mov    %edx,(%eax)
+    }
+}
+  103353:	5d                   	pop    %ebp
+  103354:	c3                   	ret    
+
+00103355 <snprintf>:
+ * @str:        the buffer to place the result into
+ * @size:        the size of buffer, including the trailing null space
+ * @fmt:        the format string to use
+ * */
+int
+snprintf(char *str, size_t size, const char *fmt, ...) {
+  103355:	55                   	push   %ebp
+  103356:	89 e5                	mov    %esp,%ebp
+  103358:	83 ec 28             	sub    $0x28,%esp
+    va_list ap;
+    int cnt;
+    va_start(ap, fmt);
+  10335b:	8d 45 14             	lea    0x14(%ebp),%eax
+  10335e:	89 45 f0             	mov    %eax,-0x10(%ebp)
+    cnt = vsnprintf(str, size, fmt, ap);
+  103361:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  103364:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  103368:	8b 45 10             	mov    0x10(%ebp),%eax
+  10336b:	89 44 24 08          	mov    %eax,0x8(%esp)
+  10336f:	8b 45 0c             	mov    0xc(%ebp),%eax
+  103372:	89 44 24 04          	mov    %eax,0x4(%esp)
+  103376:	8b 45 08             	mov    0x8(%ebp),%eax
+  103379:	89 04 24             	mov    %eax,(%esp)
+  10337c:	e8 08 00 00 00       	call   103389 <vsnprintf>
+  103381:	89 45 f4             	mov    %eax,-0xc(%ebp)
+    va_end(ap);
+    return cnt;
+  103384:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  103387:	c9                   	leave  
+  103388:	c3                   	ret    
+
+00103389 <vsnprintf>:
+ *
+ * Call this function if you are already dealing with a va_list.
+ * Or you probably want snprintf() instead.
+ * */
+int
+vsnprintf(char *str, size_t size, const char *fmt, va_list ap) {
+  103389:	55                   	push   %ebp
+  10338a:	89 e5                	mov    %esp,%ebp
+  10338c:	83 ec 28             	sub    $0x28,%esp
+    struct sprintbuf b = {str, str + size - 1, 0};
+  10338f:	8b 45 08             	mov    0x8(%ebp),%eax
+  103392:	89 45 ec             	mov    %eax,-0x14(%ebp)
+  103395:	8b 45 0c             	mov    0xc(%ebp),%eax
+  103398:	8d 50 ff             	lea    -0x1(%eax),%edx
+  10339b:	8b 45 08             	mov    0x8(%ebp),%eax
+  10339e:	01 d0                	add    %edx,%eax
+  1033a0:	89 45 f0             	mov    %eax,-0x10(%ebp)
+  1033a3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
+    if (str == NULL || b.buf > b.ebuf) {
+  1033aa:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
+  1033ae:	74 0a                	je     1033ba <vsnprintf+0x31>
+  1033b0:	8b 55 ec             	mov    -0x14(%ebp),%edx
+  1033b3:	8b 45 f0             	mov    -0x10(%ebp),%eax
+  1033b6:	39 c2                	cmp    %eax,%edx
+  1033b8:	76 07                	jbe    1033c1 <vsnprintf+0x38>
+        return -E_INVAL;
+  1033ba:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
+  1033bf:	eb 2a                	jmp    1033eb <vsnprintf+0x62>
+    }
+    // print the string to the buffer
+    vprintfmt((void*)sprintputch, &b, fmt, ap);
+  1033c1:	8b 45 14             	mov    0x14(%ebp),%eax
+  1033c4:	89 44 24 0c          	mov    %eax,0xc(%esp)
+  1033c8:	8b 45 10             	mov    0x10(%ebp),%eax
+  1033cb:	89 44 24 08          	mov    %eax,0x8(%esp)
+  1033cf:	8d 45 ec             	lea    -0x14(%ebp),%eax
+  1033d2:	89 44 24 04          	mov    %eax,0x4(%esp)
+  1033d6:	c7 04 24 20 33 10 00 	movl   $0x103320,(%esp)
+  1033dd:	e8 49 fb ff ff       	call   102f2b <vprintfmt>
+    // null terminate the buffer
+    *b.buf = '\0';
+  1033e2:	8b 45 ec             	mov    -0x14(%ebp),%eax
+  1033e5:	c6 00 00             	movb   $0x0,(%eax)
+    return b.cnt;
+  1033e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
+}
+  1033eb:	c9                   	leave  
+  1033ec:	c3                   	ret    
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kernel.sym ./obj/kernel.sym
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/kernel.sym	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/kernel.sym	2022-10-09 19:34:01.735314415 +0800
@@ -0,0 +1,401 @@
+00100000 .text
+00103400 .rodata
+00103d2c .stab
+0010b395 .stabstr
+0010e000 .data
+0010ea20 .bss
+00000000 .comment
+00000000 init.c
+00100102 lab1_print_cur_status
+0010ea20 round.1120
+001001c8 lab1_switch_to_user
+001001cd lab1_switch_to_kernel
+001001d2 lab1_switch_test
+00000000 stdio.c
+0010020b cputch
+00000000 readline.c
+0010ea40 buf
+00000000 panic.c
+0010ee40 is_panic
+00000000 kdebug.c
+00100489 stab_binsearch
+00100a62 read_eip
+00000000 kmonitor.c
+0010e000 commands
+00100b0b parse
+00100bc2 runcmd
+00000000 clock.c
+00000000 console.c
+00100db8 delay
+0010ee60 crt_buf
+0010ee64 crt_pos
+0010ee66 addr_6845
+00100e25 cga_init
+0010ee68 serial_exists
+00100f20 serial_init
+00101020 lpt_putc_sub
+001010a6 lpt_putc
+001010e5 cga_putc
+001012bd serial_putc_sub
+00101323 serial_putc
+0010ee80 cons
+00101362 cons_intr
+001013ac serial_proc_data
+0010e040 shiftcode
+0010e140 togglecode
+0010e240 normalmap
+0010e340 shiftmap
+0010e440 ctlmap
+0010e540 charcode
+00101435 kbd_proc_data
+0010f088 shift.1237
+001015d3 kbd_intr
+001015e7 kbd_init
+00000000 picirq.c
+0010e550 irq_mask
+0010f08c did_init
+001016b0 pic_setmask
+00000000 intr.c
+00000000 trap.c
+00101884 print_ticks
+0010f0a0 idt
+0010e560 idt_pd
+001018a5 trapname
+00103ae0 excnames.1210
+0010e580 IA32flags
+00101b68 trap_dispatch
+00000000 pmm.c
+0010f8a0 ts
+0010e9e0 gdt
+0010ea10 gdt_pd
+001026ee lgdt
+00102723 gdt_init
+00000000 string.c
+00000000 printfmt.c
+00103b94 error_string
+00102d27 printnum
+00102e5f getuint
+00102eae getint
+00103320 sprintputch
+00102624 vector242
+0010207b vector119
+00100927 print_kerninfo
+00101f5b vector87
+00101f52 vector86
+00102690 vector251
+0010288b strcpy
+00101f7f vector91
+00101d75 vector33
+00102264 vector162
+001024c8 vector213
+00102018 vector108
+00101dcf vector43
+00100d43 mon_backtrace
+00102288 vector165
+00102378 vector185
+00102057 vector115
+00102096 vector122
+0010221c vector156
+00102648 vector245
+001023a8 vector189
+00101c99 vector7
+00101e71 vector61
+00101d24 vector24
+00102033 vector111
+0010242c vector200
+00101ea7 vector67
+00102144 vector138
+00101ee6 vector74
+00102bb7 memmove
+00101e4d vector57
+00103355 snprintf
+001018ec print_trapframe
+001024d4 vector214
+00102f2b vprintfmt
+00101fc7 vector99
+001026cc __alltraps
+00101655 cons_getc
+00102168 vector141
+0010047f is_kernel_panic
+001022dc vector172
+00100a78 print_stackframe
+00102618 vector241
+001026a8 vector253
+00101c75 vector3
+00101c6c vector2
+00102570 vector227
+001024a4 vector210
+0010254c vector224
+00101dbd vector41
+0010025e cprintf
+00101d09 vector21
+00102318 vector177
+00102072 vector118
+00101ec2 vector70
+00101eb9 vector69
+001025e8 vector237
+00101e8c vector64
+00101d3f vector27
+001020fc vector132
+00102384 vector186
+001024f8 vector217
+00102c6e memcpy
+00101c63 vector1
+00102324 vector178
+00101da2 vector38
+001025f4 vector238
+00100302 readline
+00102108 vector133
+00101edd vector73
+0010218c vector144
+00100000 kern_init
+001026b4 vector254
+00101fd9 vector101
+001024b0 vector211
+001022f4 vector174
+00102630 vector243
+001020cc vector128
+00101f25 vector81
+00101cc7 vector13
+00103389 vsnprintf
+00101e17 vector51
+00101cde vector16
+0010ea16 edata
+00101600 cons_init
+0010260c vector240
+00101e32 vector54
+00101cf7 vector19
+0010b394 __STAB_END__
+00101f88 vector92
+0010263c vector244
+0010215c vector140
+00101de1 vector45
+00101f13 vector79
+00102588 vector229
+00102234 vector158
+00101708 pic_enable
+00101dab vector39
+001022ac vector168
+00101d87 vector35
+00102045 vector113
+0010b395 __STABSTR_BEGIN__
+001020b1 vector125
+001003bb __panic
+001024ec vector216
+00101e83 vector63
+00101d36 vector26
+00101418 serial_intr
+001023d8 vector193
+001023fc vector196
+001000c3 grade_backtrace0
+00102498 vector209
+00101c7e vector4
+001022c4 vector170
+0010212c vector136
+00101cb2 vector10
+00102474 vector206
+0010f920 stack0
+001026c0 vector255
+00102348 vector181
+00101e5f vector59
+001000dd grade_backtrace
+00101f49 vector85
+00101f40 vector84
+00102360 vector183
+00102240 vector159
+001024bc vector212
+00101df3 vector47
+00102a0f strtol
+0010257c vector228
+00101dc6 vector42
+0010204e vector114
+00102858 strnlen
+00102300 vector175
+00102180 vector143
+001020e4 vector130
+00102654 vector246
+00101ca9 vector9
+00102174 vector142
+00101fd0 vector100
+00102438 vector201
+001018a0 idt_init
+001009bf print_debuginfo
+00101e68 vector60
+00101d1b vector23
+001025dc vector236
+001025a0 vector231
+00101e9e vector66
+00101d51 vector29
+00102120 vector135
+00100c74 kmonitor
+00101f01 vector77
+0010233c vector180
+00100d55 clock_init
+0010248c vector208
+00101fbe vector98
+00101fb5 vector97
+0010230c vector176
+001023e4 vector194
+00101d6c vector32
+0010fd20 end
+00102420 vector199
+001020f0 vector131
+0010269c vector252
+00101c5a vector0
+001029e0 strfind
+0010162c cons_putc
+001033ed etext
+00102198 vector145
+0010200f vector107
+00101db4 vector40
+00101878 intr_enable
+00101fe2 vector102
+00101e44 vector56
+00101eb0 vector68
+00101c90 vector6
+001020d8 vector129
+00102408 vector197
+001021ec vector152
+0010e5e0 __vectors
+00102594 vector230
+00102955 strncmp
+00101d99 vector37
+00102468 vector205
+00102258 vector161
+001028ce strncpy
+00101ecb vector71
+0010224c vector160
+001024e0 vector215
+00102228 vector157
+0010187e intr_disable
+00101ab1 print_regs
+0010203c vector112
+00100072 grade_backtrace2
+00102354 vector182
+00101cc0 vector12
+00102ccb memcmp
+00102021 vector109
+00101d00 vector20
+00101e29 vector53
+00101cee vector18
+00101fa3 vector95
+00102564 vector226
+00101e05 vector49
+00101dd8 vector44
+00101f0a vector78
+001022e8 vector173
+00102069 vector117
+001018d6 trap_in_kernel
+00101f2e vector82
+00102534 vector222
+00101ca2 vector8
+001021c8 vector149
+00100284 cputchar
+00102b6c memset
+001025ac vector232
+00102006 vector106
+0010251c vector220
+00101f76 vector90
+00102270 vector163
+001025c4 vector234
+00101e7a vector62
+00101d2d vector25
+00102414 vector198
+00102084 vector120
+001002e9 getchar
+00101e0e vector50
+00101cd5 vector15
+00102efd printfmt
+001021e0 vector151
+00101f37 vector83
+00101f6d vector89
+00101f64 vector88
+00101c47 trap
+00102330 vector179
+00101d7e vector34
+0010d335 __STABSTR_END__
+00101dea vector46
+00102908 strcmp
+00102114 vector134
+00102540 vector223
+00102504 vector218
+001005df debuginfo_eip
+0010173d pic_init
+00102558 vector225
+00102390 vector187
+00102823 pmm_init
+00101d5a vector30
+001020c3 vector127
+0010f908 ticks
+001023cc vector192
+00102294 vector166
+00101ef8 vector76
+00101eef vector75
+001023f0 vector195
+001021d4 vector150
+00101e56 vector58
+0010266c vector248
+0010209f vector123
+00101fac vector96
+00101d63 vector31
+00102450 vector203
+00102150 vector139
+001021f8 vector153
+0010227c vector164
+0010208d vector121
+00101c87 vector5
+001022a0 vector167
+00102210 vector155
+00102678 vector249
+00102684 vector250
+001020a8 vector124
+0010202a vector110
+0010245c vector204
+001026e3 __trapret
+0010022b vcprintf
+00102138 vector137
+00100439 __warn
+00102660 vector247
+00101d12 vector22
+00102444 vector202
+00101ed4 vector72
+00101e3b vector55
+00100297 cputs
+001020ba vector126
+00101e95 vector65
+00101d48 vector28
+001022b8 vector169
+001025b8 vector233
+001021b0 vector147
+00101ff4 vector104
+00102060 vector116
+00103d2c __STAB_BEGIN__
+00101e20 vector52
+00101ce7 vector17
+0010236c vector184
+0010282d strlen
+00102480 vector207
+001023b4 vector190
+00102600 vector239
+00101f9a vector94
+00101f91 vector93
+0010239c vector188
+001029ad strchr
+00101dfc vector48
+00100096 grade_backtrace1
+00102510 vector219
+001021bc vector148
+00102528 vector221
+00101f1c vector80
+001022d0 vector171
+00102204 vector154
+00101d90 vector36
+001025d0 vector235
+00101ffd vector105
+00100d31 mon_kerninfo
+001021a4 vector146
+001023c0 vector191
+00101feb vector103
+00100cd4 mon_help
+00101cb9 vector11
+00101cce vector14
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/libs/printfmt.d ./obj/libs/printfmt.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/libs/printfmt.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/libs/printfmt.d	2022-10-09 18:19:16.463731540 +0800
@@ -0,0 +1,2 @@
+obj/libs/printfmt.o obj/libs/printfmt.d: libs/printfmt.c libs/defs.h \
+ libs/x86.h libs/error.h libs/stdio.h libs/stdarg.h libs/string.h
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/libs/printfmt.o and ./obj/libs/printfmt.o differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/libs/string.d ./obj/libs/string.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/libs/string.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/libs/string.d	2022-10-09 18:19:16.471731763 +0800
@@ -0,0 +1,2 @@
+obj/libs/string.o obj/libs/string.d: libs/string.c libs/string.h \
+ libs/defs.h libs/x86.h
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/libs/string.o and ./obj/libs/string.o differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/sign/tools/sign.d ./obj/sign/tools/sign.d
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/sign/tools/sign.d	1970-01-01 08:00:00.000000000 +0800
+++ ./obj/sign/tools/sign.d	2022-10-09 18:19:16.119721948 +0800
@@ -0,0 +1 @@
+obj/sign/tools/sign.o obj/sign/tools/sign.d: tools/sign.c
Binary files /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/obj/sign/tools/sign.o and ./obj/sign/tools/sign.o differ
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/.vscode/c_cpp_properties.json ./.vscode/c_cpp_properties.json
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/.vscode/c_cpp_properties.json	1970-01-01 08:00:00.000000000 +0800
+++ ./.vscode/c_cpp_properties.json	2022-10-09 18:23:58.319019048 +0800
@@ -0,0 +1,26 @@
+{
+    "configurations": [
+        {
+            "name": "Linux",
+            "includePath": [
+                "${workspaceFolder}/**",
+                "${workspaceFolder}/boot",
+                "${workspaceFolder}/kern/debug",
+                "${workspaceFolder}/kern/driver",
+                "${workspaceFolder}/kern/init",
+                "${workspaceFolder}/kern/libs",
+                "${workspaceFolder}/kern/mm",
+                "${workspaceFolder}/kern/trap",
+                "${workspaceFolder}/libs",
+                "${default}" 
+            ],
+            "defines": [],
+            "compilerPath": "/usr/bin/gcc",
+            "cStandard": "c89",
+            "cppStandard": "c++11",
+            "intelliSenseMode": "linux-gcc-x64",
+            "configurationProvider": "ms-vscode.makefile-tools"
+        }
+    ],
+    "version": 4
+}
\ No newline at end of file
