diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/boot/bootasm.S ./boot/bootasm.S
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/boot/bootasm.S	2021-03-18 17:08:00.000000000 +0800
+++ ./boot/bootasm.S	2022-10-31 20:58:41.181220149 +0800
@@ -5,16 +5,16 @@
 # memory at physical address 0x7c00 and starts executing in real mode
 # with %cs=0 %ip=7c00.
 
-.set PROT_MODE_CSEG,        0x8                     # kernel code segment selector
-.set PROT_MODE_DSEG,        0x10                    # kernel data segment selector
+.set PROT_MODE_CSEG,        0x8                     # kernel code segment selector:index=1;TI=0b0;RPL=0b00 (TI=0代表应该访问全局描述符表（GDT），TI=1代表应该访问局部描述符表（LDT）)
+.set PROT_MODE_DSEG,        0x10                    # kernel data segment selector:index=2;TI=0b0;RPL=0b00
 .set CR0_PE_ON,             0x1                     # protected mode enable flag
 
 # start address should be 0:7c00, in real mode, the beginning address of the running bootloader
 .globl start
 start:
 .code16                                             # Assemble for 16-bit mode
-    cli                                             # Disable interrupts
-    cld                                             # String operations increment
+    cli                                             # Disable interrupts，之前BIOS运行时，可能打开了中断，而后面打开A20 Gate需要给键盘端口发送指令，而且操作系统还未加载，也无法处理中断.（猜测）
+    cld                                             # String operations increment，串处理指令，例如movs,执行后指针寄存器(si, di)自增1
 
     # Set up the important data segment registers (DS, ES, SS).
     xorw %ax, %ax                                   # Segment number zero
@@ -28,9 +28,9 @@
     #  1MB wrap around to zero by default. This code undoes this.
 seta20.1:
     inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
-    testb $0x2, %al
+    testb $0x2, %al                                 # Status Register (0x64端口) 的 bit1 代表 input register (60h/64h) 有数据
     jnz seta20.1
-
+    # 向键盘输入缓冲器(0x64端口)写一个控制命令(0xd1)
     movb $0xd1, %al                                 # 0xd1 -> port 0x64
     outb %al, $0x64                                 # 0xd1 means: write data to 8042's P2 port
 
@@ -38,7 +38,7 @@
     inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).
     testb $0x2, %al
     jnz seta20.2
-
+    # 向键盘输入缓冲器(0x60端口)写入0xdf
     movb $0xdf, %al                                 # 0xdf -> port 0x60
     outb %al, $0x60                                 # 0xdf = 11011111, means set P2's A20 bit(the 1 bit) to 1
 
@@ -46,14 +46,14 @@
     # and segment translation that makes virtual addresses
     # identical to physical addresses, so that the
     # effective memory map does not change during the switch.
-    lgdt gdtdesc
-    movl %cr0, %eax
+    lgdt gdtdesc                                    # 加载全局描述符表放入GDTR寄存器
+    movl %cr0, %eax                                 # cr0寄存器0位是保护允许位PE(Protedted Enable)，用于启动保护模式，如果PE位置1，则保护模式启动，如果PE=0，则在实模式下运行。
     orl $CR0_PE_ON, %eax
     movl %eax, %cr0
 
     # Jump to next instruction, but in 32-bit code segment.
     # Switches processor into 32-bit mode.
-    ljmp $PROT_MODE_CSEG, $protcseg
+    ljmp $PROT_MODE_CSEG, $protcseg                 # 第一个参数是段，第二个参数是偏移量
 
 .code32                                             # Assemble for 32-bit mode
 protcseg:
@@ -75,12 +75,12 @@
     jmp spin
 
 # Bootstrap GDT
-.p2align 2                                          # force 4 byte alignment
-gdt:
+.p2align 2                                          # force 4 byte alignment， 将位置计数器移动到4字节的倍数，如果已经是4字节的倍数则不会发生变化。
+gdt:                                                # 关于SEG_ASM（段描述符）的定义在ASM.h中，以type，base，lim为参数定义一个段描述符
     SEG_NULLASM                                     # null seg
-    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel
-    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel
-
+    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel，可读可执行
+    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel，可写但不可执行
+# GDTR长48位，其中高32位为基地址，低16位为段界限
 gdtdesc:
-    .word 0x17                                      # sizeof(gdt) - 1
-    .long gdt                                       # address gdt
+    .word 0x17                                      # sizeof(gdt) - 1，为什么是sizeof(gdt) - 1而不是sizeof(gdt)我也不是特别清楚，据说是规定
+    .long gdt                                       # address gdt，.long后面的参数为gdt运行时生成的值，即gdt表的地址
diff -r -u -P /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/boot/bootmain.c ./boot/bootmain.c
--- /home/hero945/Coding/os_kernel_lab_original/labcodes/lab1/boot/bootmain.c	2021-03-18 17:08:00.000000000 +0800
+++ ./boot/bootmain.c	2022-10-31 21:01:11.940783868 +0800
@@ -40,18 +40,18 @@
         /* do nothing */;
 }
 
-/* readsect - read a single sector at @secno into @dst */
+/* readsect - read a single sector at @secno into @dst，bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。 */
 static void
 readsect(void *dst, uint32_t secno) {
     // wait for disk to be ready
     waitdisk();
-
-    outb(0x1F2, 1);                         // count = 1
-    outb(0x1F3, secno & 0xFF);
-    outb(0x1F4, (secno >> 8) & 0xFF);
-    outb(0x1F5, (secno >> 16) & 0xFF);
-    outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0);
-    outb(0x1F7, 0x20);                      // cmd 0x20 - read sectors
+    // 发出读取扇区的命令
+    outb(0x1F2, 1);                            // count = 1，读一个扇区
+    outb(0x1F3, secno & 0xFF);                 // LBA参数的0-7位
+    outb(0x1F4, (secno >> 8) & 0xFF);          // LBA参数的8-15位
+    outb(0x1F5, (secno >> 16) & 0xFF);         // LBA参数的16-23位
+    outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0); // 第0~3位是LBA模式的24-27位;第4位为0，代表主盘;第6位：为1=LBA模式(0 = CHS模式);第7位和第5位必须为1
+    outb(0x1F7, 0x20);                         // cmd 0x20 - read sectors
 
     // wait for disk to be ready
     waitdisk();
